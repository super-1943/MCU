	.module jifeng_jieshou.c
	.area text(rom, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
	.area lit(rom, con, rel)
_ling16::
	.byte 0,224
	.byte 240,8
	.byte 8,24
	.byte 240,192
	.byte 0,15
	.byte 31,32
	.byte 32,48
	.byte 31,7
	.dbsym e ling16 _ling16 A[16:16]kc
_yi16::
	.byte 0,0
	.byte 16,240
	.byte 248,0
	.byte 0,0
	.byte 0,0
	.byte 32,63
	.byte 63,32
	.byte 32,0
	.dbsym e yi16 _yi16 A[16:16]kc
_er16::
	.byte 0,'p
	.byte 'x,8
	.byte 8,152
	.byte 248,'p
	.byte 0,48
	.byte 56,52
	.byte 50,49
	.byte 48,56
	.dbsym e er16 _er16 A[16:16]kc
_san16::
	.byte 0,48
	.byte 56,136
	.byte 136,248
	.byte 'p,0
	.byte 0,24
	.byte 56,33
	.byte 33,51
	.byte 30,12
	.dbsym e san16 _san16 A[16:16]kc
_si16::
	.byte 0,0
	.byte 128,96
	.byte 48,248
	.byte 248,0
	.byte 0,6
	.byte 5,36
	.byte 36,63
	.byte 63,36
	.dbsym e si16 _si16 A[16:16]kc
_wu16::
	.byte 0,240
	.byte 248,136
	.byte 136,136
	.byte 8,0
	.byte 0,25
	.byte 57,32
	.byte 32,49
	.byte 31,6
	.dbsym e wu16 _wu16 A[16:16]kc
_liu16::
	.byte 0,224
	.byte 240,136
	.byte 136,152
	.byte 152,0
	.byte 0,15
	.byte 63,32
	.byte 32,32
	.byte 31,14
	.dbsym e liu16 _liu16 A[16:16]kc
_qi16::
	.byte 0,56
	.byte 24,8
	.byte 136,232
	.byte 56,8
	.byte 0,0
	.byte 0,62
	.byte 63,0
	.byte 0,0
	.dbsym e qi16 _qi16 A[16:16]kc
_ba16::
	.byte 0,'p
	.byte 248,140
	.byte 140,140
	.byte 248,'p
	.byte 0,14
	.byte 31,49
	.byte 49,51
	.byte 31,14
	.dbsym e ba16 _ba16 A[16:16]kc
_jiu16::
	.byte 0,240
	.byte 248,8
	.byte 8,24
	.byte 248,240
	.byte 0,25
	.byte 51,50
	.byte 50,59
	.byte 31,15
	.dbsym e jiu16 _jiu16 A[16:16]kc
_xsdian::
	.byte 0,0
	.byte 0,0
	.byte 0,0
	.byte 0,0
	.byte 0,0
	.byte 0,0
	.byte 48,48
	.byte 48,0
	.dbsym e xsdian _xsdian A[16:16]kc
_wu::
	.byte 0,64
	.byte 'B,'B
	.byte 'B,'B
	.byte 254,'B
	.byte 194,'B
	.byte 'C,'B
	.byte 96,64
	.byte 0,0
	.byte 0,128
	.byte 64,32
	.byte 24,6
	.byte 1,0
	.byte 63,64
	.byte 64,64
	.byte 64,64
	.byte 'p,0
	.dbsym e wu _wu A[32:32]kc
_xian::
	.byte 0,32
	.byte 48,172
	.byte 'c,32
	.byte 48,32
	.byte 32,255
	.byte 144,146
	.byte 148,208
	.byte 128,0
	.byte 32,'b
	.byte 35,18
	.byte 18,18
	.byte 'A,'A
	.byte 33,23
	.byte 24,36
	.byte 'B,128
	.byte 224,0
	.dbsym e xian _xian A[32:32]kc
_yao::
	.byte 64,'B
	.byte 'D,204
	.byte 0,'B
	.byte 54,42
	.byte 34,254
	.byte 33,41
	.byte 37,128
	.byte 0,0
	.byte 0,64
	.byte 32,31
	.byte 33,'A
	.byte 93,'I
	.byte 'I,'O
	.byte 'I,'I
	.byte 93,'a
	.byte 33,0
	.dbsym e yao _yao A[32:32]kc
_kong::
	.byte 16,16
	.byte 16,255
	.byte 144,'P
	.byte 12,'D
	.byte 36,21
	.byte 6,20
	.byte 36,'T
	.byte 12,0
	.byte 2,'B
	.byte 129,127
	.byte 0,64
	.byte 'B,'B
	.byte 'B,'B
	.byte 126,'B
	.byte 'C,'b
	.byte 64,0
	.dbsym e kong _kong A[32:32]kc
_xi::
	.byte 0,2
	.byte 34,34
	.byte 50,46
	.byte 162,'b
	.byte 34,34
	.byte 145,9
	.byte 1,0
	.byte 0,0
	.byte 0,0
	.byte 'B,34
	.byte 26,'C
	.byte 130,126
	.byte 2,2
	.byte 10,19
	.byte 'f,0
	.byte 0,0
	.dbsym e xi _xi A[32:32]kc
_tong::
	.byte 32,48
	.byte 172,'c
	.byte 48,136
	.byte 200,168
	.byte 153,142
	.byte 136,168
	.byte 204,136
	.byte 0,0
	.byte 34,'g
	.byte 34,18
	.byte 146,64
	.byte 48,15
	.byte 0,0
	.byte 63,64
	.byte 64,'A
	.byte 'p,0
	.dbsym e tong _tong A[32:32]kc
_ji::
	.byte 32,48
	.byte 172,'c
	.byte 48,0
	.byte 254,136
	.byte 144,160
	.byte 255,160
	.byte 144,152
	.byte 0,0
	.byte 34,'g
	.byte 34,18
	.byte 18,0
	.byte 127,'H
	.byte 'D,'B
	.byte 127,'B
	.byte 'D,'l
	.byte 64,0
	.dbsym e ji _ji A[32:32]kc
_dian::
	.byte 0,248
	.byte 'H,'H
	.byte 'H,'H
	.byte 255,'H
	.byte 'H,'H
	.byte 'H,252
	.byte 8,0
	.byte 0,0
	.byte 0,7
	.byte 2,2
	.byte 2,2
	.byte 63,'B
	.byte 'B,'B
	.byte 'B,'G
	.byte 64,'p
	.byte 0,0
	.dbsym e dian _dian A[32:32]kc
_qi::
	.byte 128,128
	.byte 159,145
	.byte 145,145
	.byte 159,224
	.byte 159,145
	.byte 177,209
	.byte 159,192
	.byte 128,0
	.byte 8,8
	.byte 252,140
	.byte 138,138
	.byte 249,0
	.byte 249,138
	.byte 138,140
	.byte 252,8
	.byte 8,0
	.dbsym e qi _qi A[32:32]kc
_kai::
	.byte 128,130
	.byte 130,130
	.byte 254,130
	.byte 130,130
	.byte 130,130
	.byte 254,130
	.byte 131,194
	.byte 128,0
	.byte 0,128
	.byte 64,48
	.byte 15,0
	.byte 0,0
	.byte 0,0
	.byte 255,0
	.byte 0,0
	.byte 0,0
	.dbsym e kai _kai A[32:32]kc
_feng::
	.byte 0,240
	.byte 16,255
	.byte 16,248
	.byte 144,136
	.byte 'O,'T
	.byte 164,'T
	.byte 'L,196
	.byte 64,0
	.byte 32,'g
	.byte 34,31
	.byte 18,59
	.byte 0,20
	.byte 21,21
	.byte 255,21
	.byte 21,20
	.byte 0,0
	.dbsym e feng _feng A[32:32]kc
_ming::
	.byte 0,252
	.byte 'D,'D
	.byte 'D,254
	.byte 4,0
	.byte 254,34
	.byte 34,34
	.byte 34,255
	.byte 2,0
	.byte 0,15
	.byte 4,4
	.byte 4,143
	.byte 64,48
	.byte 15,2
	.byte 2,'B
	.byte 130,127
	.byte 0,0
	.dbsym e ming _ming A[32:32]kc
_xiang::
	.byte 0,252
	.byte 4,4
	.byte 254,4
	.byte 248,8
	.byte 204,'J
	.byte 'I,200
	.byte 8,252
	.byte 8,0
	.byte 0,31
	.byte 8,8
	.byte 31,0
	.byte 255,0
	.byte 15,8
	.byte 8,'O
	.byte 128,127
	.byte 0,0
	.dbsym e xiang _xiang A[32:32]kc
	.area data(ram, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
_TxAddress::
	.blkb 2
	.area idata
	.byte 204,204
	.area data(ram, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
	.blkb 2
	.area idata
	.byte 204,204
	.area data(ram, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
	.dbsym e TxAddress _TxAddress A[4:4]c
_RFConf::
	.blkb 2
	.area idata
	.byte 0,'L
	.area data(ram, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
	.blkb 2
	.area idata
	.byte 12,'D
	.area data(ram, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
	.blkb 2
	.area idata
	.byte 4,4
	.area data(ram, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
	.blkb 2
	.area idata
	.byte 204,204
	.area data(ram, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
	.blkb 2
	.area idata
	.byte 204,204
	.area data(ram, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
	.blkb 1
	.area idata
	.byte 'X
	.area data(ram, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
	.dbsym e RFConf _RFConf A[11:11]c
	.area text(rom, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
	.dbfunc e Delay _Delay fV
;              i -> R20,R21
;              x -> R16,R17
	.even
_Delay::
	rcall push_gset1
	.dbline -1
	.dbline 183
; //ICC-AVR application builder : 2007-8-11 20:37:32
; // Target : M16
; // Crystal: 8.0000Mhz
; #include <iom16v.h>
; #include <macros.h>
; #define uint  unsigned int
; #define uchar unsigned char
; //---------------------------------模式控制定义---------------------------------
; //#define  nrf905_TX_EN	  PB0	    //输出1
; #define   Hign_nrf905_TX_EN    PORTB |= (1 << PB0);   
; #define   Low_nrf905_TX_EN     PORTB &= ~(1 << PB0); 
; //#define  nrf905_TRX_CE  PD5 	    //输出1
; #define   Hign_nrf905_TRX_CE    PORTD |= (1 << PD5);   
; #define   Low_nrf905_TRX_CE     PORTD &= ~(1 << PD5); 
; //#define  nrf905_PWR     PB1 	    //输出1
; #define   Hign_nrf905_PWR    PORTB |= (1 << PB1);   
; #define   Low_nrf905_PWR     PORTB &= ~(1 << PB1); 
; //--------------------------------NRF905-SPI口接口定义--------------------------
; //#define  nrf905_MISO	  PB6   	//输入0
; //#define  nrf905_MOSI    PB5	    //输出1
; //#define  nrf905_SCK     PB7	    //输出1
; #define   Low_nrf905_SCK     PORTB &= ~(1 << PB7); 
; //#define  nrf905_CSN     PB4		//输出1		
; #define   Hign_nrf905_CSN    PORTB |= (1 << PB4);   
; #define   Low_nrf905_CSN     PORTB &= ~(1 << PB4); 						
; //-------------------------------NRF905状态输出口-------------------------------
; //#define  nrf905_CD      PD4	    //输入0
; #define   Hign_nrf905_CD    PORTD |= (1 << PD4);   
; #define   Low_nrf905_CD     PORTD &= ~(1 << PD4); 
; #define   Read_nrf905_CD    PINB & (1 << PD4);
; //#define  nrf905_AM      PB3	    //输入0
; #define   Hign_nrf905_AM    PORTB |= (1 << PB3);   
; #define   Low_nrf905_AM     PORTB &= ~(1 << PB3); 
; #define   Read_nrf905_AM    PINB & (1 << PB3);
; //#define  nrf905_DR      PB2  		//输入0
; #define   Hign_nrf905_DR     PORTB |= (1 << PB2);   
; #define   Low_nrf905_DR     PORTB &= ~(1 << PB2); 
; #define   Read_nrf905_DR    PINB & (1 << PB2);   
; //------------------------------LCD状态输出口-----------------------------------
; //#define LCD_CS           PC7  	//1-out
; //#define   Out_LCD_CS       DDRC |= (1 << PC7);
; #define   Hign_LCD_CS      PORTC |= (1 << PC7);   
; #define   Low_LCD_CS       PORTC &= ~(1 << PC7); 
; //#define LCD_RESET         PC6 	//1-out
; //#define   Out_CD_RESET      DDRC |= (1 << PC6);
; #define   Hign_LCD_RESET    PORTC |= (1 << PC6);   
; #define   Low_LCD_RESET     PORTC &= ~(1 << PC6); 
; //#define LCD_RS           PC5 	//1-out
; //#define   Out_LCD_RS       DDRC |= (1 << PC5);
; #define   Hign_LCD_RS      PORTC |= (1 << PC5);   
; #define   Low_LCD_RS       PORTC &= ~(1 << PC5); 
; //#define LCD_SCL        PC4 	//1-out
; //#define   Out_LCD_SCL      DDRC |= (1 << PC4); 
; #define   Hign_LCD_SCL     PORTC |= (1 << PC4);   
; #define   Low_LCD_SCL      PORTC &= ~(1 << PC4);
; //#define LCD_SI         PC3  	//1-ou
; //#define   Out_LCD_SI      DDRC |= (1 << PC3); 
; #define   Hign_LCD_SI    PORTC |= (1 << PC3);   
; #define   Low_LCD_SI     PORTC &= ~(1 << PC3);
; //-------------------------------BELL蜂明器-------------------------------------
; #define   Hign_BELL  PORTD |= (1 << PD6);   
; #define   Low_BELL     PORTD &= ~(1 << PD6); 
; //-------------------------------JDQ继电器--------------------------------------
; #define   Hign_JDQ  PORTD |= (1 << PD7)
; #define   Low_JDQ     PORTD &= ~(1 << PD7)
; //------------------------LCD字库---------------------------------------------
; const uchar ling16[16]= 
; {0x00,0xE0,0xF0,0x08,0x08,0x18,0xF0,0xC0,0x00,0x0F,0x1F,0x20,0x20,0x30,0x1F,0x07};//0
; const uchar yi16[16]= 
; {0x00,0x00,0x10,0xF0,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x3F,0x20,0x20,0x00};//1
; const uchar er16[16]= 
; {0x00,0x70,0x78,0x08,0x08,0x98,0xF8,0x70,0x00,0x30,0x38,0x34,0x32,0x31,0x30,0x38};//2
; const uchar san16[16]=
; {0x00,0x30,0x38,0x88,0x88,0xF8,0x70,0x00,0x00,0x18,0x38,0x21,0x21,0x33,0x1E,0x0C};//3
; const uchar si16[16]= 
; {0x00,0x00,0x80,0x60,0x30,0xF8,0xF8,0x00,0x00,0x06,0x05,0x24,0x24,0x3F,0x3F,0x24};//4
; const uchar wu16[16]= 
; {0x00,0xF0,0xF8,0x88,0x88,0x88,0x08,0x00,0x00,0x19,0x39,0x20,0x20,0x31,0x1F,0x06};//5
; const uchar liu16[16]= 
; {0x00,0xE0,0xF0,0x88,0x88,0x98,0x98,0x00,0x00,0x0F,0x3F,0x20,0x20,0x20,0x1F,0x0E};//6
; const uchar qi16[16]= 
; {0x00,0x38,0x18,0x08,0x88,0xE8,0x38,0x08,0x00,0x00,0x00,0x3E,0x3F,0x00,0x00,0x00};//7
; const uchar ba16[16]= 
; {0x00,0x70,0xF8,0x8C,0x8C,0x8C,0xF8,0x70,0x00,0x0E,0x1F,0x31,0x31,0x33,0x1F,0x0E};//8
; const uchar jiu16[16]= 
; {0x00,0xF0,0xF8,0x08,0x08,0x18,0xF8,0xF0,0x00,0x19,0x33,0x32,0x32,0x3B,0x1F,0x0F};//9
; const uchar xsdian[16]=
; {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x30,0x00};//.
; 
; //-------------------------------------------------------------------------------
; const uchar wu[32]=															 	 //无
; {0x00,0x40,0x42,0x42,0x42,0x42,0xFE,0x42,0xC2,0x42,0x43,0x42,0x60,0x40,0x00,0x00,
; 0x00,0x80,0x40,0x20,0x18,0x06,0x01,0x00,0x3F,0x40,0x40,0x40,0x40,0x40,0x70,0x00};
; const uchar xian[32]=															 //线
; {0x00,0x20,0x30,0xAC,0x63,0x20,0x30,0x20,0x20,0xFF,0x90,0x92,0x94,0xD0,0x80,0x00,
; 0x20,0x62,0x23,0x12,0x12,0x12,0x41,0x41,0x21,0x17,0x18,0x24,0x42,0x80,0xE0,0x00};
; const uchar yao[32]=															 //遥
; {0x40,0x42,0x44,0xCC,0x00,0x42,0x36,0x2A,0x22,0xFE,0x21,0x29,0x25,0x80,0x00,0x00,
; 0x00,0x40,0x20,0x1F,0x21,0x41,0x5D,0x49,0x49,0x4F,0x49,0x49,0x5D,0x61,0x21,0x00};
; const uchar kong[32]=															 //控
; {0x10,0x10,0x10,0xFF,0x90,0x50,0x0C,0x44,0x24,0x15,0x06,0x14,0x24,0x54,0x0C,0x00,
; 0x02,0x42,0x81,0x7F,0x00,0x40,0x42,0x42,0x42,0x42,0x7E,0x42,0x43,0x62,0x40,0x00};
; const uchar xi[32]=															 	 //系
; {0x00,0x02,0x22,0x22,0x32,0x2E,0xA2,0x62,0x22,0x22,0x91,0x09,0x01,0x00,0x00,0x00,
; 0x00,0x00,0x42,0x22,0x1A,0x43,0x82,0x7E,0x02,0x02,0x0A,0x13,0x66,0x00,0x00,0x00};
; const uchar tong[32]=															//统
; {0x20,0x30,0xAC,0x63,0x30,0x88,0xC8,0xA8,0x99,0x8E,0x88,0xA8,0xCC,0x88,0x00,0x00,
; 0x22,0x67,0x22,0x12,0x92,0x40,0x30,0x0F,0x00,0x00,0x3F,0x40,0x40,0x41,0x70,0x00};
; const uchar ji[32]=																//继											//继
; {0x20,0x30,0xAC,0x63,0x30,0x00,0xFE,0x88,0x90,0xA0,0xFF,0xA0,0x90,0x98,0x00,0x00,
; 0x22,0x67,0x22,0x12,0x12,0x00,0x7F,0x48,0x44,0x42,0x7F,0x42,0x44,0x6C,0x40,0x00};
; const uchar dian[32]=															//电
; {0x00,0xF8,0x48,0x48,0x48,0x48,0xFF,0x48,0x48,0x48,0x48,0xFC,0x08,0x00,0x00,0x00,
; 0x00,0x07,0x02,0x02,0x02,0x02,0x3F,0x42,0x42,0x42,0x42,0x47,0x40,0x70,0x00,0x00};
; const uchar qi[32]=																//器
; {0x80,0x80,0x9F,0x91,0x91,0x91,0x9F,0xE0,0x9F,0x91,0xB1,0xD1,0x9F,0xC0,0x80,0x00,
; 0x08,0x08,0xFC,0x8C,0x8A,0x8A,0xF9,0x00,0xF9,0x8A,0x8A,0x8C,0xFC,0x08,0x08,0x00};
; const uchar kai[32]=															//开
; {0x80,0x82,0x82,0x82,0xFE,0x82,0x82,0x82,0x82,0x82,0xFE,0x82,0x83,0xC2,0x80,0x00,
; 0x00,0x80,0x40,0x30,0x0F,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00};
; const uchar feng[32]=															//蜂
; {0x00,0xF0,0x10,0xFF,0x10,0xF8,0x90,0x88,0x4F,0x54,0xA4,0x54,0x4C,0xC4,0x40,0x00,
; 0x20,0x67,0x22,0x1F,0x12,0x3B,0x00,0x14,0x15,0x15,0xFF,0x15,0x15,0x14,0x00,0x00};
; const uchar ming[32]=															//明
; {0x00,0xFC,0x44,0x44,0x44,0xFE,0x04,0x00,0xFE,0x22,0x22,0x22,0x22,0xFF,0x02,0x00,
; 0x00,0x0F,0x04,0x04,0x04,0x8F,0x40,0x30,0x0F,0x02,0x02,0x42,0x82,0x7F,0x00,0x00};
; const uchar xiang[32]=																//响
; {0x00,0xFC,0x04,0x04,0xFE,0x04,0xF8,0x08,0xCC,0x4A,0x49,0xC8,0x08,0xFC,0x08,0x00,
; 0x00,0x1F,0x08,0x08,0x1F,0x00,0xFF,0x00,0x0F,0x08,0x08,0x4F,0x80,0x7F,0x00,0x00};
; //----------------------------------NRF905-SPI指令------------------------------
; #define WC	0x00
; #define RRC	0x10
; #define WTP	0x20
; #define RTP	0x21
; #define WTA	0x22
; #define RTA	0x23
; #define RRP	0x24
; //---------------------------------发送数据-------------------------------------
; uchar TxRxBuffer[4];
; //----------------------------------接收地址------------------------------------
; uchar TxAddress[4]={0xcc,0xcc,0xcc,0xcc };    
; //------------------------------------------------------------------------------
; uchar count1 ,count2;
; //----------------------------------寄存器配置----------------------------------
; uchar RFConf[11]=
; {
;   0x00,                            //配置命令//
;   0x4c,                           //CH_NO,配置频段在430MHZ
;   0x0C,                          //输出功率为10db,不重发，节电为正常模式
;   0x44,                         //地址宽度设置，为4字节
;   0x04,0x04,                   //接收发送有效数据长度为32字节
;   0xCC,0xCC,0xCC,0xCC,        //接收地址
;   0x58,                      //CRC充许，8位CRC校验，外部时钟信号不使能，16M晶振
; };
; //----------------------------------NRF905函数申明------------------------------
; void Delay(uint x);						       //延时子程序																							
; void Spi_initial();                            //SPI初始化
; uchar SpiReadSpiWrite(unsigned char cData);    //SPI读写子程序
; void system_Init(void);		   				   //系统初始化
; void Config905(void);						   //NRF905初始化子程序
; void TxPacket(void);						
; void SetTxMode(void);						   //数据发送
; void SetRxMode(void);						   //
; void TX(void);
; unsigned char CheckDR(void);
; void RxPacket(void);
; void  RX(void);
; //-------------------------------串口函数申明-----------------------------------
; void StartUART(void);
; void R_S_Byte(uchar R_Byte);
; //-------------------------------LCD函数申明------------------------------------
; void LCD_Delay(uint time);
; void Lcd_init(void);
; void Lcd_Write_Data(uchar DATA) ;
; void Lcd_Write_command(uchar COMMAND);
; void Lcd_CURSOR(uchar add_page,uchar add_col)  ;
; void Lcd_Clear(void) ;
; void dis_1616hz(uchar x1,uchar x2,uchar row,const uchar hz[]);
; void dis_168hz(uchar x1,uchar row,const uchar hz[]);
; void LCDtime();
; //----------------------------------100us延时子程序-----------------------------
; void Delay(uint x)
; {
	rjmp L3
L2:
	.dbline 186
	clr R20
	clr R21
	rjmp L8
L5:
	.dbline 186
L6:
	.dbline 186
	subi R20,255  ; offset = 1
	sbci R21,255
L8:
	.dbline 186
	cpi R20,80
	ldi R30,0
	cpc R21,R30
	brlo L5
L3:
	.dbline 185
; 	uint i;
; 	while(x--)
	mov R2,R16
	mov R3,R17
	subi R16,1
	sbci R17,0
	tst R2
	brne L2
	tst R3
	brne L2
X0:
	.dbline -2
L1:
	rcall pop_gset1
	.dbline 0 ; func end
	ret
	.dbsym r i 20 i
	.dbsym r x 16 i
	.dbend
	.dbfunc e Spi_initial _Spi_initial fV
	.even
_Spi_initial::
	.dbline -1
	.dbline 190
; 	for(i=0;i<80;i++);
; }
; //----------------------------------SPI初始化-----------------------------------
; void Spi_initial()
; {
	.dbline 191
; 	SPCR   = (1<<SPE)|(1<<MSTR)|(0<<CPOL)|(0<<SPR0);// 主机模式，fck/16, SPI方式0
	ldi R24,80
	out 0xd,R24
	.dbline -2
L9:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e SpiReadSpiWrite _SpiReadSpiWrite fc
;          cData -> R16
	.even
_SpiReadSpiWrite::
	.dbline -1
	.dbline 195
; }
; //---------------------------------SPI读写程序----------------------------------	
; uchar SpiReadSpiWrite(unsigned char cData)
; {
	.dbline 196
; 	SPDR = cData;
	out 0xf,R16
L11:
	.dbline 198
	.dbline 198
L12:
	.dbline 197
; 	while(!(SPSR & (1<<SPIF) ))  // 等待SPI发送完毕
	sbis 0xe,7
	rjmp L11
	.dbline 198
; 	{};			
	.dbline 199
; 	return SPDR;
	in R16,0xf
	.dbline -2
L10:
	.dbline 0 ; func end
	ret
	.dbsym r cData 16 c
	.dbend
	.dbfunc e system_Init _system_Init fV
	.even
_system_Init::
	.dbline -1
	.dbline 203
; }
; //--------------------------------系统状态初始化--------------------------------
; void system_Init(void)			
; {
	.dbline 205
; 
;    	Hign_nrf905_CSN;			// SPI使能
	sbi 0x18,4
	.dbline 205
	.dbline 206
; 	Low_nrf905_SCK;				
	cbi 0x18,7
	.dbline 206
	.dbline 207
; 	Low_nrf905_DR;				// DR=0
	cbi 0x18,2
	.dbline 207
	.dbline 208
; 	Low_nrf905_AM;				// AM=0
	cbi 0x18,3
	.dbline 208
	.dbline 209
; 	Low_nrf905_CD;				// CD=0
	cbi 0x12,4
	.dbline 209
	.dbline 210
; 	Hign_nrf905_PWR;		    // PWR=1
	sbi 0x18,1
	.dbline 210
	.dbline 211
; 	Low_nrf905_TRX_CE;			// nrf905_TRX_CE=0
	cbi 0x12,5
	.dbline 211
	.dbline 212
; 	Low_nrf905_TX_EN ;			// nrf905_TX_EN=0
	cbi 0x18,0
	.dbline 212
	.dbline -2
L14:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e Config905 _Config905 fV
;              i -> R20
	.even
_Config905::
	rcall push_gset1
	.dbline -1
	.dbline 216
; }
; //--------------------------------NRF905寄存器初始化函数------------------------
; void Config905(void)
; {
	.dbline 218
; 	uchar i;
; 	Low_nrf905_CSN;				//SPI使能											
	cbi 0x18,4
	.dbline 218
	.dbline 219
; 	Delay(1);				   
	ldi R16,1
	ldi R17,0
	rcall _Delay
	.dbline 220
; 	for (i=0;i<11;i++)			//NRF905配置字
	clr R20
	rjmp L19
L16:
	.dbline 221
	.dbline 222
	ldi R24,<_RFConf
	ldi R25,>_RFConf
	mov R30,R20
	clr R31
	add R30,R24
	adc R31,R25
	ldd R16,z+0
	rcall _SpiReadSpiWrite
	.dbline 223
L17:
	.dbline 220
	inc R20
L19:
	.dbline 220
	cpi R20,11
	brlo L16
	.dbline 224
; 	{
; 	 SpiReadSpiWrite(RFConf[i]);
; 	}
; 	Hign_nrf905_CSN;					// Disable Spi
	sbi 0x18,4
	.dbline 224
	.dbline -2
L15:
	rcall pop_gset1
	.dbline 0 ; func end
	ret
	.dbsym r i 20 c
	.dbend
	.dbfunc e TxPacket _TxPacket fV
;              i -> R20
	.even
_TxPacket::
	rcall push_gset1
	.dbline -1
	.dbline 228
; }
; //--------------------------------NRF905待发数据打包----------------------------
; void TxPacket(void)
; {
	.dbline 230
; 	uchar i;
; 	Low_nrf905_CSN;		   				// 使能Spi，允许对nrf905进行读写操作
	cbi 0x18,4
	.dbline 230
	.dbline 231
; 	Delay(1);
	ldi R16,1
	ldi R17,0
	rcall _Delay
	.dbline 232
; 	SpiReadSpiWrite(WTP);				// 写数据前先写写数据命令
	ldi R16,32
	rcall _SpiReadSpiWrite
	.dbline 233
; 	for (i=0;i<32;i++)
	clr R20
	rjmp L24
L21:
	.dbline 234
	.dbline 235
	ldi R24,<_TxRxBuffer
	ldi R25,>_TxRxBuffer
	mov R30,R20
	clr R31
	add R30,R24
	adc R31,R25
	ldd R16,z+0
	rcall _SpiReadSpiWrite
	.dbline 236
L22:
	.dbline 233
	inc R20
L24:
	.dbline 233
	cpi R20,32
	brlo L21
	.dbline 237
; 	{
; 	SpiReadSpiWrite(TxRxBuffer[i]);		// 待发送的32字节数据
; 	}						
; 	Hign_nrf905_CSN;
	sbi 0x18,4
	.dbline 237
	.dbline 238
; 	Delay(1);							// 关闭Spi，不允许对nrf905进行读写操作
	ldi R16,1
	ldi R17,0
	rcall _Delay
	.dbline 239
; 	Low_nrf905_CSN;						// 使能Spi
	cbi 0x18,4
	.dbline 239
	.dbline 240
; 	SpiReadSpiWrite(WTA);				// 写地址前首先先写地址命令
	ldi R16,34
	rcall _SpiReadSpiWrite
	.dbline 241
; 	for (i=0;i<4;i++)					// 写入4 bytes 接收地址
	clr R20
	rjmp L28
L25:
	.dbline 242
	.dbline 243
	ldi R24,<_TxAddress
	ldi R25,>_TxAddress
	mov R30,R20
	clr R31
	add R30,R24
	adc R31,R25
	ldd R16,z+0
	rcall _SpiReadSpiWrite
	.dbline 244
L26:
	.dbline 241
	inc R20
L28:
	.dbline 241
	cpi R20,4
	brlo L25
	.dbline 245
; 	{
; 	SpiReadSpiWrite(TxAddress[i]);
; 	}
; 	Hign_nrf905_CSN;					// 关闭Spi
	sbi 0x18,4
	.dbline 245
	.dbline 246
; 	Hign_nrf905_TRX_CE;					// Set TRX_CE high,start Tx data transmission
	sbi 0x12,5
	.dbline 246
	.dbline 247
; 	Delay(1);							// 等待DR变高
	ldi R16,1
	ldi R17,0
	rcall _Delay
	.dbline 248
; 	Low_nrf905_TRX_CE;					// 设置TRX_CE=0
	cbi 0x12,5
	.dbline 248
	.dbline -2
L20:
	rcall pop_gset1
	.dbline 0 ; func end
	ret
	.dbsym r i 20 c
	.dbend
	.dbfunc e SetTxMode _SetTxMode fV
	.even
_SetTxMode::
	.dbline -1
	.dbline 252
; }
; //------------------------------设置发送模式------------------------------------
; void SetTxMode(void)
; {
	.dbline 253
; 	Low_nrf905_TRX_CE;				//
	cbi 0x12,5
	.dbline 253
	.dbline 254
; 	Hign_nrf905_TX_EN;				//发送使能
	sbi 0x18,0
	.dbline 254
	.dbline 255
; 	Delay(2); 				// delay for mode change(>=650us)
	ldi R16,2
	ldi R17,0
	rcall _Delay
	.dbline -2
L29:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e SetRxMode _SetRxMode fV
	.even
_SetRxMode::
	.dbline -1
	.dbline 259
; }
; //------------------------------设置接收模式激发--------------------------------
; void SetRxMode(void)
; {
	.dbline 260
; 	Low_nrf905_TX_EN;
	cbi 0x18,0
	.dbline 260
	.dbline 261
; 	Hign_nrf905_TRX_CE;
	sbi 0x12,5
	.dbline 261
	.dbline 262
; 	Delay(10); 					// delay for mode change(>=650us)
	ldi R16,10
	ldi R17,0
	rcall _Delay
	.dbline -2
L30:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e TX _TX fV
	.even
_TX::
	.dbline -1
	.dbline 266
; }
; //------------------------------发送数据----------------------------------------
; void TX(void)
; {
	.dbline 267
;      SetTxMode();	   // Set nRF905 in Tx mode
	rcall _SetTxMode
	.dbline 268
; 	 TxPacket();			   // Send data by nRF905
	rcall _TxPacket
	.dbline -2
L31:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e CheckDR _CheckDR fc
	.even
_CheckDR::
	.dbline -1
	.dbline 272
; }
; //-----------------------------判断是否收到数据---------------------------------
; unsigned char CheckDR(void)		//检查是否有新数据传入 
; {
	.dbline 273
; 	if (PINB & (1 << PB2))
	sbis 0x16,2
	rjmp L33
	.dbline 274
; 	{
	.dbline 275
; 		return 1; 	 	  		//收到数据
	ldi R16,1
	rjmp L32
L33:
	.dbline 278
; 	}
; 	else
; 	{
	.dbline 279
; 		return 0;
	clr R16
	.dbline -2
L32:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e RxPacket _RxPacket fV
;              i -> R20
	.even
_RxPacket::
	rcall push_gset1
	.dbline -1
	.dbline 284
; 	}
; }
; //-----------------------------------读接收数据包-------------------------------
; void RxPacket(void)							//读数据
; {
	.dbline 286
; 	uchar i;
;     Low_nrf905_TRX_CE;
	cbi 0x12,5
	.dbline 286
	.dbline 287
; 	Low_nrf905_CSN;						    // 使能SPI
	cbi 0x18,4
	.dbline 287
	.dbline 288
;     Delay(1);
	ldi R16,1
	ldi R17,0
	rcall _Delay
	.dbline 289
; 	SpiReadSpiWrite(RRP);				   // 写入数据接收缓冲区数据命令
	ldi R16,36
	rcall _SpiReadSpiWrite
	.dbline 290
; 	for (i = 0 ;i < 4 ;i++)
	clr R20
	rjmp L39
L36:
	.dbline 291
	.dbline 292
	clr R16
	rcall _SpiReadSpiWrite
	ldi R24,<_TxRxBuffer
	ldi R25,>_TxRxBuffer
	mov R30,R20
	clr R31
	add R30,R24
	adc R31,R25
	std z+0,R16
	.dbline 293
L37:
	.dbline 290
	inc R20
L39:
	.dbline 290
	cpi R20,4
	brlo L36
	.dbline 294
; 	{   
; 	TxRxBuffer[i]=SpiReadSpiWrite(0);	  // 读取数据接收缓冲区数据       
; 	}
; 	Hign_nrf905_CSN;
	sbi 0x18,4
	.dbline 294
	.dbline 295
;     Delay(2);                            //
	ldi R16,2
	ldi R17,0
	rcall _Delay
	.dbline 296
; 	Hign_nrf905_TRX_CE;							
	sbi 0x12,5
	.dbline 296
	.dbline -2
L35:
	rcall pop_gset1
	.dbline 0 ; func end
	ret
	.dbsym r i 20 c
	.dbend
	.dbfunc e RX _RX fV
	.even
_RX::
	.dbline -1
	.dbline 300
; }
; //--------------------------------设置接收模式----------------------------------
; void  RX(void)
; {
	.dbline 301
;     SetRxMode();			          //设置NRF905接收模式
	rcall _SetRxMode
L41:
	.dbline 302
L42:
	.dbline 302
;     while (CheckDR()==0);	         //等待接收完成
	rcall _CheckDR
	tst R16
	breq L41
	.dbline 303
; 	RxPacket();                     //读取接收数据缓冲区
	rcall _RxPacket
	.dbline 304
; 	Delay(10);
	ldi R16,10
	ldi R17,0
	rcall _Delay
	.dbline -2
L40:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e LCD_Delay _LCD_Delay fV
;              i -> R20,R21
;           time -> R16,R17
	.even
_LCD_Delay::
	rcall push_gset1
	.dbline -1
	.dbline 311
; }
; //******************************************************************************
; //以下为LCD驱动
; //******************************************************************************
; //------------------------------------------------------------------------------
; void LCD_Delay(uint time)
; {
	.dbline 313
	mov R20,R16
	mov R21,R17
	rjmp L48
L45:
	.dbline 313
L46:
	.dbline 313
	subi R20,1
	sbci R21,0
L48:
	.dbline 313
; 	uint i;
; 	for(i=time;i>0;i--);
	cpi R20,0
	cpc R20,R21
	brne L45
X1:
	.dbline -2
L44:
	rcall pop_gset1
	.dbline 0 ; func end
	ret
	.dbsym r i 20 i
	.dbsym r time 16 i
	.dbend
	.dbfunc e Lcd_init _Lcd_init fV
	.even
_Lcd_init::
	.dbline -1
	.dbline 317
; }
; //---------------------------LCD初始化---------------------------------------
; void Lcd_init(void)
; {
	.dbline 318
;  	DDRC=0xF8;
	ldi R24,248
	out 0x14,R24
	.dbline 320
; 	//ASSR &= ~(1 <<AS2); 
; 	Hign_LCD_CS;
	sbi 0x15,7
	.dbline 320
	.dbline 321
; 	Low_LCD_RESET;	 	//硬复位
	cbi 0x15,6
	.dbline 321
	.dbline 322
; 	LCD_Delay(50);
	ldi R16,50
	ldi R17,0
	rcall _LCD_Delay
	.dbline 323
; 	Hign_LCD_RESET;			
	sbi 0x15,6
	.dbline 323
	.dbline 325
; 	////////////////////////////////////////////////////////
; 	Lcd_Write_command(0xe2);	//软复位RESet:initialize the internal functions
	ldi R16,226
	rcall _Lcd_Write_command
	.dbline 326
; 	LCD_Delay(100);
	ldi R16,100
	ldi R17,0
	rcall _LCD_Delay
	.dbline 327
; 	Lcd_Write_command(0xae);	//DISPLAY OFF 
	ldi R16,174
	rcall _Lcd_Write_command
	.dbline 328
; 	Lcd_Write_command(0xa1);	//ADC SELECT ON
	ldi R16,161
	rcall _Lcd_Write_command
	.dbline 329
; 	Lcd_Write_command(0xc0);	//SHL SELECT COM64-COM1
	ldi R16,192
	rcall _Lcd_Write_command
	.dbline 330
; 	Lcd_Write_command(0xa2);	//SET LCD BIAS(1/9)
	ldi R16,162
	rcall _Lcd_Write_command
	.dbline 332
; 	//////////////////////////////////////////////////////
; 	Lcd_Write_command(0x2c);//SET POWER CONTROL(VC=1)
	ldi R16,44
	rcall _Lcd_Write_command
	.dbline 333
; 	Lcd_Write_command(0x2e);	//SET POWER CONTROL(VR=1)
	ldi R16,46
	rcall _Lcd_Write_command
	.dbline 334
; 	Lcd_Write_command(0x2f);	//SET POWER CONTROL(VF=1)
	ldi R16,47
	rcall _Lcd_Write_command
	.dbline 336
; 	////////////////////////////////////////////////////////
; 	Lcd_Write_command(0x26);	//REGULATOR RESISTOR SELECT(R2 R1 R0)=110
	ldi R16,38
	rcall _Lcd_Write_command
	.dbline 337
; 	Lcd_Write_command(0x81);	//SET REFERENCE VOLTAGE MODE	
	ldi R16,129
	rcall _Lcd_Write_command
	.dbline 338
; 	Lcd_Write_command(0x3f);	//SET REFERENCE VOLTAGE REGISTER 2ch
	ldi R16,63
	rcall _Lcd_Write_command
	.dbline 340
; 	//////////////////////////////////////////////////////
; 	Lcd_Write_command(0x7f);	//START DISPLAY LINE(COM1)  起始行
	ldi R16,127
	rcall _Lcd_Write_command
	.dbline 342
; 	//////////////////////////////////////////////////////
; 	Lcd_Write_command(0xe0);	//写入数据时地址自动加1，读数据时不变
	ldi R16,224
	rcall _Lcd_Write_command
	.dbline 344
; 	//////////////////////////////////////////////////////////
; 	Lcd_Write_command(0xaf);	//DISPLAY ON  
	ldi R16,175
	rcall _Lcd_Write_command
	.dbline -2
L49:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e Lcd_Write_Data _Lcd_Write_Data fV
;              i -> R20,R21
;           temp -> R22,R23
;           DATA -> R20
	.even
_Lcd_Write_Data::
	rcall push_gset2
	mov R20,R16
	.dbline -1
	.dbline 348
; }
; //--------------------------------LCD写数据函数---------------------------------
; void Lcd_Write_Data(uchar DATA)              //写一个字节，再加一列，正好在一页
; {                                            //定好一页后，再一列一列的写
	.dbline 350
; 	int i,temp;
; 	temp=DATA;
	mov R22,R20
	clr R23
	.dbline 351
; 	Low_LCD_RS;		
	cbi 0x15,5
	.dbline 351
	.dbline 352
; 	Hign_LCD_CS;
	sbi 0x15,7
	.dbline 352
	.dbline 353
; 	Hign_LCD_SCL;
	sbi 0x15,4
	.dbline 353
	.dbline 354
; 	LCD_Delay(1);
	ldi R16,1
	ldi R17,0
	rcall _LCD_Delay
	.dbline 355
; 	Low_LCD_CS;
	cbi 0x15,7
	.dbline 355
	.dbline 356
; 	Low_LCD_SCL;
	cbi 0x15,4
	.dbline 356
	.dbline 357
; 	Hign_LCD_RS;		//RS=1 时为写数据
	sbi 0x15,5
	.dbline 357
	.dbline 358
; 	LCD_Delay(1);
	ldi R16,1
	ldi R17,0
	rcall _LCD_Delay
	.dbline 359
; 	for(i=0;i<8;i++)
	clr R20
	clr R21
L51:
	.dbline 360
; 	{
	.dbline 361
; 		Low_LCD_SCL;
	cbi 0x15,4
	.dbline 361
	.dbline 362
; 		if(temp&0x80)
	sbrs R22,7
	rjmp L55
	.dbline 363
; 		{
	.dbline 364
; 		Hign_LCD_SI;
	sbi 0x15,3
	.dbline 364
	.dbline 365
; 		}
	rjmp L56
L55:
	.dbline 367
; 		else
; 		{
	.dbline 368
; 		Low_LCD_SI;
	cbi 0x15,3
	.dbline 368
	.dbline 369
; 		}
L56:
	.dbline 370
	ldi R16,1
	ldi R17,0
	rcall _LCD_Delay
	.dbline 371
	lsl R22
	rol R23
	.dbline 372
	sbi 0x15,4
	.dbline 372
	.dbline 373
	ldi R16,1
	ldi R17,0
	rcall _LCD_Delay
	.dbline 374
	cbi 0x15,4
	.dbline 374
	.dbline 375
L52:
	.dbline 359
	subi R20,255  ; offset = 1
	sbci R21,255
	.dbline 359
	cpi R20,8
	ldi R30,0
	cpc R21,R30
	brlt L51
	.dbline 376
; 		LCD_Delay(1);
; 		temp=temp<<1;
; 		Hign_LCD_SCL;
; 		LCD_Delay(1);
; 		Low_LCD_SCL;
; 	}
; 	Low_LCD_RS;
	cbi 0x15,5
	.dbline 376
	.dbline 377
; 	Hign_LCD_CS;    //先cs置0，然后把数据都送到口上准备好（产生上升沿），最后才置片选cs为1	
	sbi 0x15,7
	.dbline 377
	.dbline -2
L50:
	rcall pop_gset2
	.dbline 0 ; func end
	ret
	.dbsym r i 20 I
	.dbsym r temp 22 I
	.dbsym r DATA 20 c
	.dbend
	.dbfunc e Lcd_Write_command _Lcd_Write_command fV
;              i -> R20
;           temp -> R22
;        COMMAND -> R20
	.even
_Lcd_Write_command::
	rcall push_gset2
	mov R20,R16
	.dbline -1
	.dbline 381
; }
; //---------------------------------LCD写命令函数--------------------------------
; void Lcd_Write_command(uchar COMMAND)
; {
	.dbline 383
; 	uchar i,temp;
; 	temp = COMMAND;
	mov R22,R20
	.dbline 384
; 	Hign_LCD_RS;		
	sbi 0x15,5
	.dbline 384
	.dbline 385
; 	Hign_LCD_CS;
	sbi 0x15,7
	.dbline 385
	.dbline 386
; 	Hign_LCD_SCL;
	sbi 0x15,4
	.dbline 386
	.dbline 387
; 	LCD_Delay(1);
	ldi R16,1
	ldi R17,0
	rcall _LCD_Delay
	.dbline 388
; 	Low_LCD_RS;		//RS=0 为写命令
	cbi 0x15,5
	.dbline 388
	.dbline 389
; 	Low_LCD_CS;
	cbi 0x15,7
	.dbline 389
	.dbline 390
; 	Low_LCD_SCL;
	cbi 0x15,4
	.dbline 390
	.dbline 391
; 	LCD_Delay(1);
	ldi R16,1
	ldi R17,0
	rcall _LCD_Delay
	.dbline 392
; 	for(i=0;i<8;i++)
	clr R20
	rjmp L61
L58:
	.dbline 393
; 	{
	.dbline 394
; 		Low_LCD_SCL;
	cbi 0x15,4
	.dbline 394
	.dbline 395
; 		if(temp&0x80)
	sbrs R22,7
	rjmp L62
	.dbline 396
; 		{
	.dbline 397
; 		Hign_LCD_SI;
	sbi 0x15,3
	.dbline 397
	.dbline 398
; 		}
	rjmp L63
L62:
	.dbline 400
; 		else
; 		{
	.dbline 401
; 		Low_LCD_SI;
	cbi 0x15,3
	.dbline 401
	.dbline 402
; 		}
L63:
	.dbline 403
	lsl R22
	.dbline 404
	ldi R16,1
	ldi R17,0
	rcall _LCD_Delay
	.dbline 405
	sbi 0x15,4
	.dbline 405
	.dbline 406
	ldi R16,1
	ldi R17,0
	rcall _LCD_Delay
	.dbline 407
	cbi 0x15,4
	.dbline 407
	.dbline 408
L59:
	.dbline 392
	inc R20
L61:
	.dbline 392
	cpi R20,8
	brlo L58
	.dbline 409
; 		temp=temp<<1;	
; 		LCD_Delay(1);
; 		Hign_LCD_SCL;
; 		LCD_Delay(1);
; 		Low_LCD_SCL;
; 	}
; 	Hign_LCD_RS;
	sbi 0x15,5
	.dbline 409
	.dbline 410
; 	Hign_LCD_CS;      //用了temp后，原来的command的就不会变了
	sbi 0x15,7
	.dbline 410
	.dbline -2
L57:
	rcall pop_gset2
	.dbline 0 ; func end
	ret
	.dbsym r i 20 c
	.dbsym r temp 22 c
	.dbsym r COMMAND 20 c
	.dbend
	.dbfunc e Lcd_CURSOR _Lcd_CURSOR fV
;        add_col -> R20
;       add_page -> R22
	.even
_Lcd_CURSOR::
	rcall push_gset2
	mov R20,R18
	mov R22,R16
	.dbline -1
	.dbline 414
; }
; //-------------------------------LCD光标函数------------------------------------
; void Lcd_CURSOR(uchar add_page,uchar add_col)               //光标定位	//8页(<0fh)， 且128列(>0fh)
; {                                                           //每页8行
	.dbline 415
; 	Lcd_Write_command(0xB0+(add_page&0x0f));     //+号为合成为一个字节（其实就是或）B0+0x
	mov R16,R22
	andi R16,15
	subi R16,80    ; addi 176
	rcall _Lcd_Write_command
	.dbline 416
; 	Lcd_Write_command(0x10|(add_col>>4)); //Set column address MSB(10+xx)即Y7 Y6 Y5 Y4
	mov R16,R20
	swap R16
	andi R16,#0x0F
	ori R16,16
	rcall _Lcd_Write_command
	.dbline 417
; 	Lcd_Write_command(add_col&0x0f);      //Set column address LSB(00+xx)即Y3 Y2 Y1 Y0
	mov R16,R20
	andi R16,15
	rcall _Lcd_Write_command
	.dbline -2
L64:
	rcall pop_gset2
	.dbline 0 ; func end
	ret
	.dbsym r add_col 20 c
	.dbsym r add_page 22 c
	.dbend
	.dbfunc e Lcd_Clear _Lcd_Clear fV
;              i -> R20
;              j -> R22
	.even
_Lcd_Clear::
	rcall push_gset2
	.dbline -1
	.dbline 421
; }
; //-------------------------------LCD清屏函数------------------------------------
; void Lcd_Clear(void)                         //128x64字节,实际中一般要多
; {	
	.dbline 423
; 	uchar i,j;
; 	for(i=0;i<9;i++)                     //>8页
	clr R20
	rjmp L69
L66:
	.dbline 424
; 	{
	.dbline 425
; 		 Lcd_CURSOR(i,0);		
	clr R18
	mov R16,R20
	rcall _Lcd_CURSOR
	.dbline 426
; 		 for(j=0;j<132;j++)          //>128列
	clr R22
	rjmp L73
L70:
	.dbline 427
	.dbline 428
	mov R18,R22
	mov R16,R20
	rcall _Lcd_CURSOR
	.dbline 429
	clr R16
	rcall _Lcd_Write_Data
	.dbline 430
L71:
	.dbline 426
	inc R22
L73:
	.dbline 426
	cpi R22,132
	brlo L70
	.dbline 431
L67:
	.dbline 423
	inc R20
L69:
	.dbline 423
	cpi R20,9
	brlo L66
	.dbline -2
L65:
	rcall pop_gset2
	.dbline 0 ; func end
	ret
	.dbsym r i 20 c
	.dbsym r j 22 c
	.dbend
	.dbfunc e Test_LCD _Test_LCD fV
;              i -> R20
;              j -> R22
	.even
_Test_LCD::
	rcall push_gset2
	.dbline -1
	.dbline 435
; 		 {	
; 		 	 Lcd_CURSOR(i,j);      //列在变，光标也在不停的换列
; 		 	 Lcd_Write_Data(0); //定好一页后，再一列一列的写00h,列在变
; 		 }		
; 	}
; }	
; //--------------------------------LCD测试---------------------------------------
; void Test_LCD(void)
; {	
	.dbline 437
; 	uchar i,j;
; 	for(i=0xB0;i<0xB8;i++)		//B0-B8共8页
	ldi R20,176
	rjmp L78
L75:
	.dbline 438
; 	{
	.dbline 439
; 		Lcd_Write_command(i);     //+号为合成为一个字节（其实就是或）B0+0x
	mov R16,R20
	rcall _Lcd_Write_command
	.dbline 440
; 		Lcd_Write_command(0x10); //Set column address MSB(10+xx)即Y7 Y6 Y5 Y4
	ldi R16,16
	rcall _Lcd_Write_command
	.dbline 441
; 		Lcd_Write_command(0x01); 
	ldi R16,1
	rcall _Lcd_Write_command
	.dbline 442
; 		 Lcd_CURSOR(i,0);
	clr R18
	mov R16,R20
	rcall _Lcd_CURSOR
	.dbline 443
; 		 for(j=0;j<132;j++)
	clr R22
	rjmp L82
L79:
	.dbline 444
	.dbline 445
	mov R18,R22
	mov R16,R20
	rcall _Lcd_CURSOR
	.dbline 446
	ldi R16,1
	rcall _Lcd_Write_Data
	.dbline 447
L80:
	.dbline 443
	inc R22
L82:
	.dbline 443
	cpi R22,132
	brlo L79
	.dbline 449
L76:
	.dbline 437
	inc R20
L78:
	.dbline 437
	cpi R20,184
	brlo L75
	.dbline -2
L74:
	rcall pop_gset2
	.dbline 0 ; func end
	ret
	.dbsym r i 20 c
	.dbsym r j 22 c
	.dbend
	.dbfunc e dis_1616hz _dis_1616hz fV
;              i -> R20
;              j -> R14
;             hz -> R22,R23
;            row -> R10
;             x2 -> R12
;             x1 -> R14
	.even
_dis_1616hz::
	rcall push_gset5
	mov R12,R18
	mov R14,R16
	ldd R10,y+10
	ldd R22,y+12
	ldd R23,y+13
	.dbline -1
	.dbline 493
; 		 {	                        //每读写一次，列会自动加1
; 		 	 Lcd_CURSOR(i,j);       //列在变，光标也在不停的换列，重新进行定位
; 		 	 Lcd_Write_Data(0x01);  //检测写进f0h？？？4点亮4点暗
; 		 }
; 		 		
; 	}
; }
; /*
; //------------------------------------------------------------------------------
; void dis_biankuang()			//边框设计
; {	
; 	uchar i,j,k;
; 	for(i=0xB0;i<0xB8;i++)		//2页16行
; 	{
; 		Lcd_Write_command(i);     	//+号为合成为一个字节（其实就是或）B0+0x
; 		Lcd_Write_command(0x10); 	//Set column address MSB(10+xx)即Y7 Y6 Y5 Y4
; 		Lcd_Write_command(0x01); 
; 		Lcd_CURSOR(i,0);
; 		 for(j=0;j<132;j++)
; 		 {	                        //每读写一次，列会自动加1
; 		 	 Lcd_CURSOR(i,j);       //改变列位置，列在变，光标也在不停的换列，重新进行定位
; 		 	 Lcd_Write_Data(0x03);  //检测写进f0h？？？4点亮4点暗
; 		 }
; 		 for(k=0xB0;k<0xB7;k++)
; 		 {
; 		 for(j=2;j<6;j++)
; 		 {
; 		  Lcd_CURSOR(k,j);       //改变列位置，列在变，光标也在不停的换列，重新进行定位
; 		  Lcd_Write_Data(0xff);
; 		 }
; 		 for(j=130;j<132;j++)
; 		 {
; 		  Lcd_CURSOR(k,j);       //改变列位置，列在变，光标也在不停的换列，重新进行定位
; 		  Lcd_Write_Data(0xff);
; 		 }
; 		 }
; 		 i=i+7;
; 		 for(j=0;j<132;j++)      
; 		 {	                        //每读写一次，列会自动加1
; 		 	 Lcd_CURSOR(i,j);       //列在变，光标也在不停的换列，重新进行定位
; 		 	 Lcd_Write_Data(0x03);  //检测写进f0h？？？4点亮4点暗
; 		 }
; 
; 			
; 	}
; }
; */
; //------------------------------16*16汉字显示-----------------------------------
; void dis_1616hz(uchar x1,uchar x2,uchar row,const uchar hz[])			//16*16
; {	
	.dbline 495
; 	uchar i,j;
; 	for(i=x1;i<x2;i++)		//2页16行
	mov R20,R14
	rjmp L87
L84:
	.dbline 496
; 	{
	.dbline 497
; 		Lcd_Write_command(i);     	//+号为合成为一个字节（其实就是或）B0+0x
	mov R16,R20
	rcall _Lcd_Write_command
	.dbline 498
; 		Lcd_Write_command(0x10); 	//Set column address MSB(10+xx)即Y7 Y6 Y5 Y4
	ldi R16,16
	rcall _Lcd_Write_command
	.dbline 499
; 		Lcd_Write_command(0x01); 
	ldi R16,1
	rcall _Lcd_Write_command
	.dbline 500
; 		Lcd_CURSOR(i,0);
	clr R18
	mov R16,R20
	rcall _Lcd_CURSOR
	.dbline 501
; 		 for(j=0;j<16;j++)
	clr R14
	rjmp L91
L88:
	.dbline 502
	.dbline 503
	mov R18,R14
	add R18,R10
	mov R16,R20
	rcall _Lcd_CURSOR
	.dbline 504
	mov R2,R14
	clr R3
	add R2,R22
	adc R3,R23
	mov R30,R2
	mov R31,R3
	lpm
	mov R16,R0
	rcall _Lcd_Write_Data
	.dbline 505
L89:
	.dbline 501
	inc R14
L91:
	.dbline 501
	mov R24,R14
	cpi R24,16
	brlo L88
	.dbline 506
; 		 {	                        //每读写一次，列会自动加1
; 		 	 Lcd_CURSOR(i,j+row);       //改变列位置，列在变，光标也在不停的换列，重新进行定位
; 		 	 Lcd_Write_Data(hz[j]);  //检测写进f0h？？？4点亮4点暗
; 		 }
; 		 i++;
	inc R20
	.dbline 507
; 		 for(j=0;j<16;j++)      
	clr R14
	rjmp L95
L92:
	.dbline 508
	.dbline 509
	mov R18,R14
	add R18,R10
	mov R16,R20
	rcall _Lcd_CURSOR
	.dbline 510
	mov R24,R14
	clr R25
	add R24,R22
	adc R25,R23
	adiw R24,16
	mov R30,R24
	mov R31,R25
	lpm
	mov R16,R0
	rcall _Lcd_Write_Data
	.dbline 511
L93:
	.dbline 507
	inc R14
L95:
	.dbline 507
	mov R24,R14
	cpi R24,16
	brlo L92
	.dbline 512
L85:
	.dbline 495
	inc R20
L87:
	.dbline 495
	cp R20,R12
	brsh X2
	rjmp L84
X2:
	.dbline -2
L83:
	rcall pop_gset5
	.dbline 0 ; func end
	ret
	.dbsym r i 20 c
	.dbsym r j 14 c
	.dbsym r hz 22 pkc
	.dbsym r row 10 c
	.dbsym r x2 12 c
	.dbsym r x1 14 c
	.dbend
	.dbfunc e dis_168hz _dis_168hz fV
;              b -> R20
;              a -> R22
;              j -> R10
;             hz -> R12,R13
;            row -> R14
;             x1 -> R20
	.even
_dis_168hz::
	rcall push_gset5
	mov R14,R18
	mov R20,R16
	ldd R12,y+10
	ldd R13,y+11
	.dbline -1
	.dbline 546
; 		 {	                        //每读写一次，列会自动加1
; 		 	 Lcd_CURSOR(i,j+row);       //列在变，光标也在不停的换列，重新进行定位
; 		 	 Lcd_Write_Data(hz[j+16]);  //检测写进f0h？？？4点亮4点暗
; 		 }		
; 	}
; }
; /*------------------------------------------------------------------------------
; void Dis16x16(uchar add_page, uchar add_col,const uchar *pHZ,uchar state)
; {
;     uchar i;
;     Lcd_CURSOR(add_page, add_col);
;     for(i=0;i<16;i++) 
;     {                                                //一个汉字2行，16列，32个字节
;     	if(state)                                    //state(选亮，黑)
;     	{
;     		Lcd_Write_Data(pHZ[i]);              //光标定位后沿着行开始写16列的字模数据？？？？？？
;     	}
;     //	else
;     //	{
;     	    	Lcd_Write_Data(~pHZ[i]);	    //如果列变，光标也会不停的换列，这里光标只换页不换列
;     //	}                                           //那还是一列一列的写吗？？？？(写一次会自动加1列）
;      // }                                             //而清时在不停的换列
;     Lcd_CURSOR(add_page-1, add_col);                //加或减都行，只是取模方向不同
;     for(;i<32;i++)
;     {  
;     	if(state)
;     	{
;     		Lcd_Write_Data(pHZ[i]);
;     	}
;     //	else
;     //	{
;     	//	Lcd_Write_Data(~pHZ[i]);
;     	}
;     }
; }
; */
; //-----------------------------16*8点阵显示-------------------------------------
; void dis_168hz(uchar x1,uchar row,const uchar hz[])			//16*16
; {	
	.dbline 548
; 	uchar a,b,j;
; 	a=x1;
	mov R22,R20
	.dbline 549
; 	b=x1+1;
	subi R20,255    ; addi 1
	.dbline 550
; 		Lcd_Write_command(a);     	//+号为合成为一个字节（其实就是或）B0+0x
	mov R16,R22
	rcall _Lcd_Write_command
	.dbline 551
; 		Lcd_Write_command(0x10); 	//Set column address MSB(10+xx)即Y7 Y6 Y5 Y4
	ldi R16,16
	rcall _Lcd_Write_command
	.dbline 552
; 		Lcd_Write_command(0x01); 
	ldi R16,1
	rcall _Lcd_Write_command
	.dbline 553
; 		Lcd_CURSOR(a,0);
	clr R18
	mov R16,R22
	rcall _Lcd_CURSOR
	.dbline 554
; 		 for(j=0;j<8;j++)
	clr R10
	rjmp L100
L97:
	.dbline 555
	.dbline 556
	mov R18,R10
	add R18,R14
	mov R16,R22
	rcall _Lcd_CURSOR
	.dbline 557
	mov R2,R10
	clr R3
	add R2,R12
	adc R3,R13
	mov R30,R2
	mov R31,R3
	lpm
	mov R16,R0
	rcall _Lcd_Write_Data
	.dbline 558
L98:
	.dbline 554
	inc R10
L100:
	.dbline 554
	mov R24,R10
	cpi R24,8
	brlo L97
	.dbline 559
; 		 {	                        //每读写一次，列会自动加1
; 		 	 Lcd_CURSOR(a,j+row);       //改变列位置，列在变，光标也在不停的换列，重新进行定位
; 		 	 Lcd_Write_Data(hz[j]);  //检测写进f0h？？？4点亮4点暗
; 		 }
; 		 Lcd_Write_command(b);     	//+号为合成为一个字节（其实就是或）B0+0x
	mov R16,R20
	rcall _Lcd_Write_command
	.dbline 560
; 		Lcd_Write_command(0x10); 	//Set column address MSB(10+xx)即Y7 Y6 Y5 Y4
	ldi R16,16
	rcall _Lcd_Write_command
	.dbline 561
; 		Lcd_Write_command(0x01); 
	ldi R16,1
	rcall _Lcd_Write_command
	.dbline 562
; 		Lcd_CURSOR(b,0);
	clr R18
	mov R16,R20
	rcall _Lcd_CURSOR
	.dbline 563
; 		 for(j=0;j<8;j++)      
	clr R10
	rjmp L104
L101:
	.dbline 564
	.dbline 565
	mov R18,R10
	add R18,R14
	mov R16,R20
	rcall _Lcd_CURSOR
	.dbline 566
	mov R24,R10
	clr R25
	add R24,R12
	adc R25,R13
	adiw R24,8
	mov R30,R24
	mov R31,R25
	lpm
	mov R16,R0
	rcall _Lcd_Write_Data
	.dbline 567
L102:
	.dbline 563
	inc R10
L104:
	.dbline 563
	mov R24,R10
	cpi R24,8
	brlo L101
	.dbline -2
L96:
	rcall pop_gset5
	.dbline 0 ; func end
	ret
	.dbsym r b 20 c
	.dbsym r a 22 c
	.dbsym r j 10 c
	.dbsym r hz 12 pkc
	.dbsym r row 14 c
	.dbsym r x1 20 c
	.dbend
	.dbfunc e dis_shuzi _dis_shuzi fV
;          shuzi -> y+8
;              y -> R22
;              x -> R20
	.even
_dis_shuzi::
	rcall push_gset3
	mov R22,R18
	mov R20,R16
	sbiw R28,2
	.dbline -1
	.dbline 571
; 		 {	                        //每读写一次，列会自动加1
; 		 	 Lcd_CURSOR(b,j+row);       //列在变，光标也在不停的换列，重新进行定位
; 		 	 Lcd_Write_Data(hz[j+8]);  //检测写进f0h？？？4点亮4点暗
; 		 }		
; 	
; }
; void dis_shuzi(uchar x,uchar y,uchar shuzi)	
; {
	.dbline 572
; 	switch	(shuzi)
	ldd R10,y+8
	clr R11
	tst R10
	brne X3
	tst R11
	brne X5
	rjmp L118
X5:
X3:
	mov R24,R10
	mov R25,R11
	cpi R24,1
	ldi R30,0
	cpc R25,R30
	brne X6
	rjmp L117
X6:
	cpi R24,2
	ldi R30,0
	cpc R25,R30
	brne X7
	rjmp L116
X7:
	cpi R24,3
	ldi R30,0
	cpc R25,R30
	brne X8
	rjmp L115
X8:
	cpi R24,4
	ldi R30,0
	cpc R25,R30
	brne X9
	rjmp L114
X9:
	cpi R24,5
	ldi R30,0
	cpc R25,R30
	breq L113
	cpi R24,6
	ldi R30,0
	cpc R25,R30
	breq L112
	cpi R24,7
	ldi R30,0
	cpc R25,R30
	breq L111
	cpi R24,8
	ldi R30,0
	cpc R25,R30
	breq L110
	cpi R24,9
	ldi R30,0
	cpc R25,R30
	breq L109
	rjmp L107
X4:
	.dbline 573
; 	{
L109:
	.dbline 580
; 	//case 0x0f:dispaly[2]=9;break;
; 	//case 0x0e:dispaly[2]=9;break;
; 	//case 0x0d:dispaly[2]=8;break;
; 	//case 0x0c:dispaly[2]=8;break;
; 	//case 0x0b:dispaly[2]=7;break;
; 	//case 0x0a:dispaly[2]=6;break;
; 	case 0x09:dis_168hz(x,y,jiu16);break;
	ldi R24,<_jiu16
	ldi R25,>_jiu16
	std y+1,R25
	std y+0,R24
	mov R18,R22
	mov R16,R20
	rcall _dis_168hz
	.dbline 580
	rjmp L107
L110:
	.dbline 581
; 	case 0x08:dis_168hz(x,y,ba16);break;
	ldi R24,<_ba16
	ldi R25,>_ba16
	std y+1,R25
	std y+0,R24
	mov R18,R22
	mov R16,R20
	rcall _dis_168hz
	.dbline 581
	rjmp L107
L111:
	.dbline 582
; 	case 0x07:dis_168hz(x,y,qi16);break;
	ldi R24,<_qi16
	ldi R25,>_qi16
	std y+1,R25
	std y+0,R24
	mov R18,R22
	mov R16,R20
	rcall _dis_168hz
	.dbline 582
	rjmp L107
L112:
	.dbline 583
; 	case 0x06:dis_168hz(x,y,liu16);break;
	ldi R24,<_liu16
	ldi R25,>_liu16
	std y+1,R25
	std y+0,R24
	mov R18,R22
	mov R16,R20
	rcall _dis_168hz
	.dbline 583
	rjmp L107
L113:
	.dbline 584
; 	case 0x05:dis_168hz(x,y,wu16);break;
	ldi R24,<_wu16
	ldi R25,>_wu16
	std y+1,R25
	std y+0,R24
	mov R18,R22
	mov R16,R20
	rcall _dis_168hz
	.dbline 584
	rjmp L107
L114:
	.dbline 585
; 	case 0x04:dis_168hz(x,y,si16);break;
	ldi R24,<_si16
	ldi R25,>_si16
	std y+1,R25
	std y+0,R24
	mov R18,R22
	mov R16,R20
	rcall _dis_168hz
	.dbline 585
	rjmp L107
L115:
	.dbline 586
; 	case 0x03:dis_168hz(x,y,san16);break;
	ldi R24,<_san16
	ldi R25,>_san16
	std y+1,R25
	std y+0,R24
	mov R18,R22
	mov R16,R20
	rcall _dis_168hz
	.dbline 586
	rjmp L107
L116:
	.dbline 587
; 	case 0x02:dis_168hz(x,y,er16);break;
	ldi R24,<_er16
	ldi R25,>_er16
	std y+1,R25
	std y+0,R24
	mov R18,R22
	mov R16,R20
	rcall _dis_168hz
	.dbline 587
	rjmp L107
L117:
	.dbline 588
; 	case 0x01:dis_168hz(x,y,yi16);break;
	ldi R24,<_yi16
	ldi R25,>_yi16
	std y+1,R25
	std y+0,R24
	mov R18,R22
	mov R16,R20
	rcall _dis_168hz
	.dbline 588
	rjmp L107
L118:
	.dbline 589
	ldi R24,<_ling16
	ldi R25,>_ling16
	std y+1,R25
	std y+0,R24
	mov R18,R22
	mov R16,R20
	rcall _dis_168hz
	.dbline 589
	.dbline 590
L107:
	.dbline -2
L105:
	adiw R28,2
	rcall pop_gset3
	.dbline 0 ; func end
	ret
	.dbsym l shuzi 8 c
	.dbsym r y 22 c
	.dbsym r x 20 c
	.dbend
	.dbfunc e dis_ykxt _dis_ykxt fV
	.even
_dis_ykxt::
	sbiw R28,4
	.dbline -1
	.dbline 628
; 	case 0x00:dis_168hz(x,y,ling16);break;
; 	default:break;
; 	}
; }
; //-----------------------------------------------------------------------------
; 
; /*void LCDtime(uchar x,uchar nian1,uchar nian2,uchar nian3,uchar nian4,
; 		     uchar yue1,uchar yue2,
; 		     uchar ri1,uchar ri2,
; 		     uchar shi1,uchar shi2,
; 		     uchar fen1,uchar fen1,)    //LCD时间显示函数
; */
; //------------------------------------------------------------------------------
; /*
; void LCDtime()	                         
; 	{
; 	dis_168hz(0xB6,5,er16);          	 //n1
; 	dis_168hz(0xB6,13,ling16);	 		 //n2
; 	dis_168hz(0xB6,21,ling16);	 		 //n3	
; 	dis_168hz(0xB6,29,qi16);	 		 //n4
; 	dis_168hz(0xB6,37,heng16);
; 	dis_168hz(0xB6,45,yi16);	 		 //y1
; 	dis_168hz(0xB6,53,ling16);	 		 //y2
; 	dis_168hz(0xB6,61,heng16);	 	
; 	dis_168hz(0xB6,69,yi16);	 		 //r1
; 	dis_168hz(0xB6,77,ling16);       	 //r2
; 	///////////////////////////////////////////////
; 	dis_168hz(0xB6,90,yi16);	 		//s1
; 	dis_168hz(0xB6,98,san16);           //s2
; 	dis_168hz(0xB6,106,maohao16);	 	//
; 	dis_168hz(0xB6,114,yi16);        	//f3
; 	dis_168hz(0xB6,122,liu16);       	//f4
; 	}
; */
; //------------------------------------------------------------------------------
; 
; //------------------------------------------------------------------------------
; 
; void  dis_ykxt()
; {
	.dbline 630
; //---------------------------第一行“无线遥控系统“-----------------------------
; 	dis_1616hz(0xB0,0xB1,20,wu);
	ldi R24,<_wu
	ldi R25,>_wu
	std y+3,R25
	std y+2,R24
	ldi R24,20
	std y+0,R24
	ldi R18,177
	ldi R16,176
	rcall _dis_1616hz
	.dbline 631
; 	dis_1616hz(0xB0,0xB1,36,xian);
	ldi R24,<_xian
	ldi R25,>_xian
	std y+3,R25
	std y+2,R24
	ldi R24,36
	std y+0,R24
	ldi R18,177
	ldi R16,176
	rcall _dis_1616hz
	.dbline 632
; 	dis_1616hz(0xB0,0xB1,52,yao);
	ldi R24,<_yao
	ldi R25,>_yao
	std y+3,R25
	std y+2,R24
	ldi R24,52
	std y+0,R24
	ldi R18,177
	ldi R16,176
	rcall _dis_1616hz
	.dbline 633
; 	dis_1616hz(0xB0,0xB1,68,kong);
	ldi R24,<_kong
	ldi R25,>_kong
	std y+3,R25
	std y+2,R24
	ldi R24,68
	std y+0,R24
	ldi R18,177
	ldi R16,176
	rcall _dis_1616hz
	.dbline 634
; 	dis_1616hz(0xB0,0xB1,84,xi);
	ldi R24,<_xi
	ldi R25,>_xi
	std y+3,R25
	std y+2,R24
	ldi R24,84
	std y+0,R24
	ldi R18,177
	ldi R16,176
	rcall _dis_1616hz
	.dbline 635
; 	dis_1616hz(0xB0,0xB1,100,tong);
	ldi R24,<_tong
	ldi R25,>_tong
	std y+3,R25
	std y+2,R24
	ldi R24,100
	std y+0,R24
	ldi R18,177
	ldi R16,176
	rcall _dis_1616hz
	.dbline -2
L119:
	adiw R28,4
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e dis_jdql _dis_jdql fV
	.even
_dis_jdql::
	sbiw R28,4
	.dbline -1
	.dbline 639
; }
; //----------------------------第2行“继电器开”-------------------------------------
; void dis_jdql()
; {
	.dbline 640
; 	dis_1616hz(0xB3,0xB4,35,ji);
	ldi R24,<_ji
	ldi R25,>_ji
	std y+3,R25
	std y+2,R24
	ldi R24,35
	std y+0,R24
	ldi R18,180
	ldi R16,179
	rcall _dis_1616hz
	.dbline 641
; 	dis_1616hz(0xB3,0xB4,51,dian);
	ldi R24,<_dian
	ldi R25,>_dian
	std y+3,R25
	std y+2,R24
	ldi R24,51
	std y+0,R24
	ldi R18,180
	ldi R16,179
	rcall _dis_1616hz
	.dbline 642
; 	dis_1616hz(0xB3,0xB4,67,qi);
	ldi R24,<_qi
	ldi R25,>_qi
	std y+3,R25
	std y+2,R24
	ldi R24,67
	std y+0,R24
	ldi R18,180
	ldi R16,179
	rcall _dis_1616hz
	.dbline 643
; 	dis_1616hz(0xB3,0xB4,83,kai);
	ldi R24,<_kai
	ldi R25,>_kai
	std y+3,R25
	std y+2,R24
	ldi R24,83
	std y+0,R24
	ldi R18,180
	ldi R16,179
	rcall _dis_1616hz
	.dbline -2
L120:
	adiw R28,4
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e dis_fmqx _dis_fmqx fV
	.even
_dis_fmqx::
	sbiw R28,4
	.dbline -1
	.dbline 647
; }	
; //---------------------------第3行“蜂明器响“--------------------------------------
; void dis_fmqx()
; {
	.dbline 648
; 	dis_1616hz(0xB3,0xB4,35,feng);
	ldi R24,<_feng
	ldi R25,>_feng
	std y+3,R25
	std y+2,R24
	ldi R24,35
	std y+0,R24
	ldi R18,180
	ldi R16,179
	rcall _dis_1616hz
	.dbline 649
; 	dis_1616hz(0xB3,0xB4,51,ming);
	ldi R24,<_ming
	ldi R25,>_ming
	std y+3,R25
	std y+2,R24
	ldi R24,51
	std y+0,R24
	ldi R18,180
	ldi R16,179
	rcall _dis_1616hz
	.dbline 650
; 	dis_1616hz(0xB3,0xB4,67,qi);
	ldi R24,<_qi
	ldi R25,>_qi
	std y+3,R25
	std y+2,R24
	ldi R24,67
	std y+0,R24
	ldi R18,180
	ldi R16,179
	rcall _dis_1616hz
	.dbline 651
; 	dis_1616hz(0xB3,0xB4,83,xiang);
	ldi R24,<_xiang
	ldi R25,>_xiang
	std y+3,R25
	std y+2,R24
	ldi R24,83
	std y+0,R24
	ldi R18,180
	ldi R16,179
	rcall _dis_1616hz
	.dbline -2
L121:
	adiw R28,4
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e StartUART _StartUART fV
	.even
_StartUART::
	.dbline -1
	.dbline 655
; }
; //-------------------------------串口初始化-------------------------------------
; void StartUART(void)
; {
	.dbline 656
;  	 UCSRA=0x00;	
	clr R2
	out 0xb,R2
	.dbline 657
; 	 UCSRB=0x18;	
	ldi R24,24
	out 0xa,R24
	.dbline 658
; 	 UCSRC=0x06;	
	ldi R24,6
	out 0x20,R24
	.dbline 659
; 	 UBRRL=0x33;
	ldi R24,51
	out 0x9,R24
	.dbline 660
; 	 UBRRH=0x00;
	out 0x20,R2
	.dbline 661
; 	 UCSRA=UCSRA|0x08;	
	sbi 0xb,3
	.dbline -2
L122:
	.dbline 0 ; func end
	ret
	.dbend
	.dbfunc e R_S_Byte _R_S_Byte fV
;         R_Byte -> R16
	.even
_R_S_Byte::
	.dbline -1
	.dbline 665
; }
; //------------------------------串口发送----------------------------------------
; void R_S_Byte(uchar R_Byte)
; {	
	.dbline 666
;      UDR= R_Byte;  
	out 0xc,R16
	.dbline -2
L123:
	.dbline 0 ; func end
	ret
	.dbsym r R_Byte 16 c
	.dbend
	.dbfunc e main _main fV
;              i -> <dead>
	.even
_main::
	.dbline -1
	.dbline 670
; }
; //------------------------------主函数------------------------------------------
; void main(void)
; {  
	.dbline 672
; 	uint i;
; 	DDRD=0xF2;						  //端口D设置											  
	ldi R24,242
	out 0x11,R24
	.dbline 673
; 	DDRB=0xB3;					     //端口B设置							
	ldi R24,179
	out 0x17,R24
	.dbline 675
; //------------------------------------------------------------------------------				  			 				
; 	Spi_initial();	                //SPI初始化															  
	rcall _Spi_initial
	.dbline 676
; 	system_Init();				   //系统状态初始化												
	rcall _system_Init
	.dbline 677
; 	Config905();  				  //NRF905初始化	
	rcall _Config905
	.dbline 679
; //------------------------------------------------------------------------------	
; 	Lcd_init();					 //LCD初始化							  
	rcall _Lcd_init
	.dbline 681
; //------------------------------------------------------------------------------
; 	StartUART();				//串口初始化9600波特率
	rcall _StartUART
	.dbline 682
; 	Delay(500);
	ldi R16,500
	ldi R17,1
	rcall _Delay
	.dbline 683
; 	Lcd_Clear();				//清屏幕
	rcall _Lcd_Clear
	rjmp L126
L125:
	.dbline 687
; 	
; //------------------------------------------------------------------------------
; 	while(1)
; 	{
	.dbline 688
; 	RX();  					//接收数据
	rcall _RX
	.dbline 689
; 	if(TxRxBuffer[0])
	lds R2,_TxRxBuffer
	tst R2
	breq L128
	.dbline 690
; 	{
	.dbline 691
; 	if(TxRxBuffer[0]==0x29)
	mov R24,R2
	cpi R24,41
	brne L130
	.dbline 692
; 	{
	.dbline 693
; 	Low_JDQ;			   //打开继电器
	cbi 0x12,7
	.dbline 694
; 	dis_ykxt();
	rcall _dis_ykxt
	.dbline 695
; 	dis_jdql();
	rcall _dis_jdql
	.dbline 696
; 	}
L130:
	.dbline 697
; 	if(TxRxBuffer[0]==0x30)
	lds R24,_TxRxBuffer
	cpi R24,48
	brne L132
	.dbline 698
; 	{
	.dbline 699
; 	Low_BELL;			   //打开蜂明器
	cbi 0x12,6
	.dbline 699
	.dbline 700
; 	dis_ykxt();
	rcall _dis_ykxt
	.dbline 701
; 	dis_fmqx();
	rcall _dis_fmqx
	.dbline 702
; 	}
L132:
	.dbline 703
; 	if(TxRxBuffer[0]==0x31)
	lds R24,_TxRxBuffer
	cpi R24,49
	brne L134
	.dbline 704
; 	{
	.dbline 705
; 	Lcd_Clear();		  //清屏幕
	rcall _Lcd_Clear
	.dbline 706
; 	}
L134:
	.dbline 707
; 	}
L128:
	.dbline 708
	sbi 0x12,7
	.dbline 709
	sbi 0x12,6
	.dbline 709
	.dbline 710
L126:
	.dbline 686
	rjmp L125
X10:
	.dbline -2
L124:
	.dbline 0 ; func end
	ret
	.dbsym l i 1 i
	.dbend
	.area bss(ram, con, rel)
	.dbfile F:\开发板配套资料\JASK3000软件开发包\遥控开关\NRF905_接收\jifeng_jieshou.c
_count2::
	.blkb 1
	.dbsym e count2 _count2 c
_count1::
	.blkb 1
	.dbsym e count1 _count1 c
_TxRxBuffer::
	.blkb 4
	.dbsym e TxRxBuffer _TxRxBuffer A[4:4]c
