//
// Copyright (c) 2004 Golden Bits Software, Inc.
// All rights reserved
// www.goldenbits.com
//
//
//  PNP stuff
//
//  Here's the Vendor ID I'm using.  It's unofficial and just for 
//  testing purposes.
//
//  Vendor ID 7055, ProductID 100
//

#include "ntddk.h"
#include "wmilib.h"
#include "usbdi.h"
#include "usbdlib.h"
#include "CrMain.h"
#include "CrPnp.h"
#include "CrConfig.h"
#include "..\Include\UsbCryptAppInc.h"




// =============== UsbCrypt_AddDevice() ==============
//  Desc: Adds device object for this USB driver
//
//  Returns: NTSTATUS
//
NTSTATUS UsbCrypt_AddDevice(IN PDRIVER_OBJECT pDriverObject,
                            IN PDEVICE_OBJECT pPhysicalDevObject)
{
  NTSTATUS          ntStatus;
  PDEVICE_OBJECT    pNewDeviceObj;
  PUSB_CRYPT_EXT    pCryptExt;
  POWER_STATE       state;
  KIRQL             oldIrql;
  POWER_STATE       PowerState;
  UNICODE_STRING    SymbolicName;


    USB_TRACE("UsbCrypt_AddDevice - Start\n");

    pNewDeviceObj = NULL;

    ntStatus = IoCreateDevice(pDriverObject,
                    sizeof(USB_CRYPT_EXT ),         // our device extension
                    NULL,                           // Don't specify a name
                                                    // we'll use IoRegisterDeviceInterface()
                    FILE_DEVICE_UNKNOWN,
                    FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                    FALSE,                          // Not exclusive
                    &pNewDeviceObj);                // Our device object


    if(!NT_SUCCESS(ntStatus)) 
    {
        // Failed to create device object!!!
        USB_TRACE1("Failed to create USB Crypt device object, NTSTATUS = 0x%x\n", ntStatus);
        return ntStatus;
    }

    //
    // Setup or device extension
    //

    pCryptExt = (PUSB_CRYPT_EXT)pNewDeviceObj->DeviceExtension;
    pCryptExt->pLowerPhysDevObject = pPhysicalDevObject;
    pCryptExt->pOurDeviceObject = pNewDeviceObj;

    pNewDeviceObj->Flags |= DO_DIRECT_IO;

    // Set  device PNP State
    INITIALIZE_PNP_STATE(pCryptExt);


    //
    // Init and register WMI
    //
    pCryptExt->CryptWminfo.GuidCount = 
          sizeof (USBCryptGuidList) / sizeof (WMIGUIDREGINFO);

    pCryptExt->CryptWminfo.GuidList           = USBCryptGuidList;
    pCryptExt->CryptWminfo.QueryWmiRegInfo    = UsbCrypt_QueryWmiRegInfo;
    pCryptExt->CryptWminfo.QueryWmiDataBlock  = UsbCrypt_QueryWmiDataBlock;
    pCryptExt->CryptWminfo.SetWmiDataBlock    = UsbCrypt_SetWmiDataBlock;
    pCryptExt->CryptWminfo.SetWmiDataItem     = UsbCrypt_SetWmiDataItem;
    pCryptExt->CryptWminfo.ExecuteWmiMethod   = NULL;
    pCryptExt->CryptWminfo.WmiFunctionControl = NULL;


    ntStatus = IoWMIRegistrationControl(pCryptExt->pOurDeviceObject,
                                         WMIREG_ACTION_REGISTER);

    if(!NT_SUCCESS(ntStatus)) 
    {

        USB_TRACE1("UsbCrypt_AddDevice - Failed to register WMI, ntStatus 0x%x\n", ntStatus);
        IoDeleteDevice(pNewDeviceObj);
        return ntStatus;
    }

    //
    // Set pagable flag if our phys object is also
    // pageable
    //
    if(pPhysicalDevObject->Flags & DO_POWER_PAGABLE) 
    {

        pNewDeviceObj->Flags |= DO_POWER_PAGABLE;
    }


    pCryptExt->DevicePower = PowerDeviceD0;
    pCryptExt->SytemPower = PowerSystemWorking;

    PowerState.DeviceState = pCryptExt->DevicePower;

  
    // let the system know our pwer state
    PoSetPowerState(pNewDeviceObj, DevicePowerState, PowerState);

    //
    // attach our driver to device stack
    // IoAttachDeviceToDeviceStack() returns the top of the driver
    // stack.  
    //

    pCryptExt->pTopStackDeviceObject = 
                IoAttachDeviceToDeviceStack(pNewDeviceObj,
                                            pPhysicalDevObject);

    if(pCryptExt->pTopStackDeviceObject == NULL) 
    {
        USB_TRACE("UsbCrypt_AddDevice - Failed to attached to top of device stack\n");
        IoDeleteDevice(pNewDeviceObj);
        return STATUS_NO_SUCH_DEVICE;
    }

        
    //
    // Register device interface, this enables apps to
    // talk to us
    //
    ntStatus = IoRegisterDeviceInterface(pCryptExt->pLowerPhysDevObject, 
                                         &GUID_CLASS_USBCRYPT, 
                                         NULL, 
                                         &pCryptExt->OurInterfaceName);

    if(!NT_SUCCESS(ntStatus)) 
    {
        USB_TRACE("Error, failed to register device interface\n");
        IoDetachDevice(pCryptExt->pTopStackDeviceObject);
        IoDeleteDevice(pNewDeviceObj);
        return ntStatus;
    }


    // Initialize remove lock
    IoInitializeRemoveLock(&pCryptExt->RemoveLock, CRYT_MEM_TAG, 0, 100);

    // create a work item to get decription progress
    // we'll constantly use a work item (which is run in a seperate
    // system thread) to "hang" a read on the progress pipe.
    pCryptExt->pProgressWkItem = IoAllocateWorkItem(pNewDeviceObj);

    //
    // Clear the DO_DEVICE_INITIALIZING flag.
    //
    pNewDeviceObj->Flags &= ~DO_DEVICE_INITIALIZING;

    USB_TRACE("AddDevice - Successful\n");

    return STATUS_SUCCESS;
}



// ================ UsbCrypt_PnPHandler() ===========
//  Desc: Handles PNP messages
//
//  Returns: NTSTATUS
//
NTSTATUS UsbCrypt_PnPHandler(IN PDEVICE_OBJECT pDeviceObject,
                             IN PIRP           pIrp)
{
  PIO_STACK_LOCATION pIrpStack;
  PUSB_CRYPT_EXT     pCryptExt;
  KEVENT             startDeviceEvent;
  NTSTATUS           ntStatus;
  BOOLEAN            bPassDown = FALSE;  // pass down to lower driver


    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pCryptExt = (PUSB_CRYPT_EXT)pDeviceObject->DeviceExtension;

    //
    // Have we been removed?
    //
    if(GET_CURRENT_PNP_STATE(pCryptExt) == Removed)
    {
        pIrp->IoStatus.Status = STATUS_DELETE_PENDING;
        pIrp->IoStatus.Information = 0;

        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        return STATUS_DELETE_PENDING;
    }


    // print out PNP function
    USB_TRACE1("UsbCrypt_PnPHandler - %s\n", PnPMinorFunctionString(pIrpStack->MinorFunction));


    switch(pIrpStack->MinorFunction) 
    {

        case IRP_MN_START_DEVICE:

            ntStatus = StartUSBCryptDevice(pDeviceObject, pIrp);

            bPassDown = FALSE;
            if(NT_SUCCESS(ntStatus))
            {
                SET_NEW_PNP_STATE(pCryptExt, Working);
            }

            break;

        case IRP_MN_QUERY_STOP_DEVICE:

            // always succesfull
            ntStatus = STATUS_SUCCESS;
            bPassDown = TRUE;

            // change device state
            SET_NEW_PNP_STATE(pCryptExt, PendingStop);
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:

            ntStatus = STATUS_SUCCESS;
            bPassDown = TRUE;

            // change device state
            SET_NEW_PNP_STATE(pCryptExt, Working);
            break;
     
        case IRP_MN_STOP_DEVICE:

            ntStatus = STATUS_SUCCESS;
            bPassDown = TRUE;
            
            StopUSBCryptDevice(pDeviceObject, pCryptExt);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:

            ntStatus = STATUS_SUCCESS;
            bPassDown = TRUE;

            // set new device status
            SET_NEW_PNP_STATE(pCryptExt, PendingRemove);
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            bPassDown = FALSE;

            ntStatus = CancelRemove(pCryptExt, pIrp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:

            ntStatus = STATUS_SUCCESS;
            bPassDown = TRUE;

            USBCryptSurpriseRemoval(pDeviceObject, pCryptExt);
            break;

        case IRP_MN_REMOVE_DEVICE:

            ntStatus = STATUS_SUCCESS;
            bPassDown = TRUE;

            RemoveCryptDevice(pDeviceObject, pCryptExt, pIrp);

            return STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_CAPABILITIES:

            ntStatus = CryptCapabilities(pDeviceObject, pIrp);
            bPassDown = FALSE;
            break;

        default:

            USB_TRACE1("PNP IRP not handled: %s\n", 
                        PnPMinorFunctionString(pIrpStack->MinorFunction));

            bPassDown = TRUE;

            // leave status unchanged
            ntStatus = pIrp->IoStatus.Status;
    
            break;

    } // end switch()


    //
    // complete request or pass down
    //

    pIrp->IoStatus.Status = ntStatus;
    pIrp->IoStatus.Information = 0;

    if(bPassDown)
    {
        // pass this PNP call down to the lower driver
        IoSkipCurrentIrpStackLocation(pIrp);
        ntStatus = IoCallDriver(pCryptExt->pTopStackDeviceObject, pIrp);
    }
    else
    {
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }


    return ntStatus;
}


// ================== HandleStartDevice() ===============
//  Desc: Starts device driver for USB device.
//
//  Returns: NTSTATUS
//
NTSTATUS StartUSBCryptDevice(IN PDEVICE_OBJECT pDeviceObject,
                             IN PIRP           pIrp)
{
  KIRQL             oldIrql;
  KEVENT            StartWaitEvent;
  NTSTATUS          Status;
  LARGE_INTEGER     dueTime;
  PUSB_CRYPT_EXT    pUsbCryptExt;


    USB_TRACE("StartUSBCryptDevice() - begin of function\n");

    //
    // get device extension
    //
    pUsbCryptExt = (PUSB_CRYPT_EXT)pDeviceObject->DeviceExtension;


    //
    // First we need to pass start IRP down to lower drivers
    //
    KeInitializeEvent(&StartWaitEvent, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(pIrp);

    IoSetCompletionRoutine(pIrp, 
                           (PIO_COMPLETION_ROUTINE)IrpGenericCompletionRoutine, 
                           (PVOID)&StartWaitEvent, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    // remember IoCallDriver() can be asynchronous
    Status = IoCallDriver(pUsbCryptExt->pTopStackDeviceObject, pIrp);

    if(Status == STATUS_PENDING) 
    {
        KeWaitForSingleObject(&StartWaitEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        // set return status
        Status = pIrp->IoStatus.Status;
    }


    if(!NT_SUCCESS(Status)) 
    {

        USB_TRACE("StartUSBCryptDevice() Error, failed to start lower device driver.\n");
        return Status;
    }


    // configure the driver and USB device
    Status = ConfigureDriver(pDeviceObject);

    IoSetDeviceInterfaceState(&pUsbCryptExt->OurInterfaceName, TRUE);

    // start our work item to get decryption byte
    // progress
    if(pUsbCryptExt->pProgressWkItem != NULL)
    {
        IoQueueWorkItem(pUsbCryptExt->pProgressWkItem, 
                        GetProgress,   // func which gets called
                        DelayedWorkQueue, NULL);
    }

    return Status;
}





// ================= IrpGenericCompletionRoutine() ================
// Desc: Handles IRP completion callback, doesn't do any special
//       processing
//
// Returns: STATUS_MORE_PROCESSING_REQUIRED
//
NTSTATUS IrpGenericCompletionRoutine(IN PDEVICE_OBJECT pDeviceObject,
                                     IN PIRP           pIrp,
                                     IN PVOID          pContext)
{
  PKEVENT pIrpWait = pContext;

    // set event, this should cause the IRP
    // processing to continue
    KeSetEvent(pIrpWait, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


// ============== StopUSBCryptDevice() ====================
// Desc: Stops all IO to USB device and deconfigures
//       USB device.
//
// Returns: Success
//
NTSTATUS StopUSBCryptDevice(IN PDEVICE_OBJECT pDevObj,
                            IN PUSB_CRYPT_EXT pCryptExt)
{
  ULONG UrbLen;
  PURB pUrbReq;
  NTSTATUS NtStatus;

    // set PNP flag to stopped
    SET_NEW_PNP_STATE(pCryptExt, Stopped);

    // have to aquire remove lock an addition time 
    // before releasing and waiting
    IoAcquireRemoveLock(&pCryptExt->RemoveLock, (PVOID)CRYT_MEM_TAG);

    // wait for IOs to complete
    // NOTE: This call will block until all of the previously
    //       acquired locks have been released.
    IoReleaseRemoveLockAndWait(&pCryptExt->RemoveLock, (PVOID)CRYT_MEM_TAG);

    // now de-configure device, here will send the USB
    // device, we do this by selecting a NULL device
    // configuration
    UrbLen = sizeof(struct _URB_SELECT_CONFIGURATION);

    pUrbReq = ExAllocatePool(NonPagedPool, UrbLen);

    if(pUrbReq == NULL)
        return STATUS_NO_MEMORY;


    UsbBuildSelectConfigurationRequest(pUrbReq, (USHORT)UrbLen, NULL);

    NtStatus = SendUSBRequest(pDevObj, pUrbReq, TRUE);

    // free memory
    ExFreePool(pUrbReq);

    // free previously allocated memory used
    // to save off interface information
    if(pCryptExt->pConfigDesc != NULL)
    {
        ExFreePool(pCryptExt->pConfigDesc);
        pCryptExt->pConfigDesc = NULL;
    }

    // free first interface - the encryption 
    // interface
    if(pCryptExt->pEncryptIFInfo != NULL)
    {
        ExFreePool(pCryptExt->pEncryptIFInfo);
        pCryptExt->pEncryptIFInfo = NULL;
    }

    // free second interface, the compression
    // intrface
    if(pCryptExt->pDecryptIFInfo != NULL)
    {
        ExFreePool(pCryptExt->pDecryptIFInfo);
        pCryptExt->pDecryptIFInfo = NULL;
    }



    return NtStatus;

}


// ============== RemoveCryptDevice() ====================
// Desc: Handles removing device
//
// Returns: NTSTATUS
//
NTSTATUS RemoveCryptDevice(IN PDEVICE_OBJECT pDevObj,
                           IN PUSB_CRYPT_EXT pCryptExt,
                           IN PIRP pIrp)
{
    // first stop all IO to device
    StopUSBCryptDevice(pDevObj, pCryptExt);

    // power down device

    // free work item
    if(pCryptExt->pProgressWkItem != NULL)
    {
        IoFreeWorkItem(pCryptExt->pProgressWkItem);
        pCryptExt->pProgressWkItem = NULL;
    }


    IoSetDeviceInterfaceState(&pCryptExt->OurInterfaceName, FALSE);

    // deregister WMI
    IoWMIRegistrationControl(pDevObj,  WMIREG_ACTION_DEREGISTER);

    // delete symbolic link name
    RtlFreeUnicodeString(&pCryptExt->OurInterfaceName);

    // call lower device
    IoSkipCurrentIrpStackLocation(pIrp);
    IoCallDriver(pCryptExt->pTopStackDeviceObject, pIrp);

    // detach our device from dev stack
    IoDetachDevice(pCryptExt->pTopStackDeviceObject);

    // delete device object
    IoDeleteDevice(pDevObj);

    return STATUS_SUCCESS;
}


// ============== CancelRemove() ====================
// Desc: Handles cancel remove IRP_MN_CANCEL_REMOVE IRP.
//
// Returns: NTSTATUS
//
NTSTATUS CancelRemove(IN PUSB_CRYPT_EXT pCryptExt, 
                      IN PIRP pIrp)
{
  KEVENT IrpWaitEvent;
  NTSTATUS Status;

    // send to lower device first
    KeInitializeEvent(&IrpWaitEvent, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(pIrp);

    IoSetCompletionRoutine(pIrp, 
                           (PIO_COMPLETION_ROUTINE)IrpGenericCompletionRoutine, 
                           (PVOID)&IrpWaitEvent, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    // remember IoCallDriver() can be asynchronous
    Status = IoCallDriver(pCryptExt->pTopStackDeviceObject, pIrp);

    if(Status == STATUS_PENDING) 
    {
        KeWaitForSingleObject(&IrpWaitEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        // set return status
        Status = pIrp->IoStatus.Status;
    }


    if(NT_SUCCESS(Status))
    {
        // restore previous dev state
        RESTORE_PREVIOUS_PNP_STATE(pCryptExt);

        // should be in working state
        ASSERT(GET_CURRENT_PNP_STATE(pCryptExt) == Working);
    }
    else
    {
        USB_TRACE("CancelRemove() Lower driver failed IRP_MN_CANCEL_REMOVAL\n");
    }

    return Status;
}



NTSTATUS USBCryptSurpriseRemoval(IN PDEVICE_OBJECT pDeviceObject,
                                 IN PUSB_CRYPT_EXT pCryptExt)
{
    // This function needs to be implemented....
    // Should abort any outstanding requests to USB
    // device
    // TODO: ****

    return STATUS_SUCCESS;
}



// ============== CryptCapabilities() ====================
// Desc: Handles PNP Query capabilities IRP
//
// Returns: Success
//
NTSTATUS CryptCapabilities(IN PDEVICE_OBJECT pDeviceObject,
                           IN PIRP           pIrp)
{
  ULONG                i;
  KEVENT               event;
  NTSTATUS             ntStatus;
  PDEVICE_CAPABILITIES pDevCaps;
  PIO_STACK_LOCATION   pIrpStack;
  PUSB_CRYPT_EXT       pCryptExt;

    USB_TRACE("CryptCapabilities()\n");


    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pCryptExt = (PUSB_CRYPT_EXT)pDeviceObject->DeviceExtension;
    pDevCaps  = pIrpStack->Parameters.DeviceCapabilities.Capabilities;

    // sanity check
    if(pDevCaps->Version < 1 || pDevCaps->Size < sizeof(DEVICE_CAPABILITIES)) 
    {
        USB_TRACE("CryptCapabilities() failed\n");
        ntStatus = STATUS_UNSUCCESSFUL;
        return ntStatus;
    }

    //
    // Add in the SurpriseRemovalOK bit before passing it down.
    //
    pDevCaps->SurpriseRemovalOK = TRUE;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
        
    IoCopyCurrentIrpStackLocationToNext(pIrp);

    //
    // We will just handle this IRP on the way down adding our 
    // own capabilities.  We'll set a completion routine
    // here.  This lets us examine the DEVICE_CAPABILITIES
    // struct after the lower layer drivers have had a chance
    // to process this IRP.  

    IoSetCompletionRoutine(pIrp, 
                           (PIO_COMPLETION_ROUTINE)IrpGenericCompletionRoutine, 
                           (PVOID)&event, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    ntStatus = IoCallDriver(pCryptExt->pTopStackDeviceObject, pIrp);

    // If we needed to remove a capability then we would remove
    // the capability here.  For now we'll just leave it untouched

    USB_TRACE("CryptCapabilities() - end\n");

    return ntStatus;
}





PCHAR PnPMinorFunctionString(UCHAR MinorFunction)
{
    switch (MinorFunction) 
    {

        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";

        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";

        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";

        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";

        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";

        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";

        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";

        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";

        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";

        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";

        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";

        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";

        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";

        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";

        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";

        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";

        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";

        default:
            return "IRP_MN_<unknown>";
    }
}

