C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE USB
OBJECT MODULE PLACED IN usb.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE usb.c BROWSE DEFINE(WORK_AROUND_192) DEBUG OBJECTEXTEND CODE

line level    source

   1          #include "reg52modified.h"
   2          #include "types.h"
   3          #include "tusb2136.h"
   4          #include "usb.h"
   5          #include "serial.h"
   6          
   7          
   8          tDEVICE_REQUEST xdata tSetupPacket _at_ 0xff00;
   9          tEDB0 xdata tEndPoint0DescriptorBlock  _at_ 0xff80;
  10          tEDB xdata tInputEndPointDescriptorBlock[3]_at_ 0xff48;
  11          tEDB xdata tOutputEndPointDescriptorBlock[3] _at_ 0xff08;
  12          BYTE xdata abIEP0Buffer[EP0_MAX_PACKET_SIZE]  _at_ 0xfef8;
  13          BYTE xdata abOEP0Buffer[EP0_MAX_PACKET_SIZE] _at_ 0xfef0;
  14          BYTE xdata abDescriptor[SIZEOF_DEVICE_DESCRIPTOR]  _at_ 0xfe80;
  15          BYTE xdata pbOutBufferAddress[EP_MAX_PACKET_SIZE] _at_ 0xfd80; // ENDPOINT 1 OUT X buffer
  16          BYTE xdata pb48BufferAddress[EP_MAX_PACKET_SIZE] _at_ 0xfdc0;  // use ENDPOINT 1 OUT Y buffer space for bu
             -ffering the 1st 
  17                                                                         // half of 96-byte block write for UCD9110 
             -flash programming
  18          BYTE xdata pbInBufferAddress[EP_MAX_PACKET_SIZE] _at_ 0xfe00;  // ENDPOINT 1 IN X buffer
  19          
  20          #ifdef WORK_AROUND_192
  21          BYTE xdata pb145BufferAddress[160] _at_ 0xfe40;  // WW
  22          #endif
  23          
  24          /***************************************************************************
  25           * Section:    Declarations                                                *
  26           * Programmer: Craig Steiner (csteiner@vaultbbs.com)                       *
  27           * Description: This section of the code declares global and external      *
  28           *    variables, as well as functions, etc.                                *
  29           ***************************************************************************/
  30          
  31          // EXTERNAL DECLARATIONS 
  32          extern BYTE code abromReportDescriptor[SIZEOF_REPORT_DESCRIPTOR];
  33          extern unsigned char intFlags; // From keyboard.c
  34          extern unsigned char otherFlags; // From keyboard.c
  35          extern void IEP1InterruptHandler(void); // From keyboard.c
  36          extern void UsbReset(void); // From usbinit.c
  37          extern void OEP0SetLEDs(void);
  38          extern BYTE code abromReportDescriptor[SIZEOF_REPORT_DESCRIPTOR];
  39          extern BYTE code abromConfigurationDescriptorGroup[SIZEOF_BOOTCODE_CONFIG_DESC_GROUP];
  40          extern BYTE code abromDeviceDescriptor[SIZEOF_DEVICE_DESCRIPTOR];
  41          extern BYTE code LanguageId[];
  42          extern BYTE code ProductStringDescriptor[];
  43          extern BYTE code SerialNumberStringDescriptor[];
  44          extern BYTE code ManufacturerStringDescriptor[];
  45          
  46          // for PMBus/SMBus transactions. WW
  47          extern BYTE i2c_start(void);
  48          extern BYTE i2c_restart(void);
  49          extern BYTE i2c_stop(void);
  50          extern BYTE i2c_write_bytes(BYTE num_of_bytes, BYTE * source_buf);
  51          extern BYTE i2c_read_bytes(BYTE num_of_bytes, BYTE * destination_buf, BYTE nack_byte);
  52          extern void i2c_reset(void);
  53          extern BYTE calc_pec(BYTE start_crc8, BYTE length, BYTE* start_addr);
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 2   

  54          
  55          
  56          extern BYTE eeprom_read(WORD wAddress, BYTE bNumber, PBYTE pbDataArray);
  57          extern BYTE eeprom_write(WORD wAddress, BYTE bNumber, PBYTE pbDataArray);
  58          
  59          
  60          // GLOBAL VARIABLE DECLARATIONS
  61          bit deviceReady = FALSE;                // Indicates whether the device has been
  62                                                                          // properly initialized on the USB bus.
  63          bit bSuspended = FALSE;             // Indicates whether the device is suspended or not
  64          BYTE bStatusAction;                             // Indicates the current state of sending
  65                                                                          // receiving data packets.
  66          BYTE bUsbDeviceAddress;                 // The device's USB address.
  67          WORD wBytesRemainingOnIEP0;     // For endpoint zero transmitter only
  68                                          // Holds count of bytes remaining to be
  69                                          // transmitted by endpoint 0.  A value
  70                                          // of 0 means that a 0-length data packet
  71                                          // A value of 0xFFFF means that transfer
  72                                          // is complete.
  73          bit bHostAskMoreDataThanAvailable;
  74                                          // If host ask more data then TUSB2136 has
  75                                          // It will send one zero-length packet
  76                                          // if the asked lenght is a multiple of
  77                                          // max. size of endpoint 0
  78          PBYTE pbIEP0Buffer;             // A buffer pointer to input end point 0
  79                                          // Data sent back to host is copied from
  80                                          // this pointed memory location
  81          BYTE bConfigurationNumber = 0;  // Set to 1 when USB device has been
  82                                          // configured, set to 0 when unconfigured
  83          BYTE bInterfaceNumber = 0;              // The interface number selected
  84          WORD wDeviceFeatures = 0;               // The device features
  85          WORD wBytesRemainingOnOEP0;     // For endpoint zero transmitter only
  86                                          // Holds count of bytes remaining to be
  87                                          // received by endpoint 0.  A value
  88                                          // of 0 means that a 0-length data packet
  89                                          // A value of 0xFFFF means that transfer
  90          PBYTE pbOEP0Buffer;             // A buffer pointer to output end point 0
  91                                          // Data sent from host is copied to
  92                                          // this pointed memory location
  93                                          // is complete.
  94          
  95          WORD pmb_clk_low_stretch_timer;
  96          BYTE previous_crc8;
  97          bit PMBus_Error; // 0 - success; 1 - fail. WW
  98          bit PMBus_Busy; // 1 - busy; 0 - idle. WW
  99          bit PMBus_Group_Command_Busy; // 1 - busy; 0 - idle. WW
 100          bit With_PEC; 
 101          bit Set_400KHz; // 1 for 400KHz; 0 for 100KHz
 102          
 103          BYTE volatile bdata my_bits; // create a global bit-addressable variable. WW
 104          sbit my_bit7 = my_bits ^ 7;
 105          sbit my_bit6 = my_bits ^ 6;
 106          sbit my_bit5 = my_bits ^ 5;
 107          sbit my_bit4 = my_bits ^ 4;
 108          sbit my_bit3 = my_bits ^ 3;
 109          sbit my_bit2 = my_bits ^ 2;
 110          sbit my_bit1 = my_bits ^ 1;
 111          sbit my_bit0 = my_bits ^ 0;
 112          
 113          
 114          #define usbClearOEP0ByteCount tEndPoint0DescriptorBlock.bOEPBCNT = 0x00
 115          #define usbStallOEP0          tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 3   

 116          
 117          void usbGetConfiguration(void);
 118          void usbSetConfiguration(void);
 119          void usbSetReport(void);
 120          void OEP1InterruptHandler(void);
 121          void usbGetDeviceDescriptor(void);
 122          void usbGetHIDDescriptor(void);
 123          void usbGetConfigurationDescriptor(void);
 124          void usbGetStringDescriptor(void);
 125          void usbGetReportDescriptor(void);
 126          void usbSetIdle(void);
 127          void usbGetIdle(void);
 128          void usbSetProtocol(void);
 129          void usbGetProtocol(void);
 130          void usbGetInterface(void);
 131          void usbSetInterface(void);
 132          void usbGetDeviceStatus(void);
 133          void usbSetRemoteWakeup(void);
 134          void usbClearRemoteWakeup(void);
 135          void usbGetInterfaceStatus(void);
 136          void usbSetAddress(void);
 137          void usbSetEndpointHalt(void);
 138          void usbClearEndpointHalt(void);
 139          void usbGetEndpointStatus(void);
 140          void usbNonStandardRequest(void);
 141          void usbDecodeAndProcessUsbRequest(void);
 142          void usbReceiveNextPacketOnOEP0(void);
 143          void SetupPacketInterruptHandler(void);
 144          void OEP0InterruptHandler(void);
 145          void IEP0InterruptHandler(void);
 146          
 147          void usbReceiveDataPacketOnEP0(PBYTE pbBuffer);
 148          void usbStallEndpoint0(void);
 149          void usbSendZeroLengthPacketOnIEP0(void);
 150          void usbSendNextPacketOnIEP0(void);
 151          void usbSendDataPacketOnEP0(PBYTE pbBuffer);
 152          
 153          
 154          
 155          
 156          /***************************************************************************
 157           * Section:    USB REQUEST FUNCTIONS                                       *
 158           * Programmer: Craig Steiner (csteiner@vaultbbs.com) based on code by      *
 159           *             Lobo Tai (lobotai@ti.com)                                   *
 160           * Description: The functions in this section of code are called by the    *
 161           *    usbDecodeAndProcessUsbRequest function when a Setup packet is        *
 162           *    received.  Each function handles a specific USB/Class/Endpoint       *
 163           *    function.                                                            *
 164           ***************************************************************************/
 165          
 166          // The Get/Set configuration functions allow the host to select one of various
 167          // configurations that the keyboard may support.  This firmware only supports
 168          // one configuration, but the following functions allow the firmware to accept
 169          // any given configuration number.  The code, as-is, will function identically
 170          // in any given configuration, but additional configurations may be supported
 171          // by simply adding support for the configurations, presumably in keyboard.c.
 172          
 173          void usbGetConfiguration(void)
 174          {
 175   1              rs232_printstr("GetCFG\r\n");
 176   1          wBytesRemainingOnIEP0 = 1;
 177   1          usbSendDataPacketOnEP0((PBYTE) &bConfigurationNumber);
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 4   

 178   1      }
 179          
 180          void usbSetConfiguration(void)
 181          {
 182   1              rs232_printstr("SetCFG\r\n");
 183   1          usbStallOEP0;
 184   1          bConfigurationNumber = tSetupPacket.bValueL;
 185   1              tInputEndPointDescriptorBlock[0].bEPCNF |= EPCNF_UBME|EPCNF_USBIE;      
 186   1              tInputEndPointDescriptorBlock[0].bEPBCTX = 0x00;
 187   1          usbSendZeroLengthPacketOnIEP0();
 188   1      }
 189          
 190          
 191          // we don't use this function. WW
 192          // The Set_Report request is sent by the host to a typical HID device,
 193          // such as this keyboard, to update the LEDs that correspond to the
 194          // scroll lock, caps lock, and num lock.  When the Set_Report setup
 195          // packet is received, we initiate a "Receive Data Packet" sequence
 196          // since the actual 1-byte data value will be in the following
 197          // packet on OEP0.  Thus we initicate that we will receive 1 byte
 198          // (since the LED data is contained in a single byte) and we
 199          // instruct the receive routine to receive the data at the address
 200          // at which the bLED variable is located.  Thus bLed will automatically
 201          // be updated with the new value after the transfer is completed.
 202          void usbSetReport(void)
 203          {
 204   1              rs232_printstr("SetRp\r\n");
 205   1          wBytesRemainingOnOEP0 = 1;
 206   1          usbReceiveDataPacketOnEP0((PBYTE) 0xFEA0); // point to output endpoint 2 X buffer since we don't use i
             -t
 207   1      }
 208          
 209          void OEP1InterruptHandler(void)
 210          {
 211   1      /*
 212   1              rs232_printstr("EP1OUT buffer:");
 213   1              rs232_printhex(pbOutBufferAddress[0]);
 214   1              rs232_printhex(pbOutBufferAddress[1]);
 215   1              rs232_printhex(pbOutBufferAddress[2]);
 216   1              rs232_printhex(pbOutBufferAddress[3]);
 217   1              rs232_printhex(pbOutBufferAddress[4]);
 218   1              rs232_printhex(pbOutBufferAddress[5]);
 219   1              rs232_printhex(pbOutBufferAddress[6]);
 220   1              rs232_printhex(pbOutBufferAddress[7]);
 221   1              rs232_printstr("\r\n");*/
 222   1              P0=~pbOutBufferAddress[0];
 223   1          // clear NAK bit so that more OUT packet can go out of the host
 224   1          tOutputEndPointDescriptorBlock[0].bEPBCTX = 0x00;
 225   1              
 226   1      }
 227          
 228          
 229          // The following functions are called at initial device enumeration, and are used
 230          // to obtain the device, configuration, and string descriptors from the
 231          // device.
 232          void usbGetDeviceDescriptor(void)
 233          {
 234   1              BYTE bTemp;
 235   1              rs232_printstr("GDD\r\n");
 236   1              // Copy the DEVICE DESCRIPTOR from program "ROM" to XRAM
 237   1          for(bTemp=0;bTemp<SIZEOF_DEVICE_DESCRIPTOR;bTemp++)
 238   1              abDescriptor[bTemp] = abromDeviceDescriptor[bTemp];
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 5   

 239   1      
 240   1          usbClearOEP0ByteCount;
 241   1          wBytesRemainingOnIEP0 = SIZEOF_DEVICE_DESCRIPTOR;
 242   1          usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
 243   1          
 244   1          // Once the Device Descriptor has been sent, the device can essentially
 245   1          // function.  Thus we enable the deviceReady variable so that the main
 246   1          // code in keyboard.c knows that it can begin the service loop.
 247   1              deviceReady = TRUE;    
 248   1      }
 249          
 250          void usbGetHIDDescriptor(void)
 251          {
 252   1              BYTE bTemp;
 253   1              // Copy the DEVICE DESCRIPTOR from program "ROM" to XRAM
 254   1          for(bTemp=0;bTemp<SIZEOF_DEVICE_DESCRIPTOR;bTemp++)
 255   1              abDescriptor[bTemp] = abromConfigurationDescriptorGroup[SIZEOF_CONFIG_DESCRIPTOR+SIZEOF_INTERFACE_
             -DESCRIPTOR + bTemp];
 256   1      
 257   1          usbClearOEP0ByteCount;
 258   1          wBytesRemainingOnIEP0 = SIZEOF_KEYBD_HID_DESCRIPTOR;
 259   1          usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
 260   1      }
 261          
 262          void usbGetConfigurationDescriptor(void)
 263          {
 264   1              BYTE bTemp;
 265   1              rs232_printstr("GDC\r\n");
 266   1              // Copy the DEVICE DESCRIPTOR from program "ROM" to XRAM
 267   1          for(bTemp=0;bTemp<abromConfigurationDescriptorGroup[2];bTemp++)
 268   1              abDescriptor[bTemp] = abromConfigurationDescriptorGroup[bTemp];
 269   1          usbClearOEP0ByteCount;
 270   1          wBytesRemainingOnIEP0 = SIZEOF_BOOTCODE_CONFIG_DESC_GROUP;
 271   1          usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
 272   1      }
 273          
 274          void usbGetStringDescriptor(void)
 275          {
 276   1              BYTE bTemp;
 277   1              rs232_printstr("GDS");
 278   1              rs232_printhex(tSetupPacket.bValueL);
 279   1              rs232_printstr("\r\n");
 280   1              // Copy the DEVICE DESCRIPTOR from program "ROM" to XRAM
 281   1              switch(tSetupPacket.bValueL)
 282   1              {
 283   2              case 0://Language ID    
 284   2                  for(bTemp=0;bTemp<LanguageId[0];bTemp++)
 285   2                      abDescriptor[bTemp] = LanguageId[bTemp];
 286   2                  usbClearOEP0ByteCount;
 287   2                  wBytesRemainingOnIEP0 = LanguageId[0];
 288   2                      break;
 289   2              case 1://Manufacturer
 290   2                  for(bTemp=0;bTemp<ManufacturerStringDescriptor[0];bTemp++)
 291   2                      abDescriptor[bTemp] = ManufacturerStringDescriptor[bTemp];
 292   2                  usbClearOEP0ByteCount;
 293   2                  wBytesRemainingOnIEP0 = ManufacturerStringDescriptor[0];
 294   2                      break;
 295   2              case 2://Prod
 296   2                  for(bTemp=0;bTemp<ProductStringDescriptor[0];bTemp++)
 297   2                      abDescriptor[bTemp] = ProductStringDescriptor[bTemp];
 298   2                  usbClearOEP0ByteCount;
 299   2                  wBytesRemainingOnIEP0 = ProductStringDescriptor[0];
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 6   

 300   2                      break;
 301   2              case 3://serial
 302   2                  for(bTemp=0;bTemp<SerialNumberStringDescriptor[0];bTemp++)
 303   2                      abDescriptor[bTemp] = SerialNumberStringDescriptor[bTemp];
 304   2                  usbClearOEP0ByteCount;
 305   2                  wBytesRemainingOnIEP0 = SerialNumberStringDescriptor[0];
 306   2                      break;
 307   2              }
 308   1          usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
 309   1      }
 310          
 311          void usbGetReportDescriptor(void)
 312          {
 313   1          usbClearOEP0ByteCount;
 314   1              rs232_printstr("GDRp\r\n");
 315   1          wBytesRemainingOnIEP0 = SIZEOF_REPORT_DESCRIPTOR;
 316   1          usbSendDataPacketOnEP0((PBYTE)&abromReportDescriptor);
 317   1      }
 318          
 319          // Support of the following two functions is optional.  Supporting these
 320          // features allows the host to set the Idle rate.  By default, an HID
 321          // device should always report the current status of the keys, even
 322          // if they haven't changed.  However, to save bandwidth, Windows will
 323          // attempt to set the Idle rate to 0 which means the firmware should
 324          // only report keypresses when their state changes.
 325          
 326          BYTE gbIdleRateL;
 327          BYTE gbIdleRateH;
 328          void usbSetIdle(void)
 329          {
 330   1      //    usbStallOEP0;
 331   1              rs232_printstr("SETIDLE\r\n");
 332   1          gbIdleRateL = tSetupPacket.bValueL;
 333   1          gbIdleRateH = tSetupPacket.bValueH;
 334   1          usbSendZeroLengthPacketOnIEP0();
 335   1      }
 336          
 337          void usbGetIdle(void)
 338          {
 339   1              rs232_printstr("GETIDLE\r\n");
 340   1          wBytesRemainingOnIEP0 = 1;
 341   1          usbSendDataPacketOnEP0(&gbIdleRateH);
 342   1      }
 343          
 344          BYTE gbProtocol=1; // default is report protocol
 345          void usbSetProtocol(void)
 346          {
 347   1      //    usbStallOEP0;
 348   1              rs232_printstr("SET_Protocol\r\n");
 349   1          gbProtocol = tSetupPacket.bValueL;
 350   1          usbSendZeroLengthPacketOnIEP0();
 351   1      }
 352          
 353          void usbGetProtocol(void)
 354          {
 355   1              rs232_printstr("GET_Protocol\r\n");
 356   1          wBytesRemainingOnIEP0 = 1;
 357   1          usbSendDataPacketOnEP0(&gbProtocol);
 358   1      }
 359          
 360          // The Get/Set Interface, like the Get/Set Configuration, don't really
 361          // serve any real purpose in this firmware, but they are handled so
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 7   

 362          // that modifications to the code may be made easily.  As-is, the host
 363          // may Set any interface number, and a Get Interface request will simply
 364          // return the value previously Set.
 365          
 366          void usbGetInterface(void)
 367          {
 368   1              rs232_printstr("GET_Interface\r\n");
 369   1          wBytesRemainingOnIEP0 = 1;
 370   1          usbSendDataPacketOnEP0((PBYTE) &bInterfaceNumber);
 371   1      }
 372          
 373          void usbSetInterface(void)
 374          {
 375   1              rs232_printstr("SET_Interface\r\n");
 376   1          usbStallOEP0;                             // control write without data stage
 377   1          bInterfaceNumber = tSetupPacket.bIndexL;
 378   1          usbSendZeroLengthPacketOnIEP0();
 379   1      }
 380          
 381          // The GetDeviceStatus function is used to obtain the status of the
 382          // device.  The status is essentially the Remote Wakeup status as 
 383          // well as the "Self-powered" indicator.  The value returned by
 384          // GetDeviceStatus is modified by the SetRemoteWakeup and
 385          // ClearRemoteWakeup requests.
 386          
 387          void usbGetDeviceStatus(void)
 388          {
 389   1              rs232_printstr("GET_DevSta\r\n");
 390   1          wBytesRemainingOnIEP0 = 2;
 391   1              usbSendDataPacketOnEP0((PBYTE) &wDeviceFeatures);
 392   1      }
 393          
 394          void usbSetRemoteWakeup(void)
 395          {
 396   1              rs232_printstr("SET_RotWk\r\n");
 397   1              bUSBCTL |= USBCTL_RWE;
 398   1              wDeviceFeatures |= 0x0200;
 399   1          usbStallOEP0;
 400   1          usbSendZeroLengthPacketOnIEP0();
 401   1      }
 402          
 403          void usbClearRemoteWakeup(void)
 404          {
 405   1              rs232_printstr("CLR_RotWk\r\n");
 406   1              bUSBCTL &= ~USBCTL_RWE;
 407   1              wDeviceFeatures &= ~0x0200;
 408   1          usbStallOEP0;
 409   1          usbSendZeroLengthPacketOnIEP0();
 410   1      }
 411          
 412          // The GetInterfaceStatus always returns a 0 as a 2-byte value.
 413          
 414          void usbGetInterfaceStatus(void)
 415          {
 416   1              WORD wStatusBuffer = 0x00;    
 417   1              rs232_printstr("GetInfSta\r\n");        
 418   1          usbStallOEP0;
 419   1          wBytesRemainingOnIEP0 = 2;
 420   1              usbSendDataPacketOnEP0((PBYTE) &wStatusBuffer);
 421   1      }
 422          
 423          // The SetAddress request allows the host to assign an address to this device.
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 8   

 424          // The device starts with an address of 00h, as do all USB devices, until
 425          // the host specifically assigns it another address.  This code handles that
 426          // assignment.
 427          
 428          void usbSetAddress(void)
 429          {
 430   1              rs232_printstr("SetAddr:");
 431   1              rs232_printhex(tSetupPacket.bValueL);
 432   1              rs232_printstr("\r\n");
 433   1          if(tSetupPacket.bValueL < 128)
 434   1              {
 435   2              bFUNADR = tSetupPacket.bValueL;
 436   2              bUsbDeviceAddress = tSetupPacket.bValueL;
 437   2              bStatusAction = STATUS_ACTION_SET_ADDRESS;
 438   2              usbSendZeroLengthPacketOnIEP0();
 439   2              }
 440   1          else 
 441   1              usbStallEndpoint0();
 442   1      }
 443          
 444          // The SetEndpointHalt allows the USB host to instruct the device to stop sending
 445          // information on IEP1, which is how the firmware delivers keystrokes to the host.
 446          // This is used mostly if a device goes crazy and starts sending too much data,
 447          // this allows the host to shut the endpoint down.  All we do is set or clear
 448          // the endpoint enable bit appropriately.  The GetEndpointStatus request reports
 449          // the status of the endpoint which is affected by Set/Clear EndpointHalt requests.
 450          
 451          void usbSetEndpointHalt(void)
 452          {
 453   1              rs232_printstr("SetEpHalt\r\n");
 454   1              tInputEndPointDescriptorBlock[0].bEPCNF &= ~EPCNF_UBME;
 455   1          usbSendZeroLengthPacketOnIEP0();
 456   1      }
 457          
 458          void usbClearEndpointHalt(void)
 459          {
 460   1              rs232_printstr("ClrEpHalt\r\n");
 461   1              tInputEndPointDescriptorBlock[0].bEPCNF |= EPCNF_UBME;  
 462   1          usbSendZeroLengthPacketOnIEP0();
 463   1      }
 464          
 465          void usbGetEndpointStatus(void)
 466          {
 467   1              WORD wEndpointStatus = 0x0100;
 468   1              rs232_printstr("GetEpSta\r\n");
 469   1              if(tInputEndPointDescriptorBlock[0].bEPCNF & EPCNF_UBME)
 470   1                      wEndpointStatus = 0x0000;
 471   1      
 472   1          wBytesRemainingOnIEP0 = 2;
 473   1              usbSendDataPacketOnEP0((PBYTE) &wEndpointStatus);
 474   1      }
 475          
 476          // Any non-standard or unrecognized request will arrive at the following
 477          // function by default.  We automatically stall the endpoint to indicate
 478          // it's an invalid or unrecognized request.
 479          
 480          void usbNonStandardRequest(void)
 481          {
 482   1              rs232_printstr("NonStandardReq\r\n");
 483   1              usbStallEndpoint0();
 484   1      }
 485          
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 9   

 486          /***************************************************************************
 487           * Section:    REQUEST STRUCTURE                                           *
 488           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 489           * Description: This section of code defines the structure of the lookup   *
 490           *    table which determines which 'C' function should be called for each  *
 491           *    supported USB request.                                               * 
 492           ***************************************************************************/
 493          
 494          typedef struct _tDEVICE_REQUEST_COMPARE
 495          {
 496              BYTE    bmRequestType;              // See bit definitions below
 497              BYTE    bRequest;                   // See value definitions below
 498              BYTE    bValueL;                    // Meaning varies with request type
 499              BYTE    bValueH;                    // Meaning varies with request type
 500              BYTE    bIndexL;                    // Meaning varies with request type
 501              BYTE    bIndexH;                    // Meaning varies with request type
 502              BYTE    bLengthL;                   // Number of bytes of data to transfer (LSByte)
 503              BYTE    bLengthH;                   // Number of bytes of data to transfer (MSByte)
 504              BYTE    bCompareMask;               // MSB is bRequest, if set 1, bRequest should be matched, LSB is b
             -LengthH
 505              VOID    (*pUsbFunction)(VOID);      // function pointer
 506          } tDEVICE_REQUEST_COMPARE, *ptDEVICE_REQUEST_COMPARE;
 507          
 508          /***************************************************************************
 509           * Section:    USB REQUEST TABLE                                           *
 510           * Programmer: Craig Steiner (csteiner@vaultbbs.com) based on code by      *
 511           *             Lobo Tai (lobotai@ti.com)                                   *
 512           * Description: This section of code defines the lookup table, using the   *
 513           *    structure defined in the previous section of code.  The values of    *
 514           *    the constants used in this structure are defined in usb.h.           * 
 515           * Structure of Table:                                                     * 
 516           *    bmRequestType: Indicates the type of request.  This is a bit-mapped  * 
 517           *          variable defined in the USB spec.  The bits of this variable   * 
 518           *          have the following purpose, and are defined in usb.h.          * 
 519           *          Bit 7: Data Direction (0=Host to Device, 1=Device to Host)     * 
 520           *          Bit 6-5: Type of request (00=Standard, 01=Class, 10=Vendor)    * 
 521           *          Bit 4-0: Recipient (00000=Device, 00001=Interface,             *
 522           *                              00010=Endpoint, 00011=Other                *
 523           *    bRequest: Indicates the request ID (Get descriptor, Get Status, Get  *
 524           *              feature, etc.).  These are defined in the USB and HID spec *
 525           *              and are declared in usb.h.                                 *
 526           *    bValueL/H: Additional values, purpose varies with request.           *
 527           *    bIndexL/H: Additional values, purpose varies with request.           *
 528           *    bLengthL/H: Number of bytes to transfer to or from host.             *
 529           *    bCompareMask: Indicates which of the above bytes should be compared  *
 530           *               to determine the function to call.  For example, the mask *
 531           *               0x80 means only bmRequestType must match. 0xC0 means      *
 532           *               both bmRequestType and bRequest must match.  If this      *
 533           *               variable is 0x00, as is the case in the last entry in the *
 534           *               table, then no bytes are compared and, thus, ANY packet   *
 535           *               will pass the comparsion stage.  This technique is used   *
 536           *               in the last entry of the table as an "else" condition     *
 537           *               so that any requests that haven't been handled by that    *
 538           *               point are handled by the usbNonStandardRequest function.  *
 539           ***************************************************************************/
 540          
 541          code tDEVICE_REQUEST_COMPARE tUsbRequestList[] =
 542          {
 543              // SET ENDPOINT FEATURE
 544              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_ENDPOINT,
 545              USB_REQ_SET_FEATURE,
 546              FEATURE_ENDPOINT_STALL,0x00,
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 10  

 547              0xff,0x00,
 548              0x00,0x00,
 549              0xf7,&usbSetEndpointHalt,
 550          
 551              // CLEAR ENDPOINT FEATURE
 552              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_ENDPOINT,
 553              USB_REQ_CLEAR_FEATURE,
 554              FEATURE_ENDPOINT_STALL,0x00,
 555              0xff,0x00,
 556              0x00,0x00,
 557              0xf7,&usbClearEndpointHalt,
 558          
 559              // GET CONFIGURATION
 560              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 561              USB_REQ_GET_CONFIGURATION,
 562              0x00,0x00,
 563              0x00,0x00,
 564              0x01,0x00,
 565              0xff,&usbGetConfiguration,
 566          
 567              // SET CONFIGURATION
 568              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 569              USB_REQ_SET_CONFIGURATION,
 570              0xff,0x00,
 571              0x00,0x00,
 572              0x00,0x00,
 573              0xdf,&usbSetConfiguration,
 574          
 575              // GET DEVICE DESCRIPTOR
 576              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 577              USB_REQ_GET_DESCRIPTOR,
 578              0xff,DESC_TYPE_DEVICE,                  // bValueL is index and bValueH is type
 579              0xff,0xff,
 580              0xff,0xff,
 581              0xd0,&usbGetDeviceDescriptor,
 582          
 583              // GET CONFIGURATION DESCRIPTOR
 584              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 585              USB_REQ_GET_DESCRIPTOR,
 586              0xff,DESC_TYPE_CONFIG,                  // bValueL is index and bValueH is type
 587              0xff,0xff,
 588              0xff,0xff,
 589              0xd0,&usbGetConfigurationDescriptor,
 590          
 591              // GET HID DESCRIPTOR
 592              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
 593              USB_REQ_GET_DESCRIPTOR,
 594              0xff,DESC_TYPE_HID,                  // bValueL is index and bValueH is type
 595              0xff,0xff,
 596              0xff,0xff,
 597              0xd0,&usbGetHIDDescriptor,
 598          
 599              // GET STRING DESCRIPTOR
 600              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 601              USB_REQ_GET_DESCRIPTOR,
 602              0xff,DESC_TYPE_STRING,                  // bValueL is index and bValueH is type
 603              0xff,0xff,
 604              0xff,0xff,
 605              0xd0,&usbGetStringDescriptor,
 606          
 607              // GET REPORT DESCRIPTOR
 608              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 11  

 609              USB_REQ_GET_DESCRIPTOR,
 610              0xff,DESC_TYPE_REPORT,                 // bValueL is index and bValueH is type
 611              0xff,0xff,
 612              0xff,0xff,
 613              0xd0,&usbGetReportDescriptor,
 614          
 615              // SET REPORT
 616              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
 617              USB_REQ_SET_REPORT,
 618              0xff,0xFF,                 // bValueL is index and bValueH is type
 619              0xff,0xff,
 620              0xff,0xff,
 621              0xC0,&usbSetReport,
 622          
 623              // SET IDLE
 624              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
 625              USB_REQ_SET_IDLE,
 626              0xff,0xFF,                  // bValueL is index and bValueH is type
 627              0xff,0xff,
 628              0x00,0x00,
 629              0xc3,&usbSetIdle,
 630          
 631              // SET PROTOCOL
 632              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
 633              USB_REQ_SET_PROTOCOL,
 634              0xff,0xFF,                  // bValueL is index and bValueH is type
 635              0xff,0xff,
 636              0x00,0x00,
 637              0xc3,&usbSetProtocol,
 638          
 639              // GET IDLE
 640              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
 641              USB_REQ_GET_IDLE,
 642              0xff,0xFF,                  // bValueL is index and bValueH is type
 643              0xff,0xff,
 644              0x01,0x00,
 645              0xc3,&usbGetIdle,
 646          
 647              // GET PROTOCOL
 648              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
 649              USB_REQ_GET_PROTOCOL,
 650              0xff,0xFF,                  // bValueL is index and bValueH is type
 651              0xff,0xff,
 652              0x01,0x00,
 653              0xc3,&usbGetProtocol,
 654          
 655              // GET INTERFACE
 656              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
 657              USB_REQ_GET_INTERFACE,
 658              0x00,0x00,
 659              0xff,0xff,
 660              0x01,0x00,
 661              0xf3,&usbGetInterface,
 662          
 663              // GET DEVICE STATUS
 664              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 665              USB_REQ_GET_STATUS,
 666              0x00,0x00,
 667              0x00,0x00,
 668              0x02,0x00,
 669              0xff,&usbGetDeviceStatus,
 670          
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 12  

 671              // GET INTERFACE STATUS
 672              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
 673              USB_REQ_GET_STATUS,
 674              0x00,0x00,
 675              0xff,0x00,
 676              0x02,0x00,
 677              0xf7,&usbGetInterfaceStatus,
 678          
 679              // GET ENDPOINT STATUS
 680              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_ENDPOINT,
 681              USB_REQ_GET_STATUS,
 682              0x00,0x00,
 683              0xff,0x00,
 684              0x02,0x00,
 685              0xf7,&usbGetEndpointStatus,
 686          
 687              // SET ADDRESS
 688              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 689              USB_REQ_SET_ADDRESS,
 690              0xff,0x00,
 691              0x00,0x00,
 692              0x00,0x00,
 693              0xdf,&usbSetAddress,
 694          
 695              // SET DEVICE FEATURE
 696              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 697              USB_REQ_SET_FEATURE,
 698              FEATURE_REMOTE_WAKEUP,0x00,           // feature selector
 699              0x00,0x00,
 700              0x00,0x00,
 701              0xff,&usbSetRemoteWakeup, // df, setDeviceFeature
 702              
 703                  // CLEAR DEVICE FEATURE
 704              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 705              USB_REQ_CLEAR_FEATURE,
 706              FEATURE_REMOTE_WAKEUP,0x00,
 707              0x00,0x00,
 708              0x00,0x00,
 709              0xff,&usbClearRemoteWakeup,
 710          
 711              // SET INTERFACE FEATURE
 712              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
 713              USB_REQ_SET_INTERFACE,
 714              0xff,0x00,                      // alternative setting
 715              0xff,0x00,                      // interface number
 716              0x00,0x00,
 717              0xd7,&usbSetInterface,
 718          
 719                  // END OF LIST CATCH-ALL REQUEST: 
 720                  // This will match any USB request sicne bCompareMask is 0x00.
 721              0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
 722              0x00,&usbNonStandardRequest
 723          };
 724          
 725          /***************************************************************************
 726           * Function:   UsbDecodeAndProcessUsbRequest()                             *
 727           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 728           * Description: This function is called when a USB request has been        *
 729           *    received.  It searches the tUsbRequestList[] structure defined in    * 
 730           *    the previous section for a request that matches a given entry in     * 
 731           *    the table and, when matched, executes the corresponding function.    *  
 732           ***************************************************************************/
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 13  

 733          
 734          void usbDecodeAndProcessUsbRequest(void)
 735          {
 736   1          BYTE bMask,bResult,bTemp;
 737   1          BYTE *pbUsbRequestList;                 // save code space
 738   1      /*
 739   1              rs232_printhex(*(pbEP0_SETUP_ADDRESS+0));
 740   1              rs232_printhex(*(pbEP0_SETUP_ADDRESS+1));
 741   1              rs232_printhex(*(pbEP0_SETUP_ADDRESS+2));
 742   1              rs232_printhex(*(pbEP0_SETUP_ADDRESS+3));
 743   1              rs232_printhex(*(pbEP0_SETUP_ADDRESS+4));
 744   1              rs232_printhex(*(pbEP0_SETUP_ADDRESS+5));
 745   1              rs232_printhex(*(pbEP0_SETUP_ADDRESS+6));
 746   1              rs232_printhex(*(pbEP0_SETUP_ADDRESS+7));
 747   1              rs232_printstr("\r\n");
 748   1      */
 749   1              // We initialize the pbUsbRequestList pointer to the beginning of the
 750   1              // tUsbRequestList[] so that we can subsequently traverse the table
 751   1              // by incrementing the pbUsbRequestList pointer.
 752   1          pbUsbRequestList = (PBYTE) &tUsbRequestList[0];
 753   1      
 754   1              // Cycle indefinitely until we've found an entry in the tUsbRequestList[]
 755   1              // table.  Since the last entry in the table has a 0x00 mask, we'll
 756   1              // *always* find a match, so this cycle will always exit.
 757   1          while(1)
 758   1              {
 759   2              bResult = 0x00;
 760   2              bMask   = 0x80;
 761   2      
 762   2              // We cycle through fields 0 through 7, which correspond to the 8 fields
 763   2              // in each entry of tUsbRequestList.  If the given byte in the packet
 764   2              // we just receive is equal to the corresponding byte in the table, we
 765   2              // set that bit in the result, indicating a byte which matched.  Otherwise,
 766   2              // we don't set the bit which means that byte didn't match.
 767   2              for(bTemp = 0; bTemp < 8; bTemp++)
 768   2                      {
 769   3                  if(*(pbEP0_SETUP_ADDRESS+bTemp) == *(pbUsbRequestList+bTemp)) 
 770   3                      bResult |= bMask;
 771   3                              bMask = bMask >> 1;
 772   3                      }
 773   2      
 774   2              // At this point, bResult holds 8 bits which indicate whether each of the
 775   2              // bytes in the packet matched the corresponding bytes in the tUsbRequestList[]
 776   2              // table.  We then AND the mask value in the table with the result so that
 777   2              // we only are comparing the bits required in the mask.  If the resulting
 778   2              // value is equal to the mask, that means that all significant bytes match.
 779   2              // This is done since any bit that is clear in the mask is a "don't care", so
 780   2              // the AND makes sure we don't reject a "valid" comparison beause a don't 
 781   2              // care bit actually matched.
 782   2              if((*(pbUsbRequestList+bTemp) & bResult) == *(pbUsbRequestList+bTemp)) 
 783   2                      break;
 784   2      
 785   2              // If we haven't found a matching entry yet, we advenced the pointer to point
 786   2              // to the next entry in the table, and keep looking.
 787   2              pbUsbRequestList += sizeof(tDEVICE_REQUEST_COMPARE);
 788   2              }
 789   1      
 790   1          // We check to see if any more setup packet(s) have been received and, if so, we
 791   1          // anbandon this one to hanlde the next one.
 792   1          if(bUSBSTA & (USBSTA_SETUP | USBSTA_STPOW) != 0x00) 
 793   1              return;
 794   1      
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 14  

 795   1              // If we've reached this point of the function, we've found the function that should
 796   1              // be called given the current request.  So we call it...
 797   1              ((ptDEVICE_REQUEST_COMPARE)pbUsbRequestList)->pUsbFunction();
 798   1      }
 799          
 800          /***************************************************************************
 801           * Function:   usbStallEndpoint0()                                         *
 802           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 803           * Description: Sets the STALL flag on both IEP0 and OEP0.  Often called   *
 804           *    to reflect an error condition.                                       *
 805           ***************************************************************************/
 806          
 807          void usbStallEndpoint0(void)
 808          {
 809   1          tEndPoint0DescriptorBlock.bIEPCNFG |= EPCNF_STALL;
 810   1          tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL;
 811   1      }
 812          
 813          /***************************************************************************
 814           * Function:   usbReceiveDataPacketOnEP0 / ReceiveNextPacket               *
 815           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 816           * Description: These two functions, together, are used to receive a data  *
 817           *    payload on the OEP0 endpoint.  The reception is first initiated by   *
 818           *    calling usbReceiveDataPacketOnEP0 and indicating the address that the*
 819           *    received data should be placed in.  As each data packet is received, *
 820           *    the usbReceiveNextPacketOnOEP0 will be called to process the packet  *
 821           *    and determine if the packet received was the last packet, or if there*
 822           *    are more packets coming.                                             * 
 823           ***************************************************************************/
 824          
 825          void usbReceiveDataPacketOnEP0(PBYTE pbBuffer)
 826          {
 827   1          pbOEP0Buffer = pbBuffer;
 828   1          wBytesRemainingOnOEP0 = (WORD)(tSetupPacket.bLengthH << 8) | (WORD)tSetupPacket.bLengthL;
 829   1          bStatusAction = STATUS_ACTION_DATA_OUT;
 830   1          usbClearOEP0ByteCount;            
 831   1      }
 832          
 833          void usbReceiveNextPacketOnOEP0(void)
 834          {
 835   1          BYTE bIndex,bByte;
 836   1      
 837   1              // First we must determine how many bytes were received in this data
 838   1              // packet.  We AND it with EPBCT_BYTECNT_MASK so that a NAK condition
 839   1              // will return "0 bytes."
 840   1          bByte = tEndPoint0DescriptorBlock.bOEPBCNT & EPBCT_BYTECNT_MASK;
 841   1      
 842   1              // If the number of bytes remaining to be received is greater than
 843   1              // or equal to the number of bytes received in this packet then
 844   1              // we handle the packet.  However, if we received more bytes than
 845   1              // we had expected we simply ignore the packet since it is
 846   1              // presumably erroneous.
 847   1          if(wBytesRemainingOnOEP0 >= (WORD)bByte)
 848   1              {
 849   2                      // For each of the bytes received, we copy the value received to the
 850   2                      // next position in the buffer we set aside for the OEP0 data.
 851   2              for(bIndex=0;bIndex<bByte;bIndex++)
 852   2                  *pbOEP0Buffer++ = abOEP0Buffer[bIndex];
 853   2      
 854   2                      // We now reduce the number of bytes remaining by the number of bytes
 855   2                      // received in this packet.                              
 856   2              wBytesRemainingOnOEP0 -= (WORD)bByte;
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 15  

 857   2      
 858   2              // If there are still more bytes to be received in additional packets (i.e.,
 859   2                      // wBytesRemainingOnOEP0 is greater than zero), we clear the byte count and
 860   2                      // reestablish bStatusAction to indicate that we are still in a DATA_OUT
 861   2                      // condition.
 862   2              if(wBytesRemainingOnOEP0 > 0)
 863   2                      {
 864   3                  usbClearOEP0ByteCount;        
 865   3                  bStatusAction = STATUS_ACTION_DATA_OUT;
 866   3                      }
 867   2              else
 868   2                      {
 869   3                      // If we aren't expecting any more data bytes, we terminate the OEP0
 870   3                      // transaction by stalling OEP0 and setting the bStatusAction condition
 871   3                      // to "Nothing."  Since in this firmware the only USB function that
 872   3                      // includes a subsequent data payload is the Set_Report function, we
 873   3                      // automatically update the keyboard LEDs with the new value.  If
 874   3                      // additional features are added that expect data payloads, calling
 875   3                      // the OEP0SetLeds() function when a Set_Report request was not
 876   3                      // received will cause no harm.
 877   3                  usbStallOEP0;
 878   3                  bStatusAction = STATUS_ACTION_NOTHING;        
 879   3                              OEP0SetLEDs();
 880   3                      }
 881   2              }
 882   1          else
 883   1              {
 884   2              // If the packet we received include more data than we expected, we ignore
 885   2              // the entire packet and abort the transfer.  This is accomplished by
 886   2              // stalling OEP0 and resetting the bStatusAction condition to "Nothing."
 887   2              usbStallOEP0;
 888   2              bStatusAction = STATUS_ACTION_NOTHING;
 889   2              }
 890   1      }
 891          
 892          /***************************************************************************
 893           * Function:   usbSendZeroLengthPacketOnIEP0()                             *
 894           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 895           * Description: Sends a 0-lengthg packet back to the host on IEP0. Often   *
 896           *    called to acknowledge a packet received from the host that requires  *
 897           *    no data in the reply, just an acknowledgement of receipt.            *
 898           ***************************************************************************/
 899          
 900          void usbSendZeroLengthPacketOnIEP0(void)
 901          {
 902   1          wBytesRemainingOnIEP0 = NO_MORE_DATA;
 903   1          bStatusAction = STATUS_ACTION_NOTHING;
 904   1          tEndPoint0DescriptorBlock.bIEPBCNT = 0x00;
 905   1      }
 906          
 907          /***************************************************************************
 908           * Function:   usbSendDataPacketOnEPO / SendNext                           *
 909           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 910           * Description: These two functions, together, are responsible for sending *
 911           *    data packets back to the host on IEPO.  The transfer is initiated by *
 912           *    first calling usbSendDataPacketOnEP0 and indicating the address of   *
 913           *    the buffer to send.  This initiates the transfer and sends the first *
 914           *    packet of data.  If there is more data than can be sent in the first *
 915           *    packet, the usbSendNextPacketOnIEP0 function is called to send       *
 916           *    subsequent packets of data when an interrupt indicates the previous  *
 917           *    packet has been sent.                                                *
 918           ***************************************************************************/
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 16  

 919          
 920          void usbSendDataPacketOnEP0(PBYTE pbBuffer)
 921          {
 922   1          WORD wTemp;
 923   1      
 924   1          pbIEP0Buffer = pbBuffer;
 925   1      
 926   1          wTemp = (WORD)(tSetupPacket.bLengthH << 8) | (WORD)tSetupPacket.bLengthL;
 927   1      
 928   1          // Limit transfer size to wLength if needed
 929   1          // this prevent USB device sending 'more than require' data back to host
 930   1          if(wBytesRemainingOnIEP0 >= wTemp)
 931   1              {
 932   2              wBytesRemainingOnIEP0 = wTemp;
 933   2              bHostAskMoreDataThanAvailable = FALSE;
 934   2              }
 935   1              else
 936   1                      { 
 937   2                      bHostAskMoreDataThanAvailable = TRUE;
 938   2                      }
 939   1      
 940   1          usbSendNextPacketOnIEP0();
 941   1      }
 942          
 943          void usbSendNextPacketOnIEP0(void)
 944          {
 945   1          BYTE bPacketSize,bIndex;
 946   1      
 947   1          // First check if there are bytes remaining to be transferred
 948   1          if(wBytesRemainingOnIEP0 != NO_MORE_DATA)
 949   1              {
 950   2              if(wBytesRemainingOnIEP0 > EP0_MAX_PACKET_SIZE)
 951   2                      {
 952   3                  // More bytes are remaining than will fit in one packet
 953   3                  // there will be More IN Stage
 954   3                  bPacketSize = EP0_MAX_PACKET_SIZE;
 955   3                  wBytesRemainingOnIEP0 -= EP0_MAX_PACKET_SIZE;
 956   3                  bStatusAction = STATUS_ACTION_DATA_IN;
 957   3                      }
 958   2              else if (wBytesRemainingOnIEP0 < EP0_MAX_PACKET_SIZE)
 959   2                      {
 960   3                  // The remaining data will fit in one packet.
 961   3                  // This case will properly handle wBytesRemainingOnIEP0 == 0
 962   3                  bPacketSize = (BYTE)wBytesRemainingOnIEP0;
 963   3                  wBytesRemainingOnIEP0 = NO_MORE_DATA;        // No more data need to be Txed
 964   3                  bStatusAction = STATUS_ACTION_NOTHING;
 965   3                      }
 966   2              else
 967   2                      {
 968   3                  // wBytesRemainingOnIEP0 == EP0_MAX_PACKET_SIZE
 969   3                  bPacketSize = EP0_MAX_PACKET_SIZE;
 970   3                  if(bHostAskMoreDataThanAvailable == TRUE)
 971   3                      {
 972   4                      wBytesRemainingOnIEP0 = 0;
 973   4                      bStatusAction = STATUS_ACTION_DATA_IN;
 974   4                      }
 975   3                  else
 976   3                      { 
 977   4                      wBytesRemainingOnIEP0 = NO_MORE_DATA;
 978   4                      bStatusAction = STATUS_ACTION_NOTHING;
 979   4                      }
 980   3                      }
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 17  

 981   2      
 982   2              for(bIndex=0; bIndex<bPacketSize; bIndex++) 
 983   2                  abIEP0Buffer[bIndex] = *pbIEP0Buffer++;
 984   2      
 985   2              tEndPoint0DescriptorBlock.bIEPBCNT = bPacketSize;   // & EPBCT_BYTECNT_MASK;
 986   2                      }
 987   1          else
 988   1              {
 989   2              bStatusAction = STATUS_ACTION_NOTHING;
 990   2              }
 991   1      }
 992          
 993          /***************************************************************************
 994           * Function:   SetupPacketInterruptHandler()                               *
 995           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 996           * Description: This function is called by the UsbInterrupt function when  *
 997           *    a setup packet is received.  This function immediately sets both     * 
 998           *    OEP0 and IEP0 to a NAK state, sets the bUSBCTL to send/receive based *
 999           *    on the direction of the request, then proceeds to call  the          *
1000           *    usbDecodeAndProcessUsbRequest() function which determines which      *
1001           *    function should be called to handle the given USB request.           *  
1002           ***************************************************************************/
1003          
1004          void SetupPacketInterruptHandler(void)
1005          {
1006   1          // Hardware clears STALL in both data endpoints once valid setup packet is
1007   1          // received.  NAK both data endpoints.
1008   1          tEndPoint0DescriptorBlock.bIEPBCNT  = EPBCNT_NAK;
1009   1          tEndPoint0DescriptorBlock.bOEPBCNT  = EPBCNT_NAK;
1010   1          
1011   1          bUSBSTA = USBSTA_SETUP; // from now, hardware will refer NAK bit in I/OEPBCNT
1012   1      
1013   1          // Copy the MSB of bmRequestType to DIR bit of USBCTL to indicate the
1014   1          // direction of the transfer.
1015   1          if((tSetupPacket.bmRequestType & USB_REQ_TYPE_INPUT) == USB_REQ_TYPE_INPUT)
1016   1              bUSBCTL |= USBCTL_DIR;
1017   1          else 
1018   1              bUSBCTL &= ~USBCTL_DIR;
1019   1      
1020   1              // Clear the bStatusAction to indicate that, at this point, nothing is 
1021   1              // happening (it may be set to DATA_OUT by specific functions that
1022   1              // expect a DATA packet following the setup packet).
1023   1          bStatusAction = STATUS_ACTION_NOTHING;
1024   1      
1025   1              // Call the function that determines which function should be called to
1026   1              // handle the specific USB request.
1027   1          usbDecodeAndProcessUsbRequest();
1028   1      }
1029          
1030          /***************************************************************************
1031           * Function:   OEP0InterruptHandler()                                      *
1032           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
1033           * Description: This function is called by the UsbInterrupt function when  *
1034           *    a USB interrupt is called by OEP0.  This will happen once a data     *
1035           *    transfer has been initialized by a USB function handler by calling   *
1036           *    usbReceiveDataPacketOnEP0.                                           *
1037           ***************************************************************************/
1038          
1039          void OEP0InterruptHandler(void)
1040          {
1041   1              // We clear the IEP0 byte count since we have nothing to send out.
1042   1          tEndPoint0DescriptorBlock.bIEPBCNT = 0x00;
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 18  

1043   1              rs232_printstr("\r\nOUT RP:");
1044   1              rs232_printhex(abOEP0Buffer[0]);
1045   1              rs232_printstr("\r\n");
1046   1              // We now handle the interrupt based on the bStatusAction condition.
1047   1              // If we are in a DATA_OUT condition, we call the usbReceiveNextPacketOnEP0
1048   1              // function to copy the data payload to its correct buffer.  If we are
1049   1              // not expecting any data on OEP0, we set the stall flag to stall the
1050   1              // endpoint and abort any additional data that may otherwise be
1051   1              // sent.
1052   1          if(bStatusAction == STATUS_ACTION_DATA_OUT) 
1053   1              usbReceiveNextPacketOnOEP0(); // Handle this data packet
1054   1          else 
1055   1              tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL; // We weren't expecting data
1056   1      }
1057          
1058          /***************************************************************************
1059           * Function:   IEP0InterruptHandler()                                      *
1060           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
1061           * Description: This function is called by the UsbInterrupt function when  *
1062           *    a USB interrupt is caused by IEP0.  This will happen once the data   *
1063           *    sent by calling usbSendNextPacketOnIEP0 and means the previous data  *
1064           *    packet has been sent.  At that point, there are two conditions:      *
1065           *    either there is more data to send or there isn't.  If there is, we   *
1066           *    call usbSendNextPacketOnIEP0 to send the next packet of data.  If    *
1067           *    there isn't anymore data, we stall.  However, if the bStatusAction   *
1068           *    condition indicates that we were changing the devices address, we    *
1069           *    do so at this point.                                                 *
1070           ***************************************************************************/
1071          
1072          void IEP0InterruptHandler(void)
1073          {
1074   1              // We clear the OEP0 byte count since we are not expecting any data.
1075   1          tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
1076   1      
1077   1              // We now handle the interrupt based on the bStatusAction condition.
1078   1              // If we are in a DATA_IN condition, we call the usbSendNextPacketOnIEP0  
1079   1              // function to send the next data payload packet.  If we are in a
1080   1              // Set Address mode, we modify the address.  In any other case, we've
1081   1              // sent all teh data we had to send, so we stall the endpoint to indicate
1082   1              // there is no more data to send.
1083   1          if(bStatusAction == STATUS_ACTION_DATA_IN) 
1084   1              usbSendNextPacketOnIEP0(); // Send the next data packet
1085   1          else if(bStatusAction == STATUS_ACTION_SET_ADDRESS) 
1086   1              bFUNADR = bUsbDeviceAddress; // Set the device's address
1087   1          else 
1088   1              tEndPoint0DescriptorBlock.bIEPCNFG |= EPCNF_STALL; // No more data to send
1089   1      }
1090          
1091          /***************************************************************************
1092           * Function:   USBInterrupt                                                *
1093           * Programmer: Craig Steiner (csteiner@vaultbbs.com)                       *
1094           * Description: Handles the USB interrupts generated by the USB sectiob of *
1095           *    the part.  This is actually External 0 interrupt on the 8051 at      *
1096           *    0x0003 in memory, but is used exclusively for USB interrupts on the  *
1097           *    TUSB2136.                                                            * 
1098           *                                                                         * 
1099           * Note: VECINT is cleared after being handled successfully so that the    * 
1100           *       next USB-related interrupt is made available to the handler.      *  
1101           ***************************************************************************/
1102          
1103          void USBInterrupt(void) interrupt 0
1104          {
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 19  

1105   1              // Disable all interrupts because this is critical code
1106   1              EA = DISABLE;
1107   1              // Select the appropriate interrupt handler depending on the VECINT value
1108   1          switch (bVECINT)
1109   1              {
1110   2                      case VECINT_OUTPUT_ENDPOINT0:
1111   2                              bVECINT  = 0x00;
1112   2                              rs232_printstr("EP0_out  ");
1113   2                              OEP0InterruptHandler();                 
1114   2                              break;
1115   2      
1116   2              case VECINT_INPUT_ENDPOINT0:
1117   2                              bVECINT  = 0x00;
1118   2                              rs232_printstr("EP0_in  ");
1119   2                              IEP0InterruptHandler();                 
1120   2                              break;
1121   2      
1122   2                      case VECINT_INPUT_ENDPOINT1:
1123   2                              bVECINT = 0x00;
1124   2                              rs232_printstr("EP1_in  ");
1125   2                              IEP1InterruptHandler();
1126   2                              break;
1127   2      
1128   2                      case VECINT_OUTPUT_ENDPOINT1:
1129   2                              bVECINT = 0x00;
1130   2                              rs232_printstr("EP1_out  ");
1131   2                              OEP1InterruptHandler();
1132   2                              break;
1133   2      
1134   2              case VECINT_STPOW_PACKET_RECEIVED:
1135   2                              bVECINT  = 0x00;
1136   2                              bUSBSTA = USBSTA_STPOW;
1137   2                              rs232_printstr("STPOW  ");
1138   2                              SetupPacketInterruptHandler();
1139   2                              break;
1140   2      
1141   2              case VECINT_SETUP_PACKET_RECEIVED:
1142   2              // hardware will NAK data stage, no matter NAK bit in I/OEPBCNT
1143   2                              bVECINT  = 0x00;
1144   2      //                      bUSBSTA = USBSTA_SETUP; // from now, hardware will refer NAK bit in I/OEPBCNT
1145   2                              rs232_printstr("\r\nSETUP  ");
1146   2                              SetupPacketInterruptHandler();
1147   2                              break;
1148   2      
1149   2              case VECINT_RSTR_INTERRUPT:
1150   2                              bVECINT  = 0x00;
1151   2                              bUSBSTA = USBSTA_RSTR;
1152   2                              UsbReset();
1153   2                              break;
1154   2                      
1155   2                      case VECINT_RESR_INTERRUPT:
1156   2                              bVECINT = 0x00;
1157   2                              bUSBSTA = USBSTA_RESR;
1158   2                              bSuspended = FALSE;
1159   2                              break;
1160   2                      
1161   2                      case VECINT_SUSR_INTERRUPT:
1162   2                              bVECINT = 0x00;
1163   2                              bUSBSTA = USBSTA_SUSR;
1164   2                              rs232_printstr("SUSP  ");
1165   2                              bSuspended = TRUE;
1166   2                              break;
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 20  

1167   2      
1168   2                      default:
1169   2                              bVECINT  = 0x00;
1170   2                              rs232_printhex(bVECINT);
1171   2                              break;
1172   2                      }
1173   1      
1174   1              // End of ciritical code section, reenable interrupts
1175   1          EA = ENABLE;
1176   1      }
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 21  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION usbGetConfiguration (BEGIN)
                                           ; SOURCE LINE # 173
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_0
0004 7900        R     MOV     R1,#LOW ?SC_0
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 176
0009 750000      R     MOV     wBytesRemainingOnIEP0,#00H
000C 750001      R     MOV     wBytesRemainingOnIEP0+01H,#01H
                                           ; SOURCE LINE # 177
000F 7B00              MOV     R3,#00H
0011 7A00        R     MOV     R2,#HIGH bConfigurationNumber
0013 7900        R     MOV     R1,#LOW bConfigurationNumber
0015 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetConfiguration (END)

             ; FUNCTION usbSetConfiguration (BEGIN)
                                           ; SOURCE LINE # 180
                                           ; SOURCE LINE # 181
                                           ; SOURCE LINE # 182
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_9
0004 7900        R     MOV     R1,#LOW ?SC_9
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 183
0009 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
000C E0                MOVX    A,@DPTR
000D 4408              ORL     A,#08H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 184
0010 90FF02            MOV     DPTR,#tSetupPacket+02H
0013 E0                MOVX    A,@DPTR
0014 F500        R     MOV     bConfigurationNumber,A
                                           ; SOURCE LINE # 185
0016 90FF48            MOV     DPTR,#tInputEndPointDescriptorBlock
0019 E0                MOVX    A,@DPTR
001A 4484              ORL     A,#084H
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 186
001D E4                CLR     A
001E 90FF4A            MOV     DPTR,#tInputEndPointDescriptorBlock+02H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 187
0022 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetConfiguration (END)

             ; FUNCTION usbSetReport (BEGIN)
                                           ; SOURCE LINE # 202
                                           ; SOURCE LINE # 203
                                           ; SOURCE LINE # 204
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_18
0004 7900        R     MOV     R1,#LOW ?SC_18
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 205
0009 750000      R     MOV     wBytesRemainingOnOEP0,#00H
000C 750001      R     MOV     wBytesRemainingOnOEP0+01H,#01H
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 22  

                                           ; SOURCE LINE # 206
000F 7B00              MOV     R3,#00H
0011 7AFE              MOV     R2,#0FEH
0013 79A0              MOV     R1,#0A0H
0015 020000      R     LJMP    _usbReceiveDataPacketOnEP0
             ; FUNCTION usbSetReport (END)

             ; FUNCTION OEP1InterruptHandler (BEGIN)
                                           ; SOURCE LINE # 209
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 222
0000 90FD80            MOV     DPTR,#pbOutBufferAddress
0003 E0                MOVX    A,@DPTR
0004 F4                CPL     A
0005 F580              MOV     P0,A
                                           ; SOURCE LINE # 224
0007 E4                CLR     A
0008 90FF0A            MOV     DPTR,#tOutputEndPointDescriptorBlock+02H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 226
000C 22                RET     
             ; FUNCTION OEP1InterruptHandler (END)

             ; FUNCTION usbGetDeviceDescriptor (BEGIN)
                                           ; SOURCE LINE # 232
                                           ; SOURCE LINE # 233
                                           ; SOURCE LINE # 235
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_26
0004 7900        R     MOV     R1,#LOW ?SC_26
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 237
;---- Variable 'bTemp' assigned to Register 'R7' ----
0009 E4                CLR     A
000A FF                MOV     R7,A
000B         ?C0005:
                                           ; SOURCE LINE # 238
000B EF                MOV     A,R7
000C 900000      E     MOV     DPTR,#abromDeviceDescriptor
000F 93                MOVC    A,@A+DPTR
0010 FE                MOV     R6,A
0011 7480              MOV     A,#LOW abDescriptor
0013 2F                ADD     A,R7
0014 F582              MOV     DPL,A
0016 E4                CLR     A
0017 34FE              ADDC    A,#HIGH abDescriptor
0019 F583              MOV     DPH,A
001B EE                MOV     A,R6
001C F0                MOVX    @DPTR,A
001D 0F                INC     R7
001E BF12EA            CJNE    R7,#012H,?C0005
0021         ?C0006:
                                           ; SOURCE LINE # 240
0021 E4                CLR     A
0022 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 241
0026 F500        R     MOV     wBytesRemainingOnIEP0,A
0028 750012      R     MOV     wBytesRemainingOnIEP0+01H,#012H
                                           ; SOURCE LINE # 242
002B 7B01              MOV     R3,#01H
002D 7AFE              MOV     R2,#HIGH abDescriptor
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 23  

002F 7980              MOV     R1,#LOW abDescriptor
0031 120000      R     LCALL   _usbSendDataPacketOnEP0
                                           ; SOURCE LINE # 247
0034 D200        R     SETB    deviceReady
                                           ; SOURCE LINE # 248
0036 22                RET     
             ; FUNCTION usbGetDeviceDescriptor (END)

             ; FUNCTION usbGetHIDDescriptor (BEGIN)
                                           ; SOURCE LINE # 250
                                           ; SOURCE LINE # 251
                                           ; SOURCE LINE # 254
;---- Variable 'bTemp' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
0002         ?C0009:
                                           ; SOURCE LINE # 255
0002 EF                MOV     A,R7
0003 900000      E     MOV     DPTR,#abromConfigurationDescriptorGroup+012H
0006 93                MOVC    A,@A+DPTR
0007 FE                MOV     R6,A
0008 7480              MOV     A,#LOW abDescriptor
000A 2F                ADD     A,R7
000B F582              MOV     DPL,A
000D E4                CLR     A
000E 34FE              ADDC    A,#HIGH abDescriptor
0010 F583              MOV     DPH,A
0012 EE                MOV     A,R6
0013 F0                MOVX    @DPTR,A
0014 0F                INC     R7
0015 BF12EA            CJNE    R7,#012H,?C0009
0018         ?C0010:
                                           ; SOURCE LINE # 257
0018 E4                CLR     A
0019 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 258
001D F500        R     MOV     wBytesRemainingOnIEP0,A
001F 750009      R     MOV     wBytesRemainingOnIEP0+01H,#09H
                                           ; SOURCE LINE # 259
0022 7B01              MOV     R3,#01H
0024 7AFE              MOV     R2,#HIGH abDescriptor
0026 7980              MOV     R1,#LOW abDescriptor
0028 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetHIDDescriptor (END)

             ; FUNCTION usbGetConfigurationDescriptor (BEGIN)
                                           ; SOURCE LINE # 262
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 265
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_32
0004 7900        R     MOV     R1,#LOW ?SC_32
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 267
;---- Variable 'bTemp' assigned to Register 'R7' ----
0009 E4                CLR     A
000A FF                MOV     R7,A
000B         ?C0013:
000B 900000      E     MOV     DPTR,#abromConfigurationDescriptorGroup+02H
000E E4                CLR     A
000F 93                MOVC    A,@A+DPTR
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 24  

0010 FE                MOV     R6,A
0011 EF                MOV     A,R7
0012 C3                CLR     C
0013 9E                SUBB    A,R6
0014 5015              JNC     ?C0014
                                           ; SOURCE LINE # 268
0016 EF                MOV     A,R7
0017 900000      E     MOV     DPTR,#abromConfigurationDescriptorGroup
001A 93                MOVC    A,@A+DPTR
001B FE                MOV     R6,A
001C 7480              MOV     A,#LOW abDescriptor
001E 2F                ADD     A,R7
001F F582              MOV     DPL,A
0021 E4                CLR     A
0022 34FE              ADDC    A,#HIGH abDescriptor
0024 F583              MOV     DPH,A
0026 EE                MOV     A,R6
0027 F0                MOVX    @DPTR,A
0028 0F                INC     R7
0029 80E0              SJMP    ?C0013
002B         ?C0014:
                                           ; SOURCE LINE # 269
002B E4                CLR     A
002C 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 270
0030 F500        R     MOV     wBytesRemainingOnIEP0,A
0032 750029      R     MOV     wBytesRemainingOnIEP0+01H,#029H
                                           ; SOURCE LINE # 271
0035 7B01              MOV     R3,#01H
0037 7AFE              MOV     R2,#HIGH abDescriptor
0039 7980              MOV     R1,#LOW abDescriptor
003B 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetConfigurationDescriptor (END)

             ; FUNCTION usbGetStringDescriptor (BEGIN)
                                           ; SOURCE LINE # 274
                                           ; SOURCE LINE # 275
                                           ; SOURCE LINE # 277
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_38
0004 7900        R     MOV     R1,#LOW ?SC_38
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 278
0009 90FF02            MOV     DPTR,#tSetupPacket+02H
000C E0                MOVX    A,@DPTR
000D FF                MOV     R7,A
000E 120000      E     LCALL   _rs232_printhex
                                           ; SOURCE LINE # 279
0011 7BFF              MOV     R3,#0FFH
0013 7A00        R     MOV     R2,#HIGH ?SC_42
0015 7900        R     MOV     R1,#LOW ?SC_42
0017 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 281
001A 90FF02            MOV     DPTR,#tSetupPacket+02H
001D E0                MOVX    A,@DPTR
001E 14                DEC     A
001F 6031              JZ      ?C0022
0021 14                DEC     A
0022 6054              JZ      ?C0026
0024 14                DEC     A
0025 6077              JZ      ?C0030
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 25  

0027 2403              ADD     A,#03H
0029 6003              JZ      $ + 5H
002B 020000      R     LJMP    ?C0017
                                           ; SOURCE LINE # 282
                                           ; SOURCE LINE # 283
002E         ?C0018:
                                           ; SOURCE LINE # 284
002E E4                CLR     A
002F F500        R     MOV     bTemp,A
0031         ?C0019:
0031 900000      E     MOV     DPTR,#LanguageId
0034 E4                CLR     A
0035 93                MOVC    A,@A+DPTR
0036 FF                MOV     R7,A
0037 E500        R     MOV     A,bTemp
0039 C3                CLR     C
003A 9F                SUBB    A,R7
003B 5039              JNC     ?C0115
                                           ; SOURCE LINE # 285
003D E500        R     MOV     A,bTemp
003F 93                MOVC    A,@A+DPTR
0040 FE                MOV     R6,A
0041 7480              MOV     A,#LOW abDescriptor
0043 2500        R     ADD     A,bTemp
0045 F582              MOV     DPL,A
0047 E4                CLR     A
0048 34FE              ADDC    A,#HIGH abDescriptor
004A F583              MOV     DPH,A
004C EE                MOV     A,R6
004D F0                MOVX    @DPTR,A
004E 0500        R     INC     bTemp
0050 80DF              SJMP    ?C0019
                                           ; SOURCE LINE # 289
0052         ?C0022:
                                           ; SOURCE LINE # 290
0052 E4                CLR     A
0053 F500        R     MOV     bTemp,A
0055         ?C0023:
0055 900000      E     MOV     DPTR,#ManufacturerStringDescriptor
0058 E4                CLR     A
0059 93                MOVC    A,@A+DPTR
005A FF                MOV     R7,A
005B E500        R     MOV     A,bTemp
005D C3                CLR     C
005E 9F                SUBB    A,R7
005F 5015              JNC     ?C0024
                                           ; SOURCE LINE # 291
0061 E500        R     MOV     A,bTemp
0063 93                MOVC    A,@A+DPTR
0064 FE                MOV     R6,A
0065 7480              MOV     A,#LOW abDescriptor
0067 2500        R     ADD     A,bTemp
0069 F582              MOV     DPL,A
006B E4                CLR     A
006C 34FE              ADDC    A,#HIGH abDescriptor
006E F583              MOV     DPH,A
0070 EE                MOV     A,R6
0071 F0                MOVX    @DPTR,A
0072 0500        R     INC     bTemp
0074 80DF              SJMP    ?C0023
0076         ?C0024:
                                           ; SOURCE LINE # 292
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 26  

0076         ?C0115:
                                           ; SOURCE LINE # 293
                                           ; SOURCE LINE # 294
0076 804A              SJMP    ?C0117
                                           ; SOURCE LINE # 295
0078         ?C0026:
                                           ; SOURCE LINE # 296
0078 E4                CLR     A
0079 F500        R     MOV     bTemp,A
007B         ?C0027:
007B 900000      E     MOV     DPTR,#ProductStringDescriptor
007E E4                CLR     A
007F 93                MOVC    A,@A+DPTR
0080 FF                MOV     R7,A
0081 E500        R     MOV     A,bTemp
0083 C3                CLR     C
0084 9F                SUBB    A,R7
0085 5015              JNC     ?C0028
                                           ; SOURCE LINE # 297
0087 E500        R     MOV     A,bTemp
0089 93                MOVC    A,@A+DPTR
008A FE                MOV     R6,A
008B 7480              MOV     A,#LOW abDescriptor
008D 2500        R     ADD     A,bTemp
008F F582              MOV     DPL,A
0091 E4                CLR     A
0092 34FE              ADDC    A,#HIGH abDescriptor
0094 F583              MOV     DPH,A
0096 EE                MOV     A,R6
0097 F0                MOVX    @DPTR,A
0098 0500        R     INC     bTemp
009A 80DF              SJMP    ?C0027
009C         ?C0028:
                                           ; SOURCE LINE # 298
009C         ?C0116:
                                           ; SOURCE LINE # 299
                                           ; SOURCE LINE # 300
009C 8024              SJMP    ?C0117
                                           ; SOURCE LINE # 301
009E         ?C0030:
                                           ; SOURCE LINE # 302
009E E4                CLR     A
009F F500        R     MOV     bTemp,A
00A1         ?C0031:
00A1 900000      E     MOV     DPTR,#SerialNumberStringDescriptor
00A4 E4                CLR     A
00A5 93                MOVC    A,@A+DPTR
00A6 FF                MOV     R7,A
00A7 E500        R     MOV     A,bTemp
00A9 C3                CLR     C
00AA 9F                SUBB    A,R7
00AB 5015              JNC     ?C0032
                                           ; SOURCE LINE # 303
00AD E500        R     MOV     A,bTemp
00AF 93                MOVC    A,@A+DPTR
00B0 FE                MOV     R6,A
00B1 7480              MOV     A,#LOW abDescriptor
00B3 2500        R     ADD     A,bTemp
00B5 F582              MOV     DPL,A
00B7 E4                CLR     A
00B8 34FE              ADDC    A,#HIGH abDescriptor
00BA F583              MOV     DPH,A
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 27  

00BC EE                MOV     A,R6
00BD F0                MOVX    @DPTR,A
00BE 0500        R     INC     bTemp
00C0 80DF              SJMP    ?C0031
00C2         ?C0032:
                                           ; SOURCE LINE # 304
00C2         ?C0117:
00C2 E4                CLR     A
00C3 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
00C6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 305
00C7 F500        R     MOV     wBytesRemainingOnIEP0,A
00C9 8F00        R     MOV     wBytesRemainingOnIEP0+01H,R7
                                           ; SOURCE LINE # 306
                                           ; SOURCE LINE # 307
00CB         ?C0017:
                                           ; SOURCE LINE # 308
00CB 7B01              MOV     R3,#01H
00CD 7AFE              MOV     R2,#HIGH abDescriptor
00CF 7980              MOV     R1,#LOW abDescriptor
00D1 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetStringDescriptor (END)

             ; FUNCTION usbGetReportDescriptor (BEGIN)
                                           ; SOURCE LINE # 311
                                           ; SOURCE LINE # 312
                                           ; SOURCE LINE # 313
0000 E4                CLR     A
0001 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 314
0005 7BFF              MOV     R3,#0FFH
0007 7A00        R     MOV     R2,#HIGH ?SC_45
0009 7900        R     MOV     R1,#LOW ?SC_45
000B 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 315
000E 750000      R     MOV     wBytesRemainingOnIEP0,#00H
0011 75001B      R     MOV     wBytesRemainingOnIEP0+01H,#01BH
                                           ; SOURCE LINE # 316
0014 7BFF              MOV     R3,#0FFH
0016 7A00        E     MOV     R2,#HIGH abromReportDescriptor
0018 7900        E     MOV     R1,#LOW abromReportDescriptor
001A 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetReportDescriptor (END)

             ; FUNCTION usbSetIdle (BEGIN)
                                           ; SOURCE LINE # 328
                                           ; SOURCE LINE # 329
                                           ; SOURCE LINE # 331
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_52
0004 7900        R     MOV     R1,#LOW ?SC_52
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 332
0009 90FF02            MOV     DPTR,#tSetupPacket+02H
000C E0                MOVX    A,@DPTR
000D F500        R     MOV     gbIdleRateL,A
                                           ; SOURCE LINE # 333
000F A3                INC     DPTR
0010 E0                MOVX    A,@DPTR
0011 F500        R     MOV     gbIdleRateH,A
                                           ; SOURCE LINE # 334
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 28  

0013 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetIdle (END)

             ; FUNCTION usbGetIdle (BEGIN)
                                           ; SOURCE LINE # 337
                                           ; SOURCE LINE # 338
                                           ; SOURCE LINE # 339
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_62
0004 7900        R     MOV     R1,#LOW ?SC_62
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 340
0009 750000      R     MOV     wBytesRemainingOnIEP0,#00H
000C 750001      R     MOV     wBytesRemainingOnIEP0+01H,#01H
                                           ; SOURCE LINE # 341
000F 7B00              MOV     R3,#00H
0011 7A00        R     MOV     R2,#HIGH gbIdleRateH
0013 7900        R     MOV     R1,#LOW gbIdleRateH
0015 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetIdle (END)

             ; FUNCTION usbSetProtocol (BEGIN)
                                           ; SOURCE LINE # 345
                                           ; SOURCE LINE # 346
                                           ; SOURCE LINE # 348
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_72
0004 7900        R     MOV     R1,#LOW ?SC_72
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 349
0009 90FF02            MOV     DPTR,#tSetupPacket+02H
000C E0                MOVX    A,@DPTR
000D F500        R     MOV     gbProtocol,A
                                           ; SOURCE LINE # 350
000F 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetProtocol (END)

             ; FUNCTION usbGetProtocol (BEGIN)
                                           ; SOURCE LINE # 353
                                           ; SOURCE LINE # 354
                                           ; SOURCE LINE # 355
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_87
0004 7900        R     MOV     R1,#LOW ?SC_87
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 356
0009 750000      R     MOV     wBytesRemainingOnIEP0,#00H
000C 750001      R     MOV     wBytesRemainingOnIEP0+01H,#01H
                                           ; SOURCE LINE # 357
000F 7B00              MOV     R3,#00H
0011 7A00        R     MOV     R2,#HIGH gbProtocol
0013 7900        R     MOV     R1,#LOW gbProtocol
0015 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetProtocol (END)

             ; FUNCTION usbGetInterface (BEGIN)
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 367
                                           ; SOURCE LINE # 368
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_102
0004 7900        R     MOV     R1,#LOW ?SC_102
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 29  

0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 369
0009 750000      R     MOV     wBytesRemainingOnIEP0,#00H
000C 750001      R     MOV     wBytesRemainingOnIEP0+01H,#01H
                                           ; SOURCE LINE # 370
000F 7B00              MOV     R3,#00H
0011 7A00        R     MOV     R2,#HIGH bInterfaceNumber
0013 7900        R     MOV     R1,#LOW bInterfaceNumber
0015 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetInterface (END)

             ; FUNCTION usbSetInterface (BEGIN)
                                           ; SOURCE LINE # 373
                                           ; SOURCE LINE # 374
                                           ; SOURCE LINE # 375
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_118
0004 7900        R     MOV     R1,#LOW ?SC_118
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 376
0009 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
000C E0                MOVX    A,@DPTR
000D 4408              ORL     A,#08H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 377
0010 90FF04            MOV     DPTR,#tSetupPacket+04H
0013 E0                MOVX    A,@DPTR
0014 F500        R     MOV     bInterfaceNumber,A
                                           ; SOURCE LINE # 378
0016 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetInterface (END)

             ; FUNCTION usbGetDeviceStatus (BEGIN)
                                           ; SOURCE LINE # 387
                                           ; SOURCE LINE # 388
                                           ; SOURCE LINE # 389
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_134
0004 7900        R     MOV     R1,#LOW ?SC_134
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 390
0009 750000      R     MOV     wBytesRemainingOnIEP0,#00H
000C 750002      R     MOV     wBytesRemainingOnIEP0+01H,#02H
                                           ; SOURCE LINE # 391
000F 7B00              MOV     R3,#00H
0011 7A00        R     MOV     R2,#HIGH wDeviceFeatures
0013 7900        R     MOV     R1,#LOW wDeviceFeatures
0015 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetDeviceStatus (END)

             ; FUNCTION usbSetRemoteWakeup (BEGIN)
                                           ; SOURCE LINE # 394
                                           ; SOURCE LINE # 395
                                           ; SOURCE LINE # 396
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_147
0004 7900        R     MOV     R1,#LOW ?SC_147
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 397
0009 90FFFC            MOV     DPTR,#0FFFCH
000C E0                MOVX    A,@DPTR
000D 4408              ORL     A,#08H
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 30  

000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 398
0010 430002      R     ORL     wDeviceFeatures,#02H
                                           ; SOURCE LINE # 399
0013 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
0016 E0                MOVX    A,@DPTR
0017 4408              ORL     A,#08H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 400
001A 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetRemoteWakeup (END)

             ; FUNCTION usbClearRemoteWakeup (BEGIN)
                                           ; SOURCE LINE # 403
                                           ; SOURCE LINE # 404
                                           ; SOURCE LINE # 405
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_159
0004 7900        R     MOV     R1,#LOW ?SC_159
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 406
0009 90FFFC            MOV     DPTR,#0FFFCH
000C E0                MOVX    A,@DPTR
000D 54F7              ANL     A,#0F7H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 407
0010 5300FD      R     ANL     wDeviceFeatures,#0FDH
                                           ; SOURCE LINE # 408
0013 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
0016 E0                MOVX    A,@DPTR
0017 4408              ORL     A,#08H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 409
001A 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbClearRemoteWakeup (END)

             ; FUNCTION usbGetInterfaceStatus (BEGIN)
                                           ; SOURCE LINE # 414
                                           ; SOURCE LINE # 415
                                           ; SOURCE LINE # 416
0000 E4                CLR     A
0001 F500        R     MOV     wStatusBuffer,A
0003 F500        R     MOV     wStatusBuffer+01H,A
                                           ; SOURCE LINE # 417
0005 7BFF              MOV     R3,#0FFH
0007 7A00        R     MOV     R2,#HIGH ?SC_171
0009 7900        R     MOV     R1,#LOW ?SC_171
000B 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 418
000E 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
0011 E0                MOVX    A,@DPTR
0012 4408              ORL     A,#08H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 419
0015 750000      R     MOV     wBytesRemainingOnIEP0,#00H
0018 750002      R     MOV     wBytesRemainingOnIEP0+01H,#02H
                                           ; SOURCE LINE # 420
001B 7B00              MOV     R3,#00H
001D 7A00        R     MOV     R2,#HIGH wStatusBuffer
001F 7900        R     MOV     R1,#LOW wStatusBuffer
0021 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetInterfaceStatus (END)
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 31  


             ; FUNCTION usbSetAddress (BEGIN)
                                           ; SOURCE LINE # 428
                                           ; SOURCE LINE # 429
                                           ; SOURCE LINE # 430
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_183
0004 7900        R     MOV     R1,#LOW ?SC_183
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 431
0009 90FF02            MOV     DPTR,#tSetupPacket+02H
000C E0                MOVX    A,@DPTR
000D FF                MOV     R7,A
000E 120000      E     LCALL   _rs232_printhex
                                           ; SOURCE LINE # 432
0011 7BFF              MOV     R3,#0FFH
0013 7A00        R     MOV     R2,#HIGH ?SC_42
0015 7900        R     MOV     R1,#LOW ?SC_42
0017 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 433
001A 90FF02            MOV     DPTR,#tSetupPacket+02H
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F C3                CLR     C
0020 9480              SUBB    A,#080H
0022 500D              JNC     ?C0046
                                           ; SOURCE LINE # 434
                                           ; SOURCE LINE # 435
0024 90FFFF            MOV     DPTR,#0FFFFH
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 436
0029 F500        R     MOV     bUsbDeviceAddress,A
                                           ; SOURCE LINE # 437
002B 750003      R     MOV     bStatusAction,#03H
                                           ; SOURCE LINE # 438
002E 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
                                           ; SOURCE LINE # 439
0031         ?C0046:
                                           ; SOURCE LINE # 441
0031 120000      R     LCALL   usbStallEndpoint0
                                           ; SOURCE LINE # 442
0034         ?C0048:
0034 22                RET     
             ; FUNCTION usbSetAddress (END)

             ; FUNCTION usbSetEndpointHalt (BEGIN)
                                           ; SOURCE LINE # 451
                                           ; SOURCE LINE # 452
                                           ; SOURCE LINE # 453
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_192
0004 7900        R     MOV     R1,#LOW ?SC_192
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 454
0009 90FF48            MOV     DPTR,#tInputEndPointDescriptorBlock
000C E0                MOVX    A,@DPTR
000D 547F              ANL     A,#07FH
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 455
0010 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetEndpointHalt (END)
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 32  


             ; FUNCTION usbClearEndpointHalt (BEGIN)
                                           ; SOURCE LINE # 458
                                           ; SOURCE LINE # 459
                                           ; SOURCE LINE # 460
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_204
0004 7900        R     MOV     R1,#LOW ?SC_204
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 461
0009 90FF48            MOV     DPTR,#tInputEndPointDescriptorBlock
000C E0                MOVX    A,@DPTR
000D 4480              ORL     A,#080H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 462
0010 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbClearEndpointHalt (END)

             ; FUNCTION usbGetEndpointStatus (BEGIN)
                                           ; SOURCE LINE # 465
                                           ; SOURCE LINE # 466
                                           ; SOURCE LINE # 467
0000 750001      R     MOV     wEndpointStatus,#01H
0003 750000      R     MOV     wEndpointStatus+01H,#00H
                                           ; SOURCE LINE # 468
0006 7BFF              MOV     R3,#0FFH
0008 7A00        R     MOV     R2,#HIGH ?SC_216
000A 7900        R     MOV     R1,#LOW ?SC_216
000C 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 469
000F 90FF48            MOV     DPTR,#tInputEndPointDescriptorBlock
0012 E0                MOVX    A,@DPTR
0013 30E705            JNB     ACC.7,?C0051
                                           ; SOURCE LINE # 470
0016 E4                CLR     A
0017 F500        R     MOV     wEndpointStatus,A
0019 F500        R     MOV     wEndpointStatus+01H,A
001B         ?C0051:
                                           ; SOURCE LINE # 472
001B 750000      R     MOV     wBytesRemainingOnIEP0,#00H
001E 750002      R     MOV     wBytesRemainingOnIEP0+01H,#02H
                                           ; SOURCE LINE # 473
0021 7B00              MOV     R3,#00H
0023 7A00        R     MOV     R2,#HIGH wEndpointStatus
0025 7900        R     MOV     R1,#LOW wEndpointStatus
0027 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetEndpointStatus (END)

             ; FUNCTION usbNonStandardRequest (BEGIN)
                                           ; SOURCE LINE # 480
                                           ; SOURCE LINE # 481
                                           ; SOURCE LINE # 482
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_227
0004 7900        R     MOV     R1,#LOW ?SC_227
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 483
0009 020000      R     LJMP    usbStallEndpoint0
             ; FUNCTION usbNonStandardRequest (END)

             ; FUNCTION usbDecodeAndProcessUsbRequest (BEGIN)
                                           ; SOURCE LINE # 734
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 33  

                                           ; SOURCE LINE # 735
                                           ; SOURCE LINE # 752
0000 7500FF      R     MOV     pbUsbRequestList,#0FFH
0003 750000      R     MOV     pbUsbRequestList+01H,#HIGH tUsbRequestList
0006 750000      R     MOV     pbUsbRequestList+02H,#LOW tUsbRequestList
0009         ?C0054:
                                           ; SOURCE LINE # 757
                                           ; SOURCE LINE # 758
                                           ; SOURCE LINE # 759
0009 E4                CLR     A
000A F500        R     MOV     bResult,A
                                           ; SOURCE LINE # 760
;---- Variable 'bMask' assigned to Register 'R7' ----
000C 7F80              MOV     R7,#080H
                                           ; SOURCE LINE # 767
;---- Variable 'bTemp' assigned to Register 'R6' ----
000E FE                MOV     R6,A
000F         ?C0056:
                                           ; SOURCE LINE # 768
                                           ; SOURCE LINE # 769
000F AB00        R     MOV     R3,pbUsbRequestList
0011 AA00        R     MOV     R2,pbUsbRequestList+01H
0013 A900        R     MOV     R1,pbUsbRequestList+02H
0015 8E82              MOV     DPL,R6
0017 758300            MOV     DPH,#00H
001A 120000      E     LCALL   ?C?CLDOPTR
001D FD                MOV     R5,A
001E E4                CLR     A
001F 2E                ADD     A,R6
0020 F582              MOV     DPL,A
0022 E4                CLR     A
0023 34FF              ADDC    A,#0FFH
0025 F583              MOV     DPH,A
0027 E0                MOVX    A,@DPTR
0028 B50503            CJNE    A,AR5,?C0059
                                           ; SOURCE LINE # 770
002B EF                MOV     A,R7
002C 4200        R     ORL     bResult,A
002E         ?C0059:
                                           ; SOURCE LINE # 771
002E EF                MOV     A,R7
002F C3                CLR     C
0030 13                RRC     A
0031 FF                MOV     R7,A
                                           ; SOURCE LINE # 772
0032 0E                INC     R6
0033 BE08D9            CJNE    R6,#08H,?C0056
0036         ?C0057:
                                           ; SOURCE LINE # 782
0036 AB00        R     MOV     R3,pbUsbRequestList
0038 AA00        R     MOV     R2,pbUsbRequestList+01H
003A A900        R     MOV     R1,pbUsbRequestList+02H
003C 8E82              MOV     DPL,R6
003E 758300            MOV     DPH,#00H
0041 120000      E     LCALL   ?C?CLDOPTR
0044 FF                MOV     R7,A
0045 5500        R     ANL     A,bResult
0047 6F                XRL     A,R7
0048 600D              JZ      ?C0055
                                           ; SOURCE LINE # 783
004A         ?C0060:
                                           ; SOURCE LINE # 787
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 34  

004A 740C              MOV     A,#0CH
004C 2500        R     ADD     A,pbUsbRequestList+02H
004E F500        R     MOV     pbUsbRequestList+02H,A
0050 E4                CLR     A
0051 3500        R     ADDC    A,pbUsbRequestList+01H
0053 F500        R     MOV     pbUsbRequestList+01H,A
                                           ; SOURCE LINE # 788
0055 80B2              SJMP    ?C0054
0057         ?C0055:
                                           ; SOURCE LINE # 792
0057 90FFFE            MOV     DPTR,#0FFFEH
005A E0                MOVX    A,@DPTR
005B 20E00F            JB      ACC.0,?C0062
005E         ?C0061:
                                           ; SOURCE LINE # 797
005E AB00        R     MOV     R3,pbUsbRequestList
0060 AA00        R     MOV     R2,pbUsbRequestList+01H
0062 A900        R     MOV     R1,pbUsbRequestList+02H
0064 900009            MOV     DPTR,#09H
0067 120000      E     LCALL   ?C?PLDOPTR
006A 120000      E     LCALL   ?C?ICALL
                                           ; SOURCE LINE # 798
006D         ?C0062:
006D 22                RET     
             ; FUNCTION usbDecodeAndProcessUsbRequest (END)

             ; FUNCTION usbStallEndpoint0 (BEGIN)
                                           ; SOURCE LINE # 807
                                           ; SOURCE LINE # 808
                                           ; SOURCE LINE # 809
0000 90FF80            MOV     DPTR,#tEndPoint0DescriptorBlock
0003 E0                MOVX    A,@DPTR
0004 4408              ORL     A,#08H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 810
0007 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
000A E0                MOVX    A,@DPTR
000B 4408              ORL     A,#08H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 811
000E 22                RET     
             ; FUNCTION usbStallEndpoint0 (END)

             ; FUNCTION _usbReceiveDataPacketOnEP0 (BEGIN)
                                           ; SOURCE LINE # 825
;---- Variable 'pbBuffer' assigned to Register 'R1/R2/R3' ----
                                           ; SOURCE LINE # 826
                                           ; SOURCE LINE # 827
0000 8B00        R     MOV     pbOEP0Buffer,R3
0002 8A00        R     MOV     pbOEP0Buffer+01H,R2
0004 8900        R     MOV     pbOEP0Buffer+02H,R1
                                           ; SOURCE LINE # 828
0006 90FF07            MOV     DPTR,#tSetupPacket+07H
0009 E0                MOVX    A,@DPTR
000A FE                MOV     R6,A
000B 90FF06            MOV     DPTR,#tSetupPacket+06H
000E E0                MOVX    A,@DPTR
000F FD                MOV     R5,A
0010 EE                MOV     A,R6
0011 F500        R     MOV     wBytesRemainingOnOEP0,A
0013 ED                MOV     A,R5
0014 F500        R     MOV     wBytesRemainingOnOEP0+01H,A
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 35  

                                           ; SOURCE LINE # 829
0016 750002      R     MOV     bStatusAction,#02H
                                           ; SOURCE LINE # 830
0019 E4                CLR     A
001A 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 831
001E 22                RET     
             ; FUNCTION _usbReceiveDataPacketOnEP0 (END)

             ; FUNCTION usbReceiveNextPacketOnOEP0 (BEGIN)
                                           ; SOURCE LINE # 833
                                           ; SOURCE LINE # 834
                                           ; SOURCE LINE # 840
0000 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0003 E0                MOVX    A,@DPTR
0004 547F              ANL     A,#07FH
0006 FF                MOV     R7,A
;---- Variable 'bByte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 847
0007 FD                MOV     R5,A
0008 C3                CLR     C
0009 E500        R     MOV     A,wBytesRemainingOnOEP0+01H
000B 9D                SUBB    A,R5
000C E500        R     MOV     A,wBytesRemainingOnOEP0
000E 9400              SUBB    A,#00H
0010 4055              JC      ?C0065
                                           ; SOURCE LINE # 848
                                           ; SOURCE LINE # 851
;---- Variable 'bIndex' assigned to Register 'R6' ----
0012 E4                CLR     A
0013 FE                MOV     R6,A
0014         ?C0066:
0014 EE                MOV     A,R6
0015 C3                CLR     C
0016 9F                SUBB    A,R7
0017 5021              JNC     ?C0067
                                           ; SOURCE LINE # 852
0019 74F0              MOV     A,#LOW abOEP0Buffer
001B 2E                ADD     A,R6
001C F582              MOV     DPL,A
001E E4                CLR     A
001F 34FE              ADDC    A,#HIGH abOEP0Buffer
0021 F583              MOV     DPH,A
0023 E0                MOVX    A,@DPTR
0024 FD                MOV     R5,A
0025 AB00        R     MOV     R3,pbOEP0Buffer
0027 0500        R     INC     pbOEP0Buffer+02H
0029 E500        R     MOV     A,pbOEP0Buffer+02H
002B AA00        R     MOV     R2,pbOEP0Buffer+01H
002D 7002              JNZ     ?C0112
002F 0500        R     INC     pbOEP0Buffer+01H
0031         ?C0112:
0031 14                DEC     A
0032 F9                MOV     R1,A
0033 ED                MOV     A,R5
0034 120000      E     LCALL   ?C?CSTPTR
0037 0E                INC     R6
0038 80DA              SJMP    ?C0066
003A         ?C0067:
                                           ; SOURCE LINE # 856
003A C3                CLR     C
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 36  

003B E500        R     MOV     A,wBytesRemainingOnOEP0+01H
003D 9F                SUBB    A,R7
003E F500        R     MOV     wBytesRemainingOnOEP0+01H,A
0040 E500        R     MOV     A,wBytesRemainingOnOEP0
0042 9400              SUBB    A,#00H
0044 F500        R     MOV     wBytesRemainingOnOEP0,A
                                           ; SOURCE LINE # 862
0046 D3                SETB    C
0047 E500        R     MOV     A,wBytesRemainingOnOEP0+01H
0049 9400              SUBB    A,#00H
004B E500        R     MOV     A,wBytesRemainingOnOEP0
004D 9400              SUBB    A,#00H
004F 4009              JC      ?C0069
                                           ; SOURCE LINE # 863
                                           ; SOURCE LINE # 864
0051 E4                CLR     A
0052 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 865
0056 750002      R     MOV     bStatusAction,#02H
                                           ; SOURCE LINE # 866
0059 22                RET     
005A         ?C0069:
                                           ; SOURCE LINE # 868
                                           ; SOURCE LINE # 877
005A 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
005D E0                MOVX    A,@DPTR
005E 4408              ORL     A,#08H
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 878
0061 E4                CLR     A
0062 F500        R     MOV     bStatusAction,A
                                           ; SOURCE LINE # 879
0064 020000      E     LJMP    OEP0SetLEDs
                                           ; SOURCE LINE # 880
                                           ; SOURCE LINE # 881
0067         ?C0065:
                                           ; SOURCE LINE # 883
                                           ; SOURCE LINE # 887
0067 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
006A E0                MOVX    A,@DPTR
006B 4408              ORL     A,#08H
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 888
006E E4                CLR     A
006F F500        R     MOV     bStatusAction,A
                                           ; SOURCE LINE # 889
                                           ; SOURCE LINE # 890
0071         ?C0072:
0071 22                RET     
             ; FUNCTION usbReceiveNextPacketOnOEP0 (END)

             ; FUNCTION usbSendZeroLengthPacketOnIEP0 (BEGIN)
                                           ; SOURCE LINE # 900
                                           ; SOURCE LINE # 901
                                           ; SOURCE LINE # 902
0000 74FF              MOV     A,#0FFH
0002 F500        R     MOV     wBytesRemainingOnIEP0,A
0004 F500        R     MOV     wBytesRemainingOnIEP0+01H,A
                                           ; SOURCE LINE # 903
0006 E4                CLR     A
0007 F500        R     MOV     bStatusAction,A
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 37  

                                           ; SOURCE LINE # 904
0009 90FF81            MOV     DPTR,#tEndPoint0DescriptorBlock+01H
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 905
000D 22                RET     
             ; FUNCTION usbSendZeroLengthPacketOnIEP0 (END)

             ; FUNCTION _usbSendDataPacketOnEP0 (BEGIN)
                                           ; SOURCE LINE # 920
;---- Variable 'pbBuffer' assigned to Register 'R1/R2/R3' ----
                                           ; SOURCE LINE # 921
                                           ; SOURCE LINE # 924
0000 8B00        R     MOV     pbIEP0Buffer,R3
0002 8A00        R     MOV     pbIEP0Buffer+01H,R2
0004 8900        R     MOV     pbIEP0Buffer+02H,R1
                                           ; SOURCE LINE # 926
0006 90FF07            MOV     DPTR,#tSetupPacket+07H
0009 E0                MOVX    A,@DPTR
000A FE                MOV     R6,A
000B 90FF06            MOV     DPTR,#tSetupPacket+06H
000E E0                MOVX    A,@DPTR
000F FD                MOV     R5,A
0010 ED                MOV     A,R5
0011 FF                MOV     R7,A
;---- Variable 'wTemp' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 930
0012 C3                CLR     C
0013 E500        R     MOV     A,wBytesRemainingOnIEP0+01H
0015 9F                SUBB    A,R7
0016 E500        R     MOV     A,wBytesRemainingOnIEP0
0018 9E                SUBB    A,R6
0019 4008              JC      ?C0074
                                           ; SOURCE LINE # 931
                                           ; SOURCE LINE # 932
001B 8E00        R     MOV     wBytesRemainingOnIEP0,R6
001D 8F00        R     MOV     wBytesRemainingOnIEP0+01H,R7
                                           ; SOURCE LINE # 933
001F C200        R     CLR     bHostAskMoreDataThanAvailable
                                           ; SOURCE LINE # 934
0021 8002              SJMP    ?C0075
0023         ?C0074:
                                           ; SOURCE LINE # 936
                                           ; SOURCE LINE # 937
0023 D200        R     SETB    bHostAskMoreDataThanAvailable
                                           ; SOURCE LINE # 938
0025         ?C0075:
                                           ; SOURCE LINE # 940
0025 020000      R     LJMP    usbSendNextPacketOnIEP0
             ; FUNCTION _usbSendDataPacketOnEP0 (END)

             ; FUNCTION usbSendNextPacketOnIEP0 (BEGIN)
                                           ; SOURCE LINE # 943
;---- Variable 'bPacketSize' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 944
                                           ; SOURCE LINE # 948
0000 E500        R     MOV     A,wBytesRemainingOnIEP0+01H
0002 F4                CPL     A
0003 7003              JNZ     ?C0113
0005 E500        R     MOV     A,wBytesRemainingOnIEP0
0007 F4                CPL     A
0008         ?C0113:
0008 6070              JZ      ?C0077
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 38  

                                           ; SOURCE LINE # 949
                                           ; SOURCE LINE # 950
000A D3                SETB    C
000B E500        R     MOV     A,wBytesRemainingOnIEP0+01H
000D 9408              SUBB    A,#08H
000F E500        R     MOV     A,wBytesRemainingOnIEP0
0011 9400              SUBB    A,#00H
0013 4010              JC      ?C0078
                                           ; SOURCE LINE # 951
                                           ; SOURCE LINE # 954
0015 7F08              MOV     R7,#08H
                                           ; SOURCE LINE # 955
0017 74F8              MOV     A,#0F8H
0019 2500        R     ADD     A,wBytesRemainingOnIEP0+01H
001B F500        R     MOV     wBytesRemainingOnIEP0+01H,A
001D 74FF              MOV     A,#0FFH
001F 3500        R     ADDC    A,wBytesRemainingOnIEP0
0021 F500        R     MOV     wBytesRemainingOnIEP0,A
                                           ; SOURCE LINE # 956
                                           ; SOURCE LINE # 957
0023 8019              SJMP    ?C0118
0025         ?C0078:
                                           ; SOURCE LINE # 958
0025 C3                CLR     C
0026 E500        R     MOV     A,wBytesRemainingOnIEP0+01H
0028 9408              SUBB    A,#08H
002A E500        R     MOV     A,wBytesRemainingOnIEP0
002C 9400              SUBB    A,#00H
002E 5004              JNC     ?C0080
                                           ; SOURCE LINE # 959
                                           ; SOURCE LINE # 962
0030 AF00        R     MOV     R7,wBytesRemainingOnIEP0+01H
                                           ; SOURCE LINE # 963
                                           ; SOURCE LINE # 964
                                           ; SOURCE LINE # 965
0032 800F              SJMP    ?C0119
0034         ?C0080:
                                           ; SOURCE LINE # 967
                                           ; SOURCE LINE # 969
0034 7F08              MOV     R7,#08H
                                           ; SOURCE LINE # 970
0036 30000A      R     JNB     bHostAskMoreDataThanAvailable,?C0082
                                           ; SOURCE LINE # 971
                                           ; SOURCE LINE # 972
0039 E4                CLR     A
003A F500        R     MOV     wBytesRemainingOnIEP0,A
003C F500        R     MOV     wBytesRemainingOnIEP0+01H,A
                                           ; SOURCE LINE # 973
003E         ?C0118:
003E 750001      R     MOV     bStatusAction,#01H
                                           ; SOURCE LINE # 974
0041 8009              SJMP    ?C0079
0043         ?C0082:
                                           ; SOURCE LINE # 976
                                           ; SOURCE LINE # 977
0043         ?C0119:
0043 74FF              MOV     A,#0FFH
0045 F500        R     MOV     wBytesRemainingOnIEP0,A
0047 F500        R     MOV     wBytesRemainingOnIEP0+01H,A
                                           ; SOURCE LINE # 978
0049 E4                CLR     A
004A F500        R     MOV     bStatusAction,A
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 39  

                                           ; SOURCE LINE # 979
                                           ; SOURCE LINE # 980
004C         ?C0079:
                                           ; SOURCE LINE # 982
;---- Variable 'bIndex' assigned to Register 'R6' ----
004C E4                CLR     A
004D FE                MOV     R6,A
004E         ?C0084:
004E EE                MOV     A,R6
004F C3                CLR     C
0050 9F                SUBB    A,R7
0051 5021              JNC     ?C0085
                                           ; SOURCE LINE # 983
0053 AB00        R     MOV     R3,pbIEP0Buffer
0055 0500        R     INC     pbIEP0Buffer+02H
0057 E500        R     MOV     A,pbIEP0Buffer+02H
0059 AA00        R     MOV     R2,pbIEP0Buffer+01H
005B 7002              JNZ     ?C0114
005D 0500        R     INC     pbIEP0Buffer+01H
005F         ?C0114:
005F 14                DEC     A
0060 F9                MOV     R1,A
0061 120000      E     LCALL   ?C?CLDPTR
0064 FD                MOV     R5,A
0065 74F8              MOV     A,#LOW abIEP0Buffer
0067 2E                ADD     A,R6
0068 F582              MOV     DPL,A
006A E4                CLR     A
006B 34FE              ADDC    A,#HIGH abIEP0Buffer
006D F583              MOV     DPH,A
006F ED                MOV     A,R5
0070 F0                MOVX    @DPTR,A
0071 0E                INC     R6
0072 80DA              SJMP    ?C0084
0074         ?C0085:
                                           ; SOURCE LINE # 985
0074 90FF81            MOV     DPTR,#tEndPoint0DescriptorBlock+01H
0077 EF                MOV     A,R7
0078 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 986
0079 22                RET     
007A         ?C0077:
                                           ; SOURCE LINE # 988
                                           ; SOURCE LINE # 989
007A E4                CLR     A
007B F500        R     MOV     bStatusAction,A
                                           ; SOURCE LINE # 990
                                           ; SOURCE LINE # 991
007D         ?C0088:
007D 22                RET     
             ; FUNCTION usbSendNextPacketOnIEP0 (END)

             ; FUNCTION SetupPacketInterruptHandler (BEGIN)
                                           ; SOURCE LINE # 1004
                                           ; SOURCE LINE # 1005
                                           ; SOURCE LINE # 1008
0000 90FF81            MOV     DPTR,#tEndPoint0DescriptorBlock+01H
0003 7480              MOV     A,#080H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1009
0006 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0009 F0                MOVX    @DPTR,A
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 40  

                                           ; SOURCE LINE # 1011
000A 90FFFE            MOV     DPTR,#0FFFEH
000D 7404              MOV     A,#04H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1015
0010 90FF00            MOV     DPTR,#tSetupPacket
0013 E0                MOVX    A,@DPTR
0014 90FFFC            MOV     DPTR,#0FFFCH
0017 30E706            JNB     ACC.7,?C0089
                                           ; SOURCE LINE # 1016
001A E0                MOVX    A,@DPTR
001B 4401              ORL     A,#01H
001D F0                MOVX    @DPTR,A
001E 8004              SJMP    ?C0090
0020         ?C0089:
                                           ; SOURCE LINE # 1018
0020 E0                MOVX    A,@DPTR
0021 54FE              ANL     A,#0FEH
0023 F0                MOVX    @DPTR,A
0024         ?C0090:
                                           ; SOURCE LINE # 1023
0024 E4                CLR     A
0025 F500        R     MOV     bStatusAction,A
                                           ; SOURCE LINE # 1027
0027 020000      R     LJMP    usbDecodeAndProcessUsbRequest
             ; FUNCTION SetupPacketInterruptHandler (END)

             ; FUNCTION OEP0InterruptHandler (BEGIN)
                                           ; SOURCE LINE # 1039
                                           ; SOURCE LINE # 1040
                                           ; SOURCE LINE # 1042
0000 E4                CLR     A
0001 90FF81            MOV     DPTR,#tEndPoint0DescriptorBlock+01H
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1043
0005 7BFF              MOV     R3,#0FFH
0007 7A00        R     MOV     R2,#HIGH ?SC_244
0009 7900        R     MOV     R1,#LOW ?SC_244
000B 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1044
000E 90FEF0            MOV     DPTR,#abOEP0Buffer
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 120000      E     LCALL   _rs232_printhex
                                           ; SOURCE LINE # 1045
0016 7BFF              MOV     R3,#0FFH
0018 7A00        R     MOV     R2,#HIGH ?SC_42
001A 7900        R     MOV     R1,#LOW ?SC_42
001C 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1052
001F E500        R     MOV     A,bStatusAction
0021 B40203            CJNE    A,#02H,?C0092
                                           ; SOURCE LINE # 1053
0024 020000      R     LJMP    usbReceiveNextPacketOnOEP0
0027         ?C0092:
                                           ; SOURCE LINE # 1055
0027 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
002A E0                MOVX    A,@DPTR
002B 4408              ORL     A,#08H
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1056
002E         ?C0094:
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 41  

002E 22                RET     
             ; FUNCTION OEP0InterruptHandler (END)

             ; FUNCTION IEP0InterruptHandler (BEGIN)
                                           ; SOURCE LINE # 1072
                                           ; SOURCE LINE # 1073
                                           ; SOURCE LINE # 1075
0000 E4                CLR     A
0001 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1083
0005 E500        R     MOV     A,bStatusAction
0007 B40103            CJNE    A,#01H,?C0095
                                           ; SOURCE LINE # 1084
000A 020000      R     LJMP    usbSendNextPacketOnIEP0
000D         ?C0095:
                                           ; SOURCE LINE # 1085
000D E500        R     MOV     A,bStatusAction
000F B40307            CJNE    A,#03H,?C0097
                                           ; SOURCE LINE # 1086
0012 90FFFF            MOV     DPTR,#0FFFFH
0015 E500        R     MOV     A,bUsbDeviceAddress
0017 F0                MOVX    @DPTR,A
0018 22                RET     
0019         ?C0097:
                                           ; SOURCE LINE # 1088
0019 90FF80            MOV     DPTR,#tEndPoint0DescriptorBlock
001C E0                MOVX    A,@DPTR
001D 4408              ORL     A,#08H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1089
0020         ?C0099:
0020 22                RET     
             ; FUNCTION IEP0InterruptHandler (END)

             ; FUNCTION USBInterrupt (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
000A 75D000            MOV     PSW,#00H
000D C000              PUSH    AR0
000F C001              PUSH    AR1
0011 C002              PUSH    AR2
0013 C003              PUSH    AR3
0015 C004              PUSH    AR4
0017 C005              PUSH    AR5
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
                                           ; SOURCE LINE # 1103
                                           ; SOURCE LINE # 1106
001D C2AF              CLR     EA
                                           ; SOURCE LINE # 1108
001F 90FF92            MOV     DPTR,#0FF92H
0022 E0                MOVX    A,@DPTR
0023 120000      E     LCALL   ?C?CCASE
0026 0000        R     DW      ?C0104
0028 12                DB      012H
0029 0000        R     DW      ?C0103
002B 22                DB      022H
002C 0000        R     DW      ?C0105
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 42  

002E 30                DB      030H
002F 0000        R     DW      ?C0106
0031 32                DB      032H
0032 0000        R     DW      ?C0108
0034 38                DB      038H
0035 0000        R     DW      ?C0109
0037 3A                DB      03AH
0038 0000        R     DW      ?C0107
003A 3C                DB      03CH
003B 0000        R     DW      ?C0102
003D 44                DB      044H
003E 0000        R     DW      ?C0101
0040 46                DB      046H
0041 0000              DW      00H
0043 0000        R     DW      ?C0110
                                           ; SOURCE LINE # 1109
                                           ; SOURCE LINE # 1110
0045         ?C0101:
                                           ; SOURCE LINE # 1111
0045 90FF92            MOV     DPTR,#0FF92H
0048 E4                CLR     A
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1112
004A 7BFF              MOV     R3,#0FFH
004C 7A00        R     MOV     R2,#HIGH ?SC_254
004E 7900        R     MOV     R1,#LOW ?SC_254
0050 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1113
0053 120000      R     LCALL   OEP0InterruptHandler
                                           ; SOURCE LINE # 1114
0056 020000      R     LJMP    ?C0100
                                           ; SOURCE LINE # 1116
0059         ?C0102:
                                           ; SOURCE LINE # 1117
0059 90FF92            MOV     DPTR,#0FF92H
005C E4                CLR     A
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1118
005E 7BFF              MOV     R3,#0FFH
0060 7A00        R     MOV     R2,#HIGH ?SC_264
0062 7900        R     MOV     R1,#LOW ?SC_264
0064 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1119
0067 120000      R     LCALL   IEP0InterruptHandler
                                           ; SOURCE LINE # 1120
006A 020000      R     LJMP    ?C0100
                                           ; SOURCE LINE # 1122
006D         ?C0103:
                                           ; SOURCE LINE # 1123
006D 90FF92            MOV     DPTR,#0FF92H
0070 E4                CLR     A
0071 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1124
0072 7BFF              MOV     R3,#0FFH
0074 7A00        R     MOV     R2,#HIGH ?SC_273
0076 7900        R     MOV     R1,#LOW ?SC_273
0078 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1125
007B 120000      E     LCALL   IEP1InterruptHandler
                                           ; SOURCE LINE # 1126
007E 8079              SJMP    ?C0100
                                           ; SOURCE LINE # 1128
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 43  

0080         ?C0104:
                                           ; SOURCE LINE # 1129
0080 90FF92            MOV     DPTR,#0FF92H
0083 E4                CLR     A
0084 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1130
0085 7BFF              MOV     R3,#0FFH
0087 7A00        R     MOV     R2,#HIGH ?SC_282
0089 7900        R     MOV     R1,#LOW ?SC_282
008B 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1131
008E 120000      R     LCALL   OEP1InterruptHandler
                                           ; SOURCE LINE # 1132
0091 8066              SJMP    ?C0100
                                           ; SOURCE LINE # 1134
0093         ?C0105:
                                           ; SOURCE LINE # 1135
0093 90FF92            MOV     DPTR,#0FF92H
0096 E4                CLR     A
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1136
0098 90FFFE            MOV     DPTR,#0FFFEH
009B 04                INC     A
009C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1137
009D 7BFF              MOV     R3,#0FFH
009F 7A00        R     MOV     R2,#HIGH ?SC_292
00A1 7900        R     MOV     R1,#LOW ?SC_292
                                           ; SOURCE LINE # 1138
                                           ; SOURCE LINE # 1139
00A3 800B              SJMP    ?C0120
                                           ; SOURCE LINE # 1141
00A5         ?C0106:
                                           ; SOURCE LINE # 1143
00A5 90FF92            MOV     DPTR,#0FF92H
00A8 E4                CLR     A
00A9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1145
00AA 7BFF              MOV     R3,#0FFH
00AC 7A00        R     MOV     R2,#HIGH ?SC_300
00AE 7900        R     MOV     R1,#LOW ?SC_300
00B0         ?C0120:
00B0 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1146
00B3 120000      R     LCALL   SetupPacketInterruptHandler
                                           ; SOURCE LINE # 1147
00B6 8041              SJMP    ?C0100
                                           ; SOURCE LINE # 1149
00B8         ?C0107:
                                           ; SOURCE LINE # 1150
00B8 90FF92            MOV     DPTR,#0FF92H
00BB E4                CLR     A
00BC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1151
00BD 90FFFE            MOV     DPTR,#0FFFEH
00C0 7480              MOV     A,#080H
00C2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1152
00C3 120000      E     LCALL   UsbReset
                                           ; SOURCE LINE # 1153
00C6 8031              SJMP    ?C0100
                                           ; SOURCE LINE # 1155
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 44  

00C8         ?C0108:
                                           ; SOURCE LINE # 1156
00C8 90FF92            MOV     DPTR,#0FF92H
00CB E4                CLR     A
00CC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1157
00CD 90FFFE            MOV     DPTR,#0FFFEH
00D0 7420              MOV     A,#020H
00D2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1158
00D3 C200        R     CLR     bSuspended
                                           ; SOURCE LINE # 1159
00D5 8022              SJMP    ?C0100
                                           ; SOURCE LINE # 1161
00D7         ?C0109:
                                           ; SOURCE LINE # 1162
00D7 90FF92            MOV     DPTR,#0FF92H
00DA E4                CLR     A
00DB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1163
00DC 90FFFE            MOV     DPTR,#0FFFEH
00DF 7440              MOV     A,#040H
00E1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1164
00E2 7BFF              MOV     R3,#0FFH
00E4 7A00        R     MOV     R2,#HIGH ?SC_310
00E6 7900        R     MOV     R1,#LOW ?SC_310
00E8 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1165
00EB D200        R     SETB    bSuspended
                                           ; SOURCE LINE # 1166
00ED 800A              SJMP    ?C0100
                                           ; SOURCE LINE # 1168
00EF         ?C0110:
                                           ; SOURCE LINE # 1169
00EF 90FF92            MOV     DPTR,#0FF92H
00F2 E4                CLR     A
00F3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1170
00F4 E0                MOVX    A,@DPTR
00F5 FF                MOV     R7,A
00F6 120000      E     LCALL   _rs232_printhex
                                           ; SOURCE LINE # 1171
                                           ; SOURCE LINE # 1172
00F9         ?C0100:
                                           ; SOURCE LINE # 1175
00F9 D2AF              SETB    EA
                                           ; SOURCE LINE # 1176
00FB D007              POP     AR7
00FD D006              POP     AR6
00FF D005              POP     AR5
0101 D004              POP     AR4
0103 D003              POP     AR3
0105 D002              POP     AR2
0107 D001              POP     AR1
0109 D000              POP     AR0
010B D0D0              POP     PSW
010D D082              POP     DPL
010F D083              POP     DPH
0111 D0F0              POP     B
0113 D0E0              POP     ACC
0115 32                RETI    
C51 COMPILER V8.02   USB                                                                   07/18/2010 16:48:48 PAGE 45  

             ; FUNCTION USBInterrupt (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1749    ----
   CONSTANT SIZE    =    593    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
