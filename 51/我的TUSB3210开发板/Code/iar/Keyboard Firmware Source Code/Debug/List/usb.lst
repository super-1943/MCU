###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                28/May/2010  14:43:50 #
# Copyright 2004-2009 IAR Systems AB.                                         #
# Time limited license: 20 days left                                          #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\AllProject\51\Keyboard Firmware Source          #
#                          Code\usb.c                                         #
#    Command line       =  "E:\AllProject\51\Keyboard Firmware Source         #
#                          Code\usb.c" -lC "E:\AllProject\51\Keyboard         #
#                          Firmware Source Code\Debug\List\" -lA              #
#                          "E:\AllProject\51\Keyboard Firmware Source         #
#                          Code\Debug\List\" -o "E:\AllProject\51\Keyboard    #
#                          Firmware Source Code\Debug\Obj\" -e                #
#                          --char_is_signed --no_cse --no_unroll --no_inline  #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large --code_model=near   #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8 -I      #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.3 Evaluation version\8051\INC\" -I "C:\Program   #
#                          Files\IAR Systems\Embedded Workbench 5.3           #
#                          Evaluation version\8051\INC\CLIB\" -Ol             #
#    List file          =  E:\AllProject\51\Keyboard Firmware Source          #
#                          Code\Debug\List\usb.lst                            #
#    Object file        =  E:\AllProject\51\Keyboard Firmware Source          #
#                          Code\Debug\Obj\usb.r51                             #
#                                                                             #
#                                                                             #
###############################################################################

E:\AllProject\51\Keyboard Firmware Source Code\usb.c
      1          /******************************************************************************
      2           *                         VAULT INFORMATION SERVICES                         *
      3           *                          TEXAS INSTRUMENTS, INC.                           *
      4           *----------------------------------------------------------------------------*
      5           *                     "USB Handler for TUSB2136 Demo App"                    *
      6           *                                                                            * 
      7           * Programmed by: Craig Steiner, VIS (csteiner@vaultbbs.com)                  * 
      8           * Develop Date:  30/Sep/2000                                                 *  
      9           *----------------------------------------------------------------------------*
     10           * Description: This module is a component of the TUSB2136 Demo App.  It      *
     11           *   handles all USB-related operation functions such as USB request          *
     12           *   handlers, interrupts, etc.  Functions related to USB initialization      *
     13           *   may be found in usbinit.c                                                * 
     14           *                                                                            *
     15           * Modified by Jim Chen 2001/01/03:                                           *
     16           *   1. total 102 keys                                                        *
     17           *   2. can work in Mac                                                       *
     18           *   3. use scanline8, scanline9 and return 0x40 as suspend key               *
     19           *   4. added usbSetIdle(void), void usbSetProtocol(void) for Mac             *
     20           *                                                                            *
     21           * Modified by Jim Chen 2001/01/19:                                           *
     22           *   1. fixed bug in high speed Mac                                           *
     23           *                                                                            *
     24           * Modified by Jim Chen 2001/01/31:                                           *
     25           *   1. added usbGetIdle and usbGetProtocol for passing HIDView optional      *
     26           *      commands                                                              *
     27           *                                                                            *
     28           * Modified by Jim Chen 2001/05/20:                                           *
     29           *   1. fix bug on                                                            *
     30           *      USB_REQ_SET_INTERFACE mapping usbSetInterface of tUsbRequestList      *
     31           ******************************************************************************/
     32          
     33          #include <io51.h>

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IE
   \                     _A_IE:
   \   000000                DS 1
     34          #include "types.h"
     35          #include "tusb2136.h"
     36          #include "usb.h"
     37          #include "delay.h"
     38          
     39          /***************************************************************************
     40           * Section:    TUSB2136 Segment Definitions                                *
     41           * Programmer: Craig Steiner (csteiner@vaultbbs.com)                       *
     42           * Description: This section of code assigns certain variables to defined  *
     43           *    mapped memory addresses in the TUSB2136.  The mapped memory symbols  *
     44           *    used in the dataset() pragmas are found in the .XCL file for the     * 
     45           *    project.                                                             *  
     46           ***************************************************************************/
     47          
     48          #pragma dataseg=TUSB2136_SETUPPACKET_SEG

   \                                 In  segment TUSB2136_SETUPPACKET_SEG, align 1
     49          __no_init tDEVICE_REQUEST tSetupPacket;
   \                     tSetupPacket:
   \   000000                DS 8
     50          #pragma dataseg= default
     51          
     52          #pragma dataseg=TUSB2136_EP0_EDB_SEG

   \                                 In  segment TUSB2136_EP0_EDB_SEG, align 1
     53          __no_init tEDB0 tEndPoint0DescriptorBlock;
   \                     tEndPoint0DescriptorBlock:
   \   000000                DS 4
     54          #pragma dataseg= default
     55          
     56          #pragma dataseg=TUSB2136_IEP_EDB_SEG

   \                                 In  segment TUSB2136_IEP_EDB_SEG, align 1
     57          __no_init tEDB tInputEndPointDescriptorBlock[3];
   \                     tInputEndPointDescriptorBlock:
   \   000000                DS 24
     58          #pragma dataseg= default
     59          
     60          #pragma dataseg=TUSB2136_OEP_EDB_SEG

   \                                 In  segment TUSB2136_OEP_EDB_SEG, align 1
     61          __no_init tEDB tOutputEndPointDescriptorBlock[3];
   \                     tOutputEndPointDescriptorBlock:
   \   000000                DS 24
     62          #pragma dataseg= default
     63          
     64          #pragma dataseg=TUSB2136_IEP0BUFFER_SEG

   \                                 In  segment TUSB2136_IEP0BUFFER_SEG, align 1
     65          __no_init BYTE abIEP0Buffer[EP0_MAX_PACKET_SIZE];
   \                     abIEP0Buffer:
   \   000000                DS 8
     66          #pragma dataseg= default
     67          
     68          #pragma dataseg=TUSB2136_OEP0BUFFER_SEG

   \                                 In  segment TUSB2136_OEP0BUFFER_SEG, align 1
     69          __no_init BYTE abOEP0Buffer[EP0_MAX_PACKET_SIZE];
   \                     abOEP0Buffer:
   \   000000                DS 8
     70          #pragma dataseg= default
     71          
     72          #pragma dataseg=TUSB2136_DESC_SEG             // 0xfe00

   \                                 In  segment TUSB2136_DESC_SEG, align 1
     73          __no_init BYTE abDescriptor[SIZEOF_DEVICE_DESCRIPTOR];
   \                     abDescriptor:
   \   000000                DS 18
     74          //BYTE abConfigurationDescriptorGroup[SIZEOF_BOOTCODE_CONFIG_DESC_GROUP];
     75          //BYTE abStringDescriptor[SIZEOF_BOOTCODE_STRING_DESC_GROUP];
     76          #pragma dataseg= default
     77          
     78          #pragma dataseg=TUSB2136_OEP1_X_BUFFER_SEG    // 0xfd80

   \                                 In  segment TUSB2136_OEP1_X_BUFFER_SEG, align 1
     79          __no_init BYTE pbXBufferAddress[EP_MAX_PACKET_SIZE];
   \                     pbXBufferAddress:
   \   000000                DS 64
     80          #pragma dataseg= default
     81          
     82          #pragma dataseg=TUSB2136_OEP1_Y_BUFFER_SEG    // 0xfdc0

   \                                 In  segment TUSB2136_OEP1_Y_BUFFER_SEG, align 1
     83          __no_init BYTE pbYBufferAddress[EP_MAX_PACKET_SIZE];
   \                     pbYBufferAddress:
   \   000000                DS 64
     84          #pragma dataseg= default
     85          
     86          /***************************************************************************
     87           * Section:    Declarations                                                *
     88           * Programmer: Craig Steiner (csteiner@vaultbbs.com)                       *
     89           * Description: This section of the code declares global and external      *
     90           *    variables, as well as functions, etc.                                *
     91           ***************************************************************************/
     92          
     93          // EXTERNAL DECLARATIONS 
     94          extern BYTE code abromReportDescriptor[SIZEOF_REPORT_DESCRIPTOR];
     95          extern void setLEDs(BYTE bData); // From 8255.c
     96          extern unsigned char intFlags; // From keyboard.c
     97          extern unsigned char otherFlags; // From keyboard.c
     98          extern void IEP1InterruptHandler(void); // From keyboard.c
     99          extern void UsbReset(void); // From usbinit.c
    100          extern void OEP0SetLEDs(void);
    101          extern BYTE bLED;
    102          extern struct FUNCDEF_STRUCT code funcDefs[17]; // From vidpid.c
    103          extern unsigned char fncOffset; // From vidpid.c
    104          extern BYTE code abromReportDescriptor[SIZEOF_REPORT_DESCRIPTOR];
    105          extern BYTE code abromConfigurationDescriptorGroup[SIZEOF_BOOTCODE_CONFIG_DESC_GROUP];
    106          extern BYTE code abromDeviceDescriptor[SIZEOF_DEVICE_DESCRIPTOR];
    107          extern BYTE strlen(char *string); // From support.c
    108          
    109          
    110          
    111          // GLOBAL VARIABLE DECLARATIONS
    112          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    113          BYTE deviceReady = FALSE;		// Indicates whether the device has been
   \                     deviceReady:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    114          								// properly initialized on the USB bus.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    115          BYTE bSuspended = FALSE;		// Indicates whether the device is suspended or not
   \                     bSuspended:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    116          BYTE bStatusAction;				// Indicates the current state of sending
   \                     bStatusAction:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    117          								// receiving data packets.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    118          BYTE bUsbDeviceAddress;			// The device's USB address.
   \                     bUsbDeviceAddress:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    119          WORD wBytesRemainingOnIEP0;     // For endpoint zero transmitter only
   \                     wBytesRemainingOnIEP0:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    120                                          // Holds count of bytes remaining to be
    121                                          // transmitted by endpoint 0.  A value
    122                                          // of 0 means that a 0-length data packet
    123                                          // A value of 0xFFFF means that transfer
    124                                          // is complete.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    125          BOOL bHostAskMoreDataThanAvailable;
   \                     bHostAskMoreDataThanAvailable:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    126                                          // If host ask more data then TUSB2136 has
    127                                          // It will send one zero-length packet
    128                                          // if the asked lenght is a multiple of
    129                                          // max. size of endpoint 0

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    130          PBYTE pbIEP0Buffer;             // A buffer pointer to input end point 0
   \                     pbIEP0Buffer:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    131                                          // Data sent back to host is copied from
    132                                          // this pointed memory location

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    133          BYTE bConfigurationNumber = 0;  // Set to 1 when USB device has been
   \                     bConfigurationNumber:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    134                                          // configured, set to 0 when unconfigured

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    135          BYTE bInterfaceNumber = 0;		// The interface number selected
   \                     bInterfaceNumber:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    136          WORD wDeviceFeatures = 0;		// The device features
   \                     wDeviceFeatures:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    137          WORD wBytesRemainingOnOEP0;     // For endpoint zero transmitter only
   \                     wBytesRemainingOnOEP0:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    138                                          // Holds count of bytes remaining to be
    139                                          // received by endpoint 0.  A value
    140                                          // of 0 means that a 0-length data packet
    141                                          // A value of 0xFFFF means that transfer

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    142          PBYTE pbOEP0Buffer;             // A buffer pointer to output end point 0
   \                     pbOEP0Buffer:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    143                                          // Data sent from host is copied to
    144                                          // this pointed memory location
    145                                          // is complete.
    146          
    147          #define usbClearOEP0ByteCount tEndPoint0DescriptorBlock.bOEPBCNT = 0x00
    148          #define usbStallOEP0          tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL
    149          
    150          void usbReceiveDataPacketOnEP0(PBYTE pbBuffer);
    151          void usbStallEndpoint0(void);
    152          void usbSendZeroLengthPacketOnIEP0(void);
    153          void usbSendNextPacketOnIEP0(void);
    154          void usbSendDataPacketOnEP0(PBYTE pbBuffer);
    155          
    156          
    157          
    158          
    159          /***************************************************************************
    160           * Section:    USB REQUEST FUNCTIONS                                       *
    161           * Programmer: Craig Steiner (csteiner@vaultbbs.com) based on code by      *
    162           *             Lobo Tai (lobotai@ti.com)                                   *
    163           * Description: The functions in this section of code are called by the    *
    164           *    usbDecodeAndProcessUsbRequest function when a Setup packet is        *
    165           *    received.  Each function handles a specific USB/Class/Endpoint       *
    166           *    function.                                                            *
    167           ***************************************************************************/
    168          
    169          // The Get/Set configuration functions allow the host to select one of various
    170          // configurations that the keyboard may support.  This firmware only supports
    171          // one configuration, but the following functions allow the firmware to accept
    172          // any given configuration number.  The code, as-is, will function identically
    173          // in any given configuration, but additional configurations may be supported
    174          // by simply adding support for the configurations, presumably in keyboard.c.
    175          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    176          void usbGetConfiguration(void)
   \                     usbGetConfiguration:
    177          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    178              wBytesRemainingOnIEP0 = 1;
   \   000004   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000007   7401         MOV     A,#0x1
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   7400         MOV     A,#0x0
   \   00000D   F0           MOVX    @DPTR,A
    179              usbSendDataPacketOnEP0((PBYTE) &bConfigurationNumber);
   \   00000E                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   00000E   7A..         MOV     R2,#(bConfigurationNumber & 0xff)
   \   000010   7B..         MOV     R3,#((bConfigurationNumber >> 8) & 0xff)
   \   000012   12....       LCALL   usbSendDataPacketOnEP0
    180          }
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   22           RET
    181          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    182          void usbSetConfiguration(void)
   \                     usbSetConfiguration:
    183          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    184              usbStallOEP0;
   \   000004   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 2)
   \   000007   E0           MOVX    A,@DPTR
   \   000008   D2E3         SETB    0xE0 /* A   */.3
   \   00000A   F0           MOVX    @DPTR,A
    185              bConfigurationNumber = tSetupPacket.bValueL;
   \   00000B   90....       MOV     DPTR,#(tSetupPacket + 2)
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   90....       MOV     DPTR,#bConfigurationNumber
   \   000012   F0           MOVX    @DPTR,A
    186              usbSendZeroLengthPacketOnIEP0();
   \   000013                ; Setup parameters for call to function usbSendZeroLengthPacketOnIEP0
   \   000013   12....       LCALL   usbSendZeroLengthPacketOnIEP0
    187          }
   \   000016   D083         POP     DPH
   \   000018   D082         POP     DPL
   \   00001A   22           RET
    188          
    189          // The Set_Report request is sent by the host to a typical HID device,
    190          // such as this keyboard, to update the LEDs that correspond to the
    191          // scroll lock, caps lock, and num lock.  When the Set_Report setup
    192          // packet is received, we initiate a "Receive Data Packet" sequence
    193          // since the actual 1-byte data value will be in the following
    194          // packet on OEP0.  Thus we initicate that we will receive 1 byte
    195          // (since the LED data is contained in a single byte) and we
    196          // instruct the receive routine to receive the data at the address
    197          // at which the bLED variable is located.  Thus bLed will automatically
    198          // be updated with the new value after the transfer is completed.
    199          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    200          void usbSetReport(void)
   \                     usbSetReport:
    201          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    202              wBytesRemainingOnOEP0 = 1;
   \   000004   90....       MOV     DPTR,#wBytesRemainingOnOEP0
   \   000007   7401         MOV     A,#0x1
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   7400         MOV     A,#0x0
   \   00000D   F0           MOVX    @DPTR,A
    203              usbReceiveDataPacketOnEP0((PBYTE) &bLED);
   \   00000E                ; Setup parameters for call to function usbReceiveDataPacketOnEP0
   \   00000E   7A..         MOV     R2,#(bLED & 0xff)
   \   000010   7B..         MOV     R3,#((bLED >> 8) & 0xff)
   \   000012   12....       LCALL   usbReceiveDataPacketOnEP0
    204          }
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   22           RET
    205          
    206          // The following functions are called at initial device enumeration, and are used
    207          // to obtain the device, configuration, and string descriptors from the
    208          // device.
    209          
    210          //extern unsigned char s0123; // The s0132 value read from VIDSTA at boot time

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    211          void usbGetDeviceDescriptor(void)
   \                     usbGetDeviceDescriptor:
    212          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    213          	BYTE bTemp;
    214          	// Copy the DEVICE DESCRIPTOR from program "ROM" to XRAM
    215              for(bTemp=0;bTemp<SIZEOF_DEVICE_DESCRIPTOR;bTemp++)
   \   000005   7A00         MOV     R2,#0x0
   \   000007   802A         SJMP    ??usbGetDeviceDescriptor_0
    216                  abDescriptor[bTemp] = abromDeviceDescriptor[bTemp];
   \                     ??usbGetDeviceDescriptor_1:
   \   000009   8A..         MOV     ?V0 + 0,R2
   \   00000B   75..00       MOV     ?V0 + 1,#0x0
   \   00000E   E5..         MOV     A,?V0 + 0
   \   000010   24..         ADD     A,#(abromDeviceDescriptor & 0xff)
   \   000012   F582         MOV     DPL,A
   \   000014   E5..         MOV     A,?V0 + 1
   \   000016   34..         ADDC    A,#((abromDeviceDescriptor >> 8) & 0xff)
   \   000018   F583         MOV     DPH,A
   \   00001A   E4           CLR     A
   \   00001B   93           MOVC    A,@A+DPTR
   \   00001C   C0E0         PUSH    A
   \   00001E   8A..         MOV     ?V0 + 0,R2
   \   000020   75..00       MOV     ?V0 + 1,#0x0
   \   000023   E5..         MOV     A,?V0 + 0
   \   000025   24..         ADD     A,#(abDescriptor & 0xff)
   \   000027   F582         MOV     DPL,A
   \   000029   E5..         MOV     A,?V0 + 1
   \   00002B   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   00002D   F583         MOV     DPH,A
   \   00002F   D0E0         POP     A
   \   000031   F0           MOVX    @DPTR,A
   \   000032   0A           INC     R2
   \                     ??usbGetDeviceDescriptor_0:
   \   000033   EA           MOV     A,R2
   \   000034   C3           CLR     C
   \   000035   9412         SUBB    A,#0x12
   \   000037   40D0         JC      ??usbGetDeviceDescriptor_1
    217          
    218          	// Modify the FUNCTION VID/PID and firmware version using our selected value
    219          //	abDescriptor[OFFSET_DEVICE_DESCRIPTOR_VID_L] = s0123;
    220          	abDescriptor[OFFSET_DEVICE_DESCRIPTOR_VID_L] = (funcDefs[fncOffset].fncVID & 0xFF);
   \   000039   90....       MOV     DPTR,#fncOffset
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   7900         MOV     R1,#0x0
   \   000040   E8           MOV     A,R0
   \   000041   75F011       MOV     B,#0x11
   \   000044   A4           MUL     AB
   \   000045   C8           XCH     A,R0
   \   000046   AAF0         MOV     R2,B
   \   000048   75F000       MOV     B,#0x0
   \   00004B   A4           MUL     AB
   \   00004C   2A           ADD     A,R2
   \   00004D   FA           MOV     R2,A
   \   00004E   75F011       MOV     B,#0x11
   \   000051   E9           MOV     A,R1
   \   000052   A4           MUL     AB
   \   000053   2A           ADD     A,R2
   \   000054   F9           MOV     R1,A
   \   000055   E8           MOV     A,R0
   \   000056   24..         ADD     A,#((funcDefs + 5) & 0xff)
   \   000058   F582         MOV     DPL,A
   \   00005A   E9           MOV     A,R1
   \   00005B   34..         ADDC    A,#(((funcDefs + 5) >> 8) & 0xff)
   \   00005D   F583         MOV     DPH,A
   \   00005F   E4           CLR     A
   \   000060   93           MOVC    A,@A+DPTR
   \   000061   90....       MOV     DPTR,#(abDescriptor + 8)
   \   000064   F0           MOVX    @DPTR,A
    221          	abDescriptor[OFFSET_DEVICE_DESCRIPTOR_VID_H] = ((funcDefs[fncOffset].fncVID & 0xFF00) >> 8);	
   \   000065   90....       MOV     DPTR,#fncOffset
   \   000068   E0           MOVX    A,@DPTR
   \   000069   F8           MOV     R0,A
   \   00006A   7900         MOV     R1,#0x0
   \   00006C   E8           MOV     A,R0
   \   00006D   75F011       MOV     B,#0x11
   \   000070   A4           MUL     AB
   \   000071   C8           XCH     A,R0
   \   000072   AAF0         MOV     R2,B
   \   000074   75F000       MOV     B,#0x0
   \   000077   A4           MUL     AB
   \   000078   2A           ADD     A,R2
   \   000079   FA           MOV     R2,A
   \   00007A   75F011       MOV     B,#0x11
   \   00007D   E9           MOV     A,R1
   \   00007E   A4           MUL     AB
   \   00007F   2A           ADD     A,R2
   \   000080   F9           MOV     R1,A
   \   000081   E8           MOV     A,R0
   \   000082   24..         ADD     A,#((funcDefs + 5) & 0xff)
   \   000084   F582         MOV     DPL,A
   \   000086   E9           MOV     A,R1
   \   000087   34..         ADDC    A,#(((funcDefs + 5) >> 8) & 0xff)
   \   000089   F583         MOV     DPH,A
   \   00008B   7401         MOV     A,#0x1
   \   00008D   93           MOVC    A,@A+DPTR
   \   00008E   F9           MOV     R1,A
   \   00008F   E9           MOV     A,R1
   \   000090   90....       MOV     DPTR,#(abDescriptor + 9)
   \   000093   F0           MOVX    @DPTR,A
    222          	abDescriptor[OFFSET_DEVICE_DESCRIPTOR_PID_L] = (funcDefs[fncOffset].fncPID & 0xFF);
   \   000094   90....       MOV     DPTR,#fncOffset
   \   000097   E0           MOVX    A,@DPTR
   \   000098   F8           MOV     R0,A
   \   000099   7900         MOV     R1,#0x0
   \   00009B   E8           MOV     A,R0
   \   00009C   75F011       MOV     B,#0x11
   \   00009F   A4           MUL     AB
   \   0000A0   C8           XCH     A,R0
   \   0000A1   AAF0         MOV     R2,B
   \   0000A3   75F000       MOV     B,#0x0
   \   0000A6   A4           MUL     AB
   \   0000A7   2A           ADD     A,R2
   \   0000A8   FA           MOV     R2,A
   \   0000A9   75F011       MOV     B,#0x11
   \   0000AC   E9           MOV     A,R1
   \   0000AD   A4           MUL     AB
   \   0000AE   2A           ADD     A,R2
   \   0000AF   F9           MOV     R1,A
   \   0000B0   E8           MOV     A,R0
   \   0000B1   24..         ADD     A,#((funcDefs + 7) & 0xff)
   \   0000B3   F582         MOV     DPL,A
   \   0000B5   E9           MOV     A,R1
   \   0000B6   34..         ADDC    A,#(((funcDefs + 7) >> 8) & 0xff)
   \   0000B8   F583         MOV     DPH,A
   \   0000BA   E4           CLR     A
   \   0000BB   93           MOVC    A,@A+DPTR
   \   0000BC   90....       MOV     DPTR,#(abDescriptor + 10)
   \   0000BF   F0           MOVX    @DPTR,A
    223          	abDescriptor[OFFSET_DEVICE_DESCRIPTOR_PID_H] = ((funcDefs[fncOffset].fncPID & 0xFF00) >> 8);	
   \   0000C0   90....       MOV     DPTR,#fncOffset
   \   0000C3   E0           MOVX    A,@DPTR
   \   0000C4   F8           MOV     R0,A
   \   0000C5   7900         MOV     R1,#0x0
   \   0000C7   E8           MOV     A,R0
   \   0000C8   75F011       MOV     B,#0x11
   \   0000CB   A4           MUL     AB
   \   0000CC   C8           XCH     A,R0
   \   0000CD   AAF0         MOV     R2,B
   \   0000CF   75F000       MOV     B,#0x0
   \   0000D2   A4           MUL     AB
   \   0000D3   2A           ADD     A,R2
   \   0000D4   FA           MOV     R2,A
   \   0000D5   75F011       MOV     B,#0x11
   \   0000D8   E9           MOV     A,R1
   \   0000D9   A4           MUL     AB
   \   0000DA   2A           ADD     A,R2
   \   0000DB   F9           MOV     R1,A
   \   0000DC   E8           MOV     A,R0
   \   0000DD   24..         ADD     A,#((funcDefs + 7) & 0xff)
   \   0000DF   F582         MOV     DPL,A
   \   0000E1   E9           MOV     A,R1
   \   0000E2   34..         ADDC    A,#(((funcDefs + 7) >> 8) & 0xff)
   \   0000E4   F583         MOV     DPH,A
   \   0000E6   7401         MOV     A,#0x1
   \   0000E8   93           MOVC    A,@A+DPTR
   \   0000E9   F9           MOV     R1,A
   \   0000EA   E9           MOV     A,R1
   \   0000EB   90....       MOV     DPTR,#(abDescriptor + 11)
   \   0000EE   F0           MOVX    @DPTR,A
    224          	abDescriptor[OFFSET_DEVICE_DESCRIPTOR_VER_L] = (funcDefs[fncOffset].fncRevision & 0xFF);
   \   0000EF   90....       MOV     DPTR,#fncOffset
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   F8           MOV     R0,A
   \   0000F4   7900         MOV     R1,#0x0
   \   0000F6   E8           MOV     A,R0
   \   0000F7   75F011       MOV     B,#0x11
   \   0000FA   A4           MUL     AB
   \   0000FB   C8           XCH     A,R0
   \   0000FC   AAF0         MOV     R2,B
   \   0000FE   75F000       MOV     B,#0x0
   \   000101   A4           MUL     AB
   \   000102   2A           ADD     A,R2
   \   000103   FA           MOV     R2,A
   \   000104   75F011       MOV     B,#0x11
   \   000107   E9           MOV     A,R1
   \   000108   A4           MUL     AB
   \   000109   2A           ADD     A,R2
   \   00010A   F9           MOV     R1,A
   \   00010B   E8           MOV     A,R0
   \   00010C   24..         ADD     A,#((funcDefs + 9) & 0xff)
   \   00010E   F582         MOV     DPL,A
   \   000110   E9           MOV     A,R1
   \   000111   34..         ADDC    A,#(((funcDefs + 9) >> 8) & 0xff)
   \   000113   F583         MOV     DPH,A
   \   000115   E4           CLR     A
   \   000116   93           MOVC    A,@A+DPTR
   \   000117   90....       MOV     DPTR,#(abDescriptor + 12)
   \   00011A   F0           MOVX    @DPTR,A
    225          	abDescriptor[OFFSET_DEVICE_DESCRIPTOR_VER_H] = ((funcDefs[fncOffset].fncRevision & 0xFF00) >> 8);	
   \   00011B   90....       MOV     DPTR,#fncOffset
   \   00011E   E0           MOVX    A,@DPTR
   \   00011F   F8           MOV     R0,A
   \   000120   7900         MOV     R1,#0x0
   \   000122   E8           MOV     A,R0
   \   000123   75F011       MOV     B,#0x11
   \   000126   A4           MUL     AB
   \   000127   C8           XCH     A,R0
   \   000128   AAF0         MOV     R2,B
   \   00012A   75F000       MOV     B,#0x0
   \   00012D   A4           MUL     AB
   \   00012E   2A           ADD     A,R2
   \   00012F   FA           MOV     R2,A
   \   000130   75F011       MOV     B,#0x11
   \   000133   E9           MOV     A,R1
   \   000134   A4           MUL     AB
   \   000135   2A           ADD     A,R2
   \   000136   F9           MOV     R1,A
   \   000137   E8           MOV     A,R0
   \   000138   24..         ADD     A,#((funcDefs + 9) & 0xff)
   \   00013A   F582         MOV     DPL,A
   \   00013C   E9           MOV     A,R1
   \   00013D   34..         ADDC    A,#(((funcDefs + 9) >> 8) & 0xff)
   \   00013F   F583         MOV     DPH,A
   \   000141   7401         MOV     A,#0x1
   \   000143   93           MOVC    A,@A+DPTR
   \   000144   F9           MOV     R1,A
   \   000145   E9           MOV     A,R1
   \   000146   90....       MOV     DPTR,#(abDescriptor + 13)
   \   000149   F0           MOVX    @DPTR,A
    226          	if(funcDefs[fncOffset].mfgDescription == NULL )
   \   00014A   90....       MOV     DPTR,#fncOffset
   \   00014D   E0           MOVX    A,@DPTR
   \   00014E   F8           MOV     R0,A
   \   00014F   7900         MOV     R1,#0x0
   \   000151   E8           MOV     A,R0
   \   000152   75F011       MOV     B,#0x11
   \   000155   A4           MUL     AB
   \   000156   C8           XCH     A,R0
   \   000157   AAF0         MOV     R2,B
   \   000159   75F000       MOV     B,#0x0
   \   00015C   A4           MUL     AB
   \   00015D   2A           ADD     A,R2
   \   00015E   FA           MOV     R2,A
   \   00015F   75F011       MOV     B,#0x11
   \   000162   E9           MOV     A,R1
   \   000163   A4           MUL     AB
   \   000164   2A           ADD     A,R2
   \   000165   F9           MOV     R1,A
   \   000166   E8           MOV     A,R0
   \   000167   24..         ADD     A,#((funcDefs + 11) & 0xff)
   \   000169   F582         MOV     DPL,A
   \   00016B   E9           MOV     A,R1
   \   00016C   34..         ADDC    A,#(((funcDefs + 11) >> 8) & 0xff)
   \   00016E   F583         MOV     DPH,A
   \   000170   E4           CLR     A
   \   000171   93           MOVC    A,@A+DPTR
   \   000172   F8           MOV     R0,A
   \   000173   7401         MOV     A,#0x1
   \   000175   93           MOVC    A,@A+DPTR
   \   000176   F9           MOV     R1,A
   \   000177   7400         MOV     A,#0x0
   \   000179   68           XRL     A,R0
   \   00017A   7003         JNZ     ??usbGetDeviceDescriptor_2
   \   00017C   7400         MOV     A,#0x0
   \   00017E   69           XRL     A,R1
   \                     ??usbGetDeviceDescriptor_2:
   \   00017F   7006         JNZ     ??usbGetDeviceDescriptor_3
    227          		abDescriptor[OFFSET_DEVICE_DESCRIPTOR_IMFG] = 0x00;
   \   000181   7400         MOV     A,#0x0
   \   000183   90....       MOV     DPTR,#(abDescriptor + 14)
   \   000186   F0           MOVX    @DPTR,A
    228          	if(funcDefs[fncOffset].prodDescription == NULL )
   \                     ??usbGetDeviceDescriptor_3:
   \   000187   90....       MOV     DPTR,#fncOffset
   \   00018A   E0           MOVX    A,@DPTR
   \   00018B   F8           MOV     R0,A
   \   00018C   7900         MOV     R1,#0x0
   \   00018E   E8           MOV     A,R0
   \   00018F   75F011       MOV     B,#0x11
   \   000192   A4           MUL     AB
   \   000193   C8           XCH     A,R0
   \   000194   AAF0         MOV     R2,B
   \   000196   75F000       MOV     B,#0x0
   \   000199   A4           MUL     AB
   \   00019A   2A           ADD     A,R2
   \   00019B   FA           MOV     R2,A
   \   00019C   75F011       MOV     B,#0x11
   \   00019F   E9           MOV     A,R1
   \   0001A0   A4           MUL     AB
   \   0001A1   2A           ADD     A,R2
   \   0001A2   F9           MOV     R1,A
   \   0001A3   E8           MOV     A,R0
   \   0001A4   24..         ADD     A,#((funcDefs + 13) & 0xff)
   \   0001A6   F582         MOV     DPL,A
   \   0001A8   E9           MOV     A,R1
   \   0001A9   34..         ADDC    A,#(((funcDefs + 13) >> 8) & 0xff)
   \   0001AB   F583         MOV     DPH,A
   \   0001AD   E4           CLR     A
   \   0001AE   93           MOVC    A,@A+DPTR
   \   0001AF   F8           MOV     R0,A
   \   0001B0   7401         MOV     A,#0x1
   \   0001B2   93           MOVC    A,@A+DPTR
   \   0001B3   F9           MOV     R1,A
   \   0001B4   7400         MOV     A,#0x0
   \   0001B6   68           XRL     A,R0
   \   0001B7   7003         JNZ     ??usbGetDeviceDescriptor_4
   \   0001B9   7400         MOV     A,#0x0
   \   0001BB   69           XRL     A,R1
   \                     ??usbGetDeviceDescriptor_4:
   \   0001BC   7006         JNZ     ??usbGetDeviceDescriptor_5
    229          		abDescriptor[OFFSET_DEVICE_DESCRIPTOR_IPROD] = 0x00;
   \   0001BE   7400         MOV     A,#0x0
   \   0001C0   90....       MOV     DPTR,#(abDescriptor + 15)
   \   0001C3   F0           MOVX    @DPTR,A
    230          	if(funcDefs[fncOffset].serialNumber == NULL )
   \                     ??usbGetDeviceDescriptor_5:
   \   0001C4   90....       MOV     DPTR,#fncOffset
   \   0001C7   E0           MOVX    A,@DPTR
   \   0001C8   F8           MOV     R0,A
   \   0001C9   7900         MOV     R1,#0x0
   \   0001CB   E8           MOV     A,R0
   \   0001CC   75F011       MOV     B,#0x11
   \   0001CF   A4           MUL     AB
   \   0001D0   C8           XCH     A,R0
   \   0001D1   AAF0         MOV     R2,B
   \   0001D3   75F000       MOV     B,#0x0
   \   0001D6   A4           MUL     AB
   \   0001D7   2A           ADD     A,R2
   \   0001D8   FA           MOV     R2,A
   \   0001D9   75F011       MOV     B,#0x11
   \   0001DC   E9           MOV     A,R1
   \   0001DD   A4           MUL     AB
   \   0001DE   2A           ADD     A,R2
   \   0001DF   F9           MOV     R1,A
   \   0001E0   E8           MOV     A,R0
   \   0001E1   24..         ADD     A,#((funcDefs + 15) & 0xff)
   \   0001E3   F582         MOV     DPL,A
   \   0001E5   E9           MOV     A,R1
   \   0001E6   34..         ADDC    A,#(((funcDefs + 15) >> 8) & 0xff)
   \   0001E8   F583         MOV     DPH,A
   \   0001EA   E4           CLR     A
   \   0001EB   93           MOVC    A,@A+DPTR
   \   0001EC   F8           MOV     R0,A
   \   0001ED   7401         MOV     A,#0x1
   \   0001EF   93           MOVC    A,@A+DPTR
   \   0001F0   F9           MOV     R1,A
   \   0001F1   7400         MOV     A,#0x0
   \   0001F3   68           XRL     A,R0
   \   0001F4   7003         JNZ     ??usbGetDeviceDescriptor_6
   \   0001F6   7400         MOV     A,#0x0
   \   0001F8   69           XRL     A,R1
   \                     ??usbGetDeviceDescriptor_6:
   \   0001F9   7006         JNZ     ??usbGetDeviceDescriptor_7
    231          		abDescriptor[OFFSET_DEVICE_DESCRIPTOR_ISN] = 0x00;
   \   0001FB   7400         MOV     A,#0x0
   \   0001FD   90....       MOV     DPTR,#(abDescriptor + 16)
   \   000200   F0           MOVX    @DPTR,A
    232          
    233              usbClearOEP0ByteCount;
   \                     ??usbGetDeviceDescriptor_7:
   \   000201   7400         MOV     A,#0x0
   \   000203   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 3)
   \   000206   F0           MOVX    @DPTR,A
    234              wBytesRemainingOnIEP0 = SIZEOF_DEVICE_DESCRIPTOR;
   \   000207   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   00020A   7412         MOV     A,#0x12
   \   00020C   F0           MOVX    @DPTR,A
   \   00020D   A3           INC     DPTR
   \   00020E   7400         MOV     A,#0x0
   \   000210   F0           MOVX    @DPTR,A
    235              usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
   \   000211                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   000211   7A..         MOV     R2,#(abDescriptor & 0xff)
   \   000213   7B..         MOV     R3,#((abDescriptor >> 8) & 0xff)
   \   000215   12....       LCALL   usbSendDataPacketOnEP0
    236              
    237              // Once the Device Descriptor has been sent, the device can essentially
    238              // function.  Thus we enable the deviceReady variable so that the main
    239              // code in keyboard.c knows that it can begin the service loop.
    240          	deviceReady = TRUE;    
   \   000218   7401         MOV     A,#0x1
   \   00021A   90....       MOV     DPTR,#deviceReady
   \   00021D   F0           MOVX    @DPTR,A
    241          }
   \   00021E   7F02         MOV     R7,#0x2
   \   000220   02....       LJMP    ?FUNC_LEAVE_XDATA
    242          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    243          void usbGetHIDDescriptor(void)
   \                     usbGetHIDDescriptor:
    244          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    245          	BYTE bTemp;
    246          	// Copy the DEVICE DESCRIPTOR from program "ROM" to XRAM
    247              for(bTemp=0;bTemp<SIZEOF_DEVICE_DESCRIPTOR;bTemp++)
   \   000005   7A00         MOV     R2,#0x0
   \   000007   802A         SJMP    ??usbGetHIDDescriptor_0
    248                  abDescriptor[bTemp] = abromConfigurationDescriptorGroup[SIZEOF_CONFIG_DESCRIPTOR+SIZEOF_INTERFACE_DESCRIPTOR + bTemp];
   \                     ??usbGetHIDDescriptor_1:
   \   000009   8A..         MOV     ?V0 + 0,R2
   \   00000B   75..00       MOV     ?V0 + 1,#0x0
   \   00000E   E5..         MOV     A,?V0 + 0
   \   000010   24..         ADD     A,#((abromConfigurationDescriptorGroup + 18) & 0xff)
   \   000012   F582         MOV     DPL,A
   \   000014   E5..         MOV     A,?V0 + 1
   \   000016   34..         ADDC    A,#(((abromConfigurationDescriptorGroup + 18) >> 8) & 0xff)
   \   000018   F583         MOV     DPH,A
   \   00001A   E4           CLR     A
   \   00001B   93           MOVC    A,@A+DPTR
   \   00001C   C0E0         PUSH    A
   \   00001E   8A..         MOV     ?V0 + 0,R2
   \   000020   75..00       MOV     ?V0 + 1,#0x0
   \   000023   E5..         MOV     A,?V0 + 0
   \   000025   24..         ADD     A,#(abDescriptor & 0xff)
   \   000027   F582         MOV     DPL,A
   \   000029   E5..         MOV     A,?V0 + 1
   \   00002B   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   00002D   F583         MOV     DPH,A
   \   00002F   D0E0         POP     A
   \   000031   F0           MOVX    @DPTR,A
   \   000032   0A           INC     R2
   \                     ??usbGetHIDDescriptor_0:
   \   000033   EA           MOV     A,R2
   \   000034   C3           CLR     C
   \   000035   9412         SUBB    A,#0x12
   \   000037   40D0         JC      ??usbGetHIDDescriptor_1
    249          
    250              usbClearOEP0ByteCount;
   \   000039   7400         MOV     A,#0x0
   \   00003B   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 3)
   \   00003E   F0           MOVX    @DPTR,A
    251              wBytesRemainingOnIEP0 = SIZEOF_KEYBD_HID_DESCRIPTOR;
   \   00003F   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000042   7409         MOV     A,#0x9
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   7400         MOV     A,#0x0
   \   000048   F0           MOVX    @DPTR,A
    252              usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
   \   000049                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   000049   7A..         MOV     R2,#(abDescriptor & 0xff)
   \   00004B   7B..         MOV     R3,#((abDescriptor >> 8) & 0xff)
   \   00004D   12....       LCALL   usbSendDataPacketOnEP0
    253          }
   \   000050   7F02         MOV     R7,#0x2
   \   000052   02....       LJMP    ?FUNC_LEAVE_XDATA
    254          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    255          void usbGetConfigurationDescriptor(void)
   \                     usbGetConfigurationDescriptor:
    256          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    257          	BYTE bTemp;
    258          	// Copy the DEVICE DESCRIPTOR from program "ROM" to XRAM
    259              for(bTemp=0;bTemp<SIZEOF_BOOTCODE_CONFIG_DESC_GROUP;bTemp++)
   \   000005   7A00         MOV     R2,#0x0
   \   000007   802A         SJMP    ??usbGetConfigurationDescriptor_0
    260                  abDescriptor[bTemp] = abromConfigurationDescriptorGroup[bTemp];
   \                     ??usbGetConfigurationDescriptor_1:
   \   000009   8A..         MOV     ?V0 + 0,R2
   \   00000B   75..00       MOV     ?V0 + 1,#0x0
   \   00000E   E5..         MOV     A,?V0 + 0
   \   000010   24..         ADD     A,#(abromConfigurationDescriptorGroup & 0xff)
   \   000012   F582         MOV     DPL,A
   \   000014   E5..         MOV     A,?V0 + 1
   \   000016   34..         ADDC    A,#((abromConfigurationDescriptorGroup >> 8) & 0xff)
   \   000018   F583         MOV     DPH,A
   \   00001A   E4           CLR     A
   \   00001B   93           MOVC    A,@A+DPTR
   \   00001C   C0E0         PUSH    A
   \   00001E   8A..         MOV     ?V0 + 0,R2
   \   000020   75..00       MOV     ?V0 + 1,#0x0
   \   000023   E5..         MOV     A,?V0 + 0
   \   000025   24..         ADD     A,#(abDescriptor & 0xff)
   \   000027   F582         MOV     DPL,A
   \   000029   E5..         MOV     A,?V0 + 1
   \   00002B   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   00002D   F583         MOV     DPH,A
   \   00002F   D0E0         POP     A
   \   000031   F0           MOVX    @DPTR,A
   \   000032   0A           INC     R2
   \                     ??usbGetConfigurationDescriptor_0:
   \   000033   EA           MOV     A,R2
   \   000034   C3           CLR     C
   \   000035   9422         SUBB    A,#0x22
   \   000037   40D0         JC      ??usbGetConfigurationDescriptor_1
    261          
    262              usbClearOEP0ByteCount;
   \   000039   7400         MOV     A,#0x0
   \   00003B   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 3)
   \   00003E   F0           MOVX    @DPTR,A
    263              wBytesRemainingOnIEP0 = SIZEOF_BOOTCODE_CONFIG_DESC_GROUP;
   \   00003F   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000042   7422         MOV     A,#0x22
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   7400         MOV     A,#0x0
   \   000048   F0           MOVX    @DPTR,A
    264              usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
   \   000049                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   000049   7A..         MOV     R2,#(abDescriptor & 0xff)
   \   00004B   7B..         MOV     R3,#((abDescriptor >> 8) & 0xff)
   \   00004D   12....       LCALL   usbSendDataPacketOnEP0
    265          }
   \   000050   7F02         MOV     R7,#0x2
   \   000052   02....       LJMP    ?FUNC_LEAVE_XDATA
    266          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    267          void usbGetStringDescriptor(void)
   \                     usbGetStringDescriptor:
    268          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    269          //    WORD bIndex;
    270             	BYTE bTemp;
    271             	BYTE stringOffset = 0;
   \   000005   7E00         MOV     R6,#0x0
    272          
    273              usbClearOEP0ByteCount;
   \   000007   7400         MOV     A,#0x0
   \   000009   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 3)
   \   00000C   F0           MOVX    @DPTR,A
    274          
    275          	switch(tSetupPacket.bValueL)
   \   00000D   90....       MOV     DPTR,#(tSetupPacket + 2)
   \   000010   E0           MOVX    A,@DPTR
   \   000011   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for usbGetStringDescriptor>_0`:
   \   000014   00           DB        0
   \   000015   03           DB        3
   \   000016   ....         DW        ??usbGetStringDescriptor_0
   \   000018   ....         DW        ??usbGetStringDescriptor_1
   \   00001A   ....         DW        ??usbGetStringDescriptor_2
   \   00001C   ....         DW        ??usbGetStringDescriptor_3
   \   00001E   ....         DW        ??usbGetStringDescriptor_4
    276          		{
    277          		case 0: // LANGUAGE ID
    278          			abDescriptor[0] = 4; // Length of language descriptor ID
   \                     ??usbGetStringDescriptor_1:
   \   000020   7404         MOV     A,#0x4
   \   000022   90....       MOV     DPTR,#abDescriptor
   \   000025   F0           MOVX    @DPTR,A
    279          			abDescriptor[1] = 3; // LANGID tag
   \   000026   7403         MOV     A,#0x3
   \   000028   90....       MOV     DPTR,#(abDescriptor + 1)
   \   00002B   F0           MOVX    @DPTR,A
    280          			abDescriptor[2] = 0x09; // Low byte of 0x0409 (English)
   \   00002C   7409         MOV     A,#0x9
   \   00002E   90....       MOV     DPTR,#(abDescriptor + 2)
   \   000031   F0           MOVX    @DPTR,A
    281          			abDescriptor[3] = 0x04; // High byte of 0x0409 (English)
   \   000032   7404         MOV     A,#0x4
   \   000034   90....       MOV     DPTR,#(abDescriptor + 3)
   \   000037   F0           MOVX    @DPTR,A
   \   000038   02....       LJMP    ??usbGetStringDescriptor_0
    282          			break;
    283          		case 1: // MANUFACTURER DESCRIPTION
    284          			abDescriptor[stringOffset++] = strlen(funcDefs[fncOffset].mfgDescription) * 2 + 2; // Length of this string
   \                     ??usbGetStringDescriptor_2:
   \   00003B   75F002       MOV     B,#0x2
   \   00003E   C0F0         PUSH    B
   \   000040                ; Setup parameters for call to function strlen
   \   000040   90....       MOV     DPTR,#fncOffset
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F8           MOV     R0,A
   \   000045   7900         MOV     R1,#0x0
   \   000047   E8           MOV     A,R0
   \   000048   75F011       MOV     B,#0x11
   \   00004B   A4           MUL     AB
   \   00004C   C8           XCH     A,R0
   \   00004D   AAF0         MOV     R2,B
   \   00004F   75F000       MOV     B,#0x0
   \   000052   A4           MUL     AB
   \   000053   2A           ADD     A,R2
   \   000054   FA           MOV     R2,A
   \   000055   75F011       MOV     B,#0x11
   \   000058   E9           MOV     A,R1
   \   000059   A4           MUL     AB
   \   00005A   2A           ADD     A,R2
   \   00005B   F9           MOV     R1,A
   \   00005C   E8           MOV     A,R0
   \   00005D   24..         ADD     A,#((funcDefs + 11) & 0xff)
   \   00005F   F582         MOV     DPL,A
   \   000061   E9           MOV     A,R1
   \   000062   34..         ADDC    A,#(((funcDefs + 11) >> 8) & 0xff)
   \   000064   F583         MOV     DPH,A
   \   000066   E4           CLR     A
   \   000067   93           MOVC    A,@A+DPTR
   \   000068   FA           MOV     R2,A
   \   000069   7401         MOV     A,#0x1
   \   00006B   93           MOVC    A,@A+DPTR
   \   00006C   FB           MOV     R3,A
   \   00006D   12....       LCALL   strlen
   \   000070   E9           MOV     A,R1
   \   000071   D0F0         POP     B
   \   000073   A4           MUL     AB
   \   000074   2402         ADD     A,#0x2
   \   000076   C0E0         PUSH    A
   \   000078   8E..         MOV     ?V0 + 0,R6
   \   00007A   75..00       MOV     ?V0 + 1,#0x0
   \   00007D   E5..         MOV     A,?V0 + 0
   \   00007F   24..         ADD     A,#(abDescriptor & 0xff)
   \   000081   F582         MOV     DPL,A
   \   000083   E5..         MOV     A,?V0 + 1
   \   000085   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   000087   F583         MOV     DPH,A
   \   000089   D0E0         POP     A
   \   00008B   F0           MOVX    @DPTR,A
   \   00008C   0E           INC     R6
    285          			abDescriptor[stringOffset++] = DESC_TYPE_STRING; // String descriptor type
   \   00008D   7403         MOV     A,#0x3
   \   00008F   C0E0         PUSH    A
   \   000091   8E..         MOV     ?V0 + 0,R6
   \   000093   75..00       MOV     ?V0 + 1,#0x0
   \   000096   E5..         MOV     A,?V0 + 0
   \   000098   24..         ADD     A,#(abDescriptor & 0xff)
   \   00009A   F582         MOV     DPL,A
   \   00009C   E5..         MOV     A,?V0 + 1
   \   00009E   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   0000A0   F583         MOV     DPH,A
   \   0000A2   D0E0         POP     A
   \   0000A4   F0           MOVX    @DPTR,A
   \   0000A5   0E           INC     R6
    286          			for(bTemp = 0; bTemp < strlen(funcDefs[fncOffset].mfgDescription);bTemp++)
   \   0000A6   7F00         MOV     R7,#0x0
   \   0000A8   8068         SJMP    ??usbGetStringDescriptor_5
    287          				{
    288          				abDescriptor[stringOffset++] = funcDefs[fncOffset].mfgDescription[bTemp]; // Insert the character from the string
   \                     ??usbGetStringDescriptor_6:
   \   0000AA   EF           MOV     A,R7
   \   0000AB   FA           MOV     R2,A
   \   0000AC   7B00         MOV     R3,#0x0
   \   0000AE   90....       MOV     DPTR,#fncOffset
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   F8           MOV     R0,A
   \   0000B3   7900         MOV     R1,#0x0
   \   0000B5   E8           MOV     A,R0
   \   0000B6   75F011       MOV     B,#0x11
   \   0000B9   A4           MUL     AB
   \   0000BA   C8           XCH     A,R0
   \   0000BB   ACF0         MOV     R4,B
   \   0000BD   75F000       MOV     B,#0x0
   \   0000C0   A4           MUL     AB
   \   0000C1   2C           ADD     A,R4
   \   0000C2   FC           MOV     R4,A
   \   0000C3   75F011       MOV     B,#0x11
   \   0000C6   E9           MOV     A,R1
   \   0000C7   A4           MUL     AB
   \   0000C8   2C           ADD     A,R4
   \   0000C9   F9           MOV     R1,A
   \   0000CA   E8           MOV     A,R0
   \   0000CB   24..         ADD     A,#((funcDefs + 11) & 0xff)
   \   0000CD   F582         MOV     DPL,A
   \   0000CF   E9           MOV     A,R1
   \   0000D0   34..         ADDC    A,#(((funcDefs + 11) >> 8) & 0xff)
   \   0000D2   F583         MOV     DPH,A
   \   0000D4   E4           CLR     A
   \   0000D5   93           MOVC    A,@A+DPTR
   \   0000D6   2A           ADD     A,R2
   \   0000D7   FC           MOV     R4,A
   \   0000D8   A3           INC     DPTR
   \   0000D9   E4           CLR     A
   \   0000DA   93           MOVC    A,@A+DPTR
   \   0000DB   3B           ADDC    A,R3
   \   0000DC   8C82         MOV     DPL,R4
   \   0000DE   F583         MOV     DPH,A
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   C0E0         PUSH    A
   \   0000E3   8E..         MOV     ?V0 + 0,R6
   \   0000E5   75..00       MOV     ?V0 + 1,#0x0
   \   0000E8   E5..         MOV     A,?V0 + 0
   \   0000EA   24..         ADD     A,#(abDescriptor & 0xff)
   \   0000EC   F582         MOV     DPL,A
   \   0000EE   E5..         MOV     A,?V0 + 1
   \   0000F0   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   0000F2   F583         MOV     DPH,A
   \   0000F4   D0E0         POP     A
   \   0000F6   F0           MOVX    @DPTR,A
   \   0000F7   0E           INC     R6
    289          				abDescriptor[stringOffset++] = 0x00; // Insert a trailing 00h for Unicode representation
   \   0000F8   7400         MOV     A,#0x0
   \   0000FA   C0E0         PUSH    A
   \   0000FC   8E..         MOV     ?V0 + 0,R6
   \   0000FE   75..00       MOV     ?V0 + 1,#0x0
   \   000101   E5..         MOV     A,?V0 + 0
   \   000103   24..         ADD     A,#(abDescriptor & 0xff)
   \   000105   F582         MOV     DPL,A
   \   000107   E5..         MOV     A,?V0 + 1
   \   000109   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   00010B   F583         MOV     DPH,A
   \   00010D   D0E0         POP     A
   \   00010F   F0           MOVX    @DPTR,A
   \   000110   0E           INC     R6
    290          				}
   \   000111   0F           INC     R7
   \                     ??usbGetStringDescriptor_5:
   \   000112   EF           MOV     A,R7
   \   000113   C0E0         PUSH    A
   \   000115                ; Setup parameters for call to function strlen
   \   000115   90....       MOV     DPTR,#fncOffset
   \   000118   E0           MOVX    A,@DPTR
   \   000119   F8           MOV     R0,A
   \   00011A   7900         MOV     R1,#0x0
   \   00011C   E8           MOV     A,R0
   \   00011D   75F011       MOV     B,#0x11
   \   000120   A4           MUL     AB
   \   000121   C8           XCH     A,R0
   \   000122   AAF0         MOV     R2,B
   \   000124   75F000       MOV     B,#0x0
   \   000127   A4           MUL     AB
   \   000128   2A           ADD     A,R2
   \   000129   FA           MOV     R2,A
   \   00012A   75F011       MOV     B,#0x11
   \   00012D   E9           MOV     A,R1
   \   00012E   A4           MUL     AB
   \   00012F   2A           ADD     A,R2
   \   000130   F9           MOV     R1,A
   \   000131   E8           MOV     A,R0
   \   000132   24..         ADD     A,#((funcDefs + 11) & 0xff)
   \   000134   F582         MOV     DPL,A
   \   000136   E9           MOV     A,R1
   \   000137   34..         ADDC    A,#(((funcDefs + 11) >> 8) & 0xff)
   \   000139   F583         MOV     DPH,A
   \   00013B   E4           CLR     A
   \   00013C   93           MOVC    A,@A+DPTR
   \   00013D   FA           MOV     R2,A
   \   00013E   7401         MOV     A,#0x1
   \   000140   93           MOVC    A,@A+DPTR
   \   000141   FB           MOV     R3,A
   \   000142   12....       LCALL   strlen
   \   000145   E9           MOV     A,R1
   \   000146   FA           MOV     R2,A
   \   000147   D0E0         POP     A
   \   000149   C3           CLR     C
   \   00014A   9A           SUBB    A,R2
   \   00014B   5003         JNC     $+5
   \   00014D   02....       LJMP    ??usbGetStringDescriptor_6
   \   000150   02....       LJMP    ??usbGetStringDescriptor_0
    291          			break;
    292          		case 2: // PRODUCT DESCRIPTION
    293          			abDescriptor[stringOffset++] = strlen(funcDefs[fncOffset].prodDescription) * 2 + 2;  // Length of this string
   \                     ??usbGetStringDescriptor_3:
   \   000153   75F002       MOV     B,#0x2
   \   000156   C0F0         PUSH    B
   \   000158                ; Setup parameters for call to function strlen
   \   000158   90....       MOV     DPTR,#fncOffset
   \   00015B   E0           MOVX    A,@DPTR
   \   00015C   F8           MOV     R0,A
   \   00015D   7900         MOV     R1,#0x0
   \   00015F   E8           MOV     A,R0
   \   000160   75F011       MOV     B,#0x11
   \   000163   A4           MUL     AB
   \   000164   C8           XCH     A,R0
   \   000165   AAF0         MOV     R2,B
   \   000167   75F000       MOV     B,#0x0
   \   00016A   A4           MUL     AB
   \   00016B   2A           ADD     A,R2
   \   00016C   FA           MOV     R2,A
   \   00016D   75F011       MOV     B,#0x11
   \   000170   E9           MOV     A,R1
   \   000171   A4           MUL     AB
   \   000172   2A           ADD     A,R2
   \   000173   F9           MOV     R1,A
   \   000174   E8           MOV     A,R0
   \   000175   24..         ADD     A,#((funcDefs + 13) & 0xff)
   \   000177   F582         MOV     DPL,A
   \   000179   E9           MOV     A,R1
   \   00017A   34..         ADDC    A,#(((funcDefs + 13) >> 8) & 0xff)
   \   00017C   F583         MOV     DPH,A
   \   00017E   E4           CLR     A
   \   00017F   93           MOVC    A,@A+DPTR
   \   000180   FA           MOV     R2,A
   \   000181   7401         MOV     A,#0x1
   \   000183   93           MOVC    A,@A+DPTR
   \   000184   FB           MOV     R3,A
   \   000185   12....       LCALL   strlen
   \   000188   E9           MOV     A,R1
   \   000189   D0F0         POP     B
   \   00018B   A4           MUL     AB
   \   00018C   2402         ADD     A,#0x2
   \   00018E   C0E0         PUSH    A
   \   000190   8E..         MOV     ?V0 + 0,R6
   \   000192   75..00       MOV     ?V0 + 1,#0x0
   \   000195   E5..         MOV     A,?V0 + 0
   \   000197   24..         ADD     A,#(abDescriptor & 0xff)
   \   000199   F582         MOV     DPL,A
   \   00019B   E5..         MOV     A,?V0 + 1
   \   00019D   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   00019F   F583         MOV     DPH,A
   \   0001A1   D0E0         POP     A
   \   0001A3   F0           MOVX    @DPTR,A
   \   0001A4   0E           INC     R6
    294          			abDescriptor[stringOffset++] = DESC_TYPE_STRING; // String descriptor type
   \   0001A5   7403         MOV     A,#0x3
   \   0001A7   C0E0         PUSH    A
   \   0001A9   8E..         MOV     ?V0 + 0,R6
   \   0001AB   75..00       MOV     ?V0 + 1,#0x0
   \   0001AE   E5..         MOV     A,?V0 + 0
   \   0001B0   24..         ADD     A,#(abDescriptor & 0xff)
   \   0001B2   F582         MOV     DPL,A
   \   0001B4   E5..         MOV     A,?V0 + 1
   \   0001B6   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   0001B8   F583         MOV     DPH,A
   \   0001BA   D0E0         POP     A
   \   0001BC   F0           MOVX    @DPTR,A
   \   0001BD   0E           INC     R6
    295          			for(bTemp = 0; bTemp < strlen(funcDefs[fncOffset].prodDescription);bTemp++)
   \   0001BE   7F00         MOV     R7,#0x0
   \   0001C0   8068         SJMP    ??usbGetStringDescriptor_7
    296          				{
    297          				abDescriptor[stringOffset++] = funcDefs[fncOffset].prodDescription[bTemp]; // Insert the character from the string
   \                     ??usbGetStringDescriptor_8:
   \   0001C2   EF           MOV     A,R7
   \   0001C3   FA           MOV     R2,A
   \   0001C4   7B00         MOV     R3,#0x0
   \   0001C6   90....       MOV     DPTR,#fncOffset
   \   0001C9   E0           MOVX    A,@DPTR
   \   0001CA   F8           MOV     R0,A
   \   0001CB   7900         MOV     R1,#0x0
   \   0001CD   E8           MOV     A,R0
   \   0001CE   75F011       MOV     B,#0x11
   \   0001D1   A4           MUL     AB
   \   0001D2   C8           XCH     A,R0
   \   0001D3   ACF0         MOV     R4,B
   \   0001D5   75F000       MOV     B,#0x0
   \   0001D8   A4           MUL     AB
   \   0001D9   2C           ADD     A,R4
   \   0001DA   FC           MOV     R4,A
   \   0001DB   75F011       MOV     B,#0x11
   \   0001DE   E9           MOV     A,R1
   \   0001DF   A4           MUL     AB
   \   0001E0   2C           ADD     A,R4
   \   0001E1   F9           MOV     R1,A
   \   0001E2   E8           MOV     A,R0
   \   0001E3   24..         ADD     A,#((funcDefs + 13) & 0xff)
   \   0001E5   F582         MOV     DPL,A
   \   0001E7   E9           MOV     A,R1
   \   0001E8   34..         ADDC    A,#(((funcDefs + 13) >> 8) & 0xff)
   \   0001EA   F583         MOV     DPH,A
   \   0001EC   E4           CLR     A
   \   0001ED   93           MOVC    A,@A+DPTR
   \   0001EE   2A           ADD     A,R2
   \   0001EF   FC           MOV     R4,A
   \   0001F0   A3           INC     DPTR
   \   0001F1   E4           CLR     A
   \   0001F2   93           MOVC    A,@A+DPTR
   \   0001F3   3B           ADDC    A,R3
   \   0001F4   8C82         MOV     DPL,R4
   \   0001F6   F583         MOV     DPH,A
   \   0001F8   E0           MOVX    A,@DPTR
   \   0001F9   C0E0         PUSH    A
   \   0001FB   8E..         MOV     ?V0 + 0,R6
   \   0001FD   75..00       MOV     ?V0 + 1,#0x0
   \   000200   E5..         MOV     A,?V0 + 0
   \   000202   24..         ADD     A,#(abDescriptor & 0xff)
   \   000204   F582         MOV     DPL,A
   \   000206   E5..         MOV     A,?V0 + 1
   \   000208   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   00020A   F583         MOV     DPH,A
   \   00020C   D0E0         POP     A
   \   00020E   F0           MOVX    @DPTR,A
   \   00020F   0E           INC     R6
    298          				abDescriptor[stringOffset++] = 0x00; // Insert a trailing 00h for Unicode representation
   \   000210   7400         MOV     A,#0x0
   \   000212   C0E0         PUSH    A
   \   000214   8E..         MOV     ?V0 + 0,R6
   \   000216   75..00       MOV     ?V0 + 1,#0x0
   \   000219   E5..         MOV     A,?V0 + 0
   \   00021B   24..         ADD     A,#(abDescriptor & 0xff)
   \   00021D   F582         MOV     DPL,A
   \   00021F   E5..         MOV     A,?V0 + 1
   \   000221   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   000223   F583         MOV     DPH,A
   \   000225   D0E0         POP     A
   \   000227   F0           MOVX    @DPTR,A
   \   000228   0E           INC     R6
    299          				}
   \   000229   0F           INC     R7
   \                     ??usbGetStringDescriptor_7:
   \   00022A   EF           MOV     A,R7
   \   00022B   C0E0         PUSH    A
   \   00022D                ; Setup parameters for call to function strlen
   \   00022D   90....       MOV     DPTR,#fncOffset
   \   000230   E0           MOVX    A,@DPTR
   \   000231   F8           MOV     R0,A
   \   000232   7900         MOV     R1,#0x0
   \   000234   E8           MOV     A,R0
   \   000235   75F011       MOV     B,#0x11
   \   000238   A4           MUL     AB
   \   000239   C8           XCH     A,R0
   \   00023A   AAF0         MOV     R2,B
   \   00023C   75F000       MOV     B,#0x0
   \   00023F   A4           MUL     AB
   \   000240   2A           ADD     A,R2
   \   000241   FA           MOV     R2,A
   \   000242   75F011       MOV     B,#0x11
   \   000245   E9           MOV     A,R1
   \   000246   A4           MUL     AB
   \   000247   2A           ADD     A,R2
   \   000248   F9           MOV     R1,A
   \   000249   E8           MOV     A,R0
   \   00024A   24..         ADD     A,#((funcDefs + 13) & 0xff)
   \   00024C   F582         MOV     DPL,A
   \   00024E   E9           MOV     A,R1
   \   00024F   34..         ADDC    A,#(((funcDefs + 13) >> 8) & 0xff)
   \   000251   F583         MOV     DPH,A
   \   000253   E4           CLR     A
   \   000254   93           MOVC    A,@A+DPTR
   \   000255   FA           MOV     R2,A
   \   000256   7401         MOV     A,#0x1
   \   000258   93           MOVC    A,@A+DPTR
   \   000259   FB           MOV     R3,A
   \   00025A   12....       LCALL   strlen
   \   00025D   E9           MOV     A,R1
   \   00025E   FA           MOV     R2,A
   \   00025F   D0E0         POP     A
   \   000261   C3           CLR     C
   \   000262   9A           SUBB    A,R2
   \   000263   5003         JNC     $+5
   \   000265   02....       LJMP    ??usbGetStringDescriptor_8
   \   000268   02....       LJMP    ??usbGetStringDescriptor_0
    300          			break;
    301          		case 3: // SERIAL NUMBER
    302          			abDescriptor[stringOffset++] = strlen(funcDefs[fncOffset].serialNumber) * 2 + 2;  // Length of this string
   \                     ??usbGetStringDescriptor_4:
   \   00026B   75F002       MOV     B,#0x2
   \   00026E   C0F0         PUSH    B
   \   000270                ; Setup parameters for call to function strlen
   \   000270   90....       MOV     DPTR,#fncOffset
   \   000273   E0           MOVX    A,@DPTR
   \   000274   F8           MOV     R0,A
   \   000275   7900         MOV     R1,#0x0
   \   000277   E8           MOV     A,R0
   \   000278   75F011       MOV     B,#0x11
   \   00027B   A4           MUL     AB
   \   00027C   C8           XCH     A,R0
   \   00027D   AAF0         MOV     R2,B
   \   00027F   75F000       MOV     B,#0x0
   \   000282   A4           MUL     AB
   \   000283   2A           ADD     A,R2
   \   000284   FA           MOV     R2,A
   \   000285   75F011       MOV     B,#0x11
   \   000288   E9           MOV     A,R1
   \   000289   A4           MUL     AB
   \   00028A   2A           ADD     A,R2
   \   00028B   F9           MOV     R1,A
   \   00028C   E8           MOV     A,R0
   \   00028D   24..         ADD     A,#((funcDefs + 15) & 0xff)
   \   00028F   F582         MOV     DPL,A
   \   000291   E9           MOV     A,R1
   \   000292   34..         ADDC    A,#(((funcDefs + 15) >> 8) & 0xff)
   \   000294   F583         MOV     DPH,A
   \   000296   E4           CLR     A
   \   000297   93           MOVC    A,@A+DPTR
   \   000298   FA           MOV     R2,A
   \   000299   7401         MOV     A,#0x1
   \   00029B   93           MOVC    A,@A+DPTR
   \   00029C   FB           MOV     R3,A
   \   00029D   12....       LCALL   strlen
   \   0002A0   E9           MOV     A,R1
   \   0002A1   D0F0         POP     B
   \   0002A3   A4           MUL     AB
   \   0002A4   2402         ADD     A,#0x2
   \   0002A6   C0E0         PUSH    A
   \   0002A8   8E..         MOV     ?V0 + 0,R6
   \   0002AA   75..00       MOV     ?V0 + 1,#0x0
   \   0002AD   E5..         MOV     A,?V0 + 0
   \   0002AF   24..         ADD     A,#(abDescriptor & 0xff)
   \   0002B1   F582         MOV     DPL,A
   \   0002B3   E5..         MOV     A,?V0 + 1
   \   0002B5   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   0002B7   F583         MOV     DPH,A
   \   0002B9   D0E0         POP     A
   \   0002BB   F0           MOVX    @DPTR,A
   \   0002BC   0E           INC     R6
    303          			abDescriptor[stringOffset++] = DESC_TYPE_STRING; // String descriptor type
   \   0002BD   7403         MOV     A,#0x3
   \   0002BF   C0E0         PUSH    A
   \   0002C1   8E..         MOV     ?V0 + 0,R6
   \   0002C3   75..00       MOV     ?V0 + 1,#0x0
   \   0002C6   E5..         MOV     A,?V0 + 0
   \   0002C8   24..         ADD     A,#(abDescriptor & 0xff)
   \   0002CA   F582         MOV     DPL,A
   \   0002CC   E5..         MOV     A,?V0 + 1
   \   0002CE   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   0002D0   F583         MOV     DPH,A
   \   0002D2   D0E0         POP     A
   \   0002D4   F0           MOVX    @DPTR,A
   \   0002D5   0E           INC     R6
    304          			for(bTemp = 0; bTemp < strlen(funcDefs[fncOffset].serialNumber);bTemp++)
   \   0002D6   7F00         MOV     R7,#0x0
   \   0002D8   8068         SJMP    ??usbGetStringDescriptor_9
    305          				{
    306          				abDescriptor[stringOffset++] = funcDefs[fncOffset].serialNumber[bTemp]; // Insert the character from the string	
   \                     ??usbGetStringDescriptor_10:
   \   0002DA   EF           MOV     A,R7
   \   0002DB   FA           MOV     R2,A
   \   0002DC   7B00         MOV     R3,#0x0
   \   0002DE   90....       MOV     DPTR,#fncOffset
   \   0002E1   E0           MOVX    A,@DPTR
   \   0002E2   F8           MOV     R0,A
   \   0002E3   7900         MOV     R1,#0x0
   \   0002E5   E8           MOV     A,R0
   \   0002E6   75F011       MOV     B,#0x11
   \   0002E9   A4           MUL     AB
   \   0002EA   C8           XCH     A,R0
   \   0002EB   ACF0         MOV     R4,B
   \   0002ED   75F000       MOV     B,#0x0
   \   0002F0   A4           MUL     AB
   \   0002F1   2C           ADD     A,R4
   \   0002F2   FC           MOV     R4,A
   \   0002F3   75F011       MOV     B,#0x11
   \   0002F6   E9           MOV     A,R1
   \   0002F7   A4           MUL     AB
   \   0002F8   2C           ADD     A,R4
   \   0002F9   F9           MOV     R1,A
   \   0002FA   E8           MOV     A,R0
   \   0002FB   24..         ADD     A,#((funcDefs + 15) & 0xff)
   \   0002FD   F582         MOV     DPL,A
   \   0002FF   E9           MOV     A,R1
   \   000300   34..         ADDC    A,#(((funcDefs + 15) >> 8) & 0xff)
   \   000302   F583         MOV     DPH,A
   \   000304   E4           CLR     A
   \   000305   93           MOVC    A,@A+DPTR
   \   000306   2A           ADD     A,R2
   \   000307   FC           MOV     R4,A
   \   000308   A3           INC     DPTR
   \   000309   E4           CLR     A
   \   00030A   93           MOVC    A,@A+DPTR
   \   00030B   3B           ADDC    A,R3
   \   00030C   8C82         MOV     DPL,R4
   \   00030E   F583         MOV     DPH,A
   \   000310   E0           MOVX    A,@DPTR
   \   000311   C0E0         PUSH    A
   \   000313   8E..         MOV     ?V0 + 0,R6
   \   000315   75..00       MOV     ?V0 + 1,#0x0
   \   000318   E5..         MOV     A,?V0 + 0
   \   00031A   24..         ADD     A,#(abDescriptor & 0xff)
   \   00031C   F582         MOV     DPL,A
   \   00031E   E5..         MOV     A,?V0 + 1
   \   000320   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   000322   F583         MOV     DPH,A
   \   000324   D0E0         POP     A
   \   000326   F0           MOVX    @DPTR,A
   \   000327   0E           INC     R6
    307          				abDescriptor[stringOffset++] = 0x00; // Insert a trailing 00h for Unicode representation
   \   000328   7400         MOV     A,#0x0
   \   00032A   C0E0         PUSH    A
   \   00032C   8E..         MOV     ?V0 + 0,R6
   \   00032E   75..00       MOV     ?V0 + 1,#0x0
   \   000331   E5..         MOV     A,?V0 + 0
   \   000333   24..         ADD     A,#(abDescriptor & 0xff)
   \   000335   F582         MOV     DPL,A
   \   000337   E5..         MOV     A,?V0 + 1
   \   000339   34..         ADDC    A,#((abDescriptor >> 8) & 0xff)
   \   00033B   F583         MOV     DPH,A
   \   00033D   D0E0         POP     A
   \   00033F   F0           MOVX    @DPTR,A
   \   000340   0E           INC     R6
    308          				}
   \   000341   0F           INC     R7
   \                     ??usbGetStringDescriptor_9:
   \   000342   EF           MOV     A,R7
   \   000343   C0E0         PUSH    A
   \   000345                ; Setup parameters for call to function strlen
   \   000345   90....       MOV     DPTR,#fncOffset
   \   000348   E0           MOVX    A,@DPTR
   \   000349   F8           MOV     R0,A
   \   00034A   7900         MOV     R1,#0x0
   \   00034C   E8           MOV     A,R0
   \   00034D   75F011       MOV     B,#0x11
   \   000350   A4           MUL     AB
   \   000351   C8           XCH     A,R0
   \   000352   AAF0         MOV     R2,B
   \   000354   75F000       MOV     B,#0x0
   \   000357   A4           MUL     AB
   \   000358   2A           ADD     A,R2
   \   000359   FA           MOV     R2,A
   \   00035A   75F011       MOV     B,#0x11
   \   00035D   E9           MOV     A,R1
   \   00035E   A4           MUL     AB
   \   00035F   2A           ADD     A,R2
   \   000360   F9           MOV     R1,A
   \   000361   E8           MOV     A,R0
   \   000362   24..         ADD     A,#((funcDefs + 15) & 0xff)
   \   000364   F582         MOV     DPL,A
   \   000366   E9           MOV     A,R1
   \   000367   34..         ADDC    A,#(((funcDefs + 15) >> 8) & 0xff)
   \   000369   F583         MOV     DPH,A
   \   00036B   E4           CLR     A
   \   00036C   93           MOVC    A,@A+DPTR
   \   00036D   FA           MOV     R2,A
   \   00036E   7401         MOV     A,#0x1
   \   000370   93           MOVC    A,@A+DPTR
   \   000371   FB           MOV     R3,A
   \   000372   12....       LCALL   strlen
   \   000375   E9           MOV     A,R1
   \   000376   FA           MOV     R2,A
   \   000377   D0E0         POP     A
   \   000379   C3           CLR     C
   \   00037A   9A           SUBB    A,R2
   \   00037B   5003         JNC     $+5
   \   00037D   02....       LJMP    ??usbGetStringDescriptor_10
    309          			break;
    310          		default:
    311          				break;
    312          		}
    313          
    314          #ifdef XX
    315              bIndex = 0x00;
    316              while(tSetupPacket.bValueL-- >  0x00) 
    317              	bIndex += abStringDescriptor[bIndex];
    318          
    319          	// Copy the STRING DESCRIPTOR from program "ROM" to XRAM
    320          	bStrLen = 
    321              for(bTemp=0;bTemp<SIZEOF_BOOTCODE_CONFIG_DESC_GROUP;bTemp++)
    322                  abDescriptor[bTemp] = abromConfigurationDescriptorGroup[bTemp];
    323          #endif    	
    324              wBytesRemainingOnIEP0 = abDescriptor[0];
   \                     ??usbGetStringDescriptor_0:
   \   000380   90....       MOV     DPTR,#abDescriptor
   \   000383   E0           MOVX    A,@DPTR
   \   000384   7900         MOV     R1,#0x0
   \   000386   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000389   F0           MOVX    @DPTR,A
   \   00038A   A3           INC     DPTR
   \   00038B   E9           MOV     A,R1
   \   00038C   F0           MOVX    @DPTR,A
    325              usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
   \   00038D                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   00038D   7A..         MOV     R2,#(abDescriptor & 0xff)
   \   00038F   7B..         MOV     R3,#((abDescriptor >> 8) & 0xff)
   \   000391   12....       LCALL   usbSendDataPacketOnEP0
    326          }
   \   000394   7F02         MOV     R7,#0x2
   \   000396   02....       LJMP    ?FUNC_LEAVE_XDATA
    327          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    328          void usbGetReportDescriptor(void)
   \                     usbGetReportDescriptor:
    329          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    330              usbClearOEP0ByteCount;
   \   000004   7400         MOV     A,#0x0
   \   000006   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 3)
   \   000009   F0           MOVX    @DPTR,A
    331              wBytesRemainingOnIEP0 = SIZEOF_REPORT_DESCRIPTOR;
   \   00000A   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   00000D   743F         MOV     A,#0x3f
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   7400         MOV     A,#0x0
   \   000013   F0           MOVX    @DPTR,A
    332              usbSendDataPacketOnEP0((PBYTE)&abromReportDescriptor);
   \   000014                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   000014   7A..         MOV     R2,#(abromReportDescriptor & 0xff)
   \   000016   7B..         MOV     R3,#((abromReportDescriptor >> 8) & 0xff)
   \   000018   12....       LCALL   usbSendDataPacketOnEP0
    333          }
   \   00001B   D083         POP     DPH
   \   00001D   D082         POP     DPL
   \   00001F   22           RET
    334          
    335          // Support of the following two functions is optional.  Supporting these
    336          // features allows the host to set the Idle rate.  By default, an HID
    337          // device should always report the current status of the keys, even
    338          // if they haven't changed.  However, to save bandwidth, Windows will
    339          // attempt to set the Idle rate to 0 which means the firmware should
    340          // only report keypresses when their state changes.
    341          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    342          BYTE gbIdleRateL;
   \                     gbIdleRateL:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    343          BYTE gbIdleRateH;
   \                     gbIdleRateH:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    344          void usbSetIdle(void)
   \                     usbSetIdle:
    345          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    346          //    usbStallOEP0;
    347              gbIdleRateL = tSetupPacket.bValueL;
   \   000004   90....       MOV     DPTR,#(tSetupPacket + 2)
   \   000007   E0           MOVX    A,@DPTR
   \   000008   90....       MOV     DPTR,#gbIdleRateL
   \   00000B   F0           MOVX    @DPTR,A
    348              gbIdleRateH = tSetupPacket.bValueH;
   \   00000C   90....       MOV     DPTR,#(tSetupPacket + 3)
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   90....       MOV     DPTR,#gbIdleRateH
   \   000013   F0           MOVX    @DPTR,A
    349              usbSendZeroLengthPacketOnIEP0();
   \   000014                ; Setup parameters for call to function usbSendZeroLengthPacketOnIEP0
   \   000014   12....       LCALL   usbSendZeroLengthPacketOnIEP0
    350          }
   \   000017   D083         POP     DPH
   \   000019   D082         POP     DPL
   \   00001B   22           RET
    351          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    352          void usbGetIdle(void)
   \                     usbGetIdle:
    353          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    354              wBytesRemainingOnIEP0 = 1;
   \   000004   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000007   7401         MOV     A,#0x1
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   7400         MOV     A,#0x0
   \   00000D   F0           MOVX    @DPTR,A
    355              usbSendDataPacketOnEP0(&gbIdleRateH);
   \   00000E                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   00000E   7A..         MOV     R2,#(gbIdleRateH & 0xff)
   \   000010   7B..         MOV     R3,#((gbIdleRateH >> 8) & 0xff)
   \   000012   12....       LCALL   usbSendDataPacketOnEP0
    356          }
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   22           RET
    357          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    358          BYTE gbProtocol=1; // default is report protocol
   \                     gbProtocol:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for gbProtocol>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    359          void usbSetProtocol(void)
   \                     usbSetProtocol:
    360          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    361          //    usbStallOEP0;
    362              gbProtocol = tSetupPacket.bValueL;
   \   000004   90....       MOV     DPTR,#(tSetupPacket + 2)
   \   000007   E0           MOVX    A,@DPTR
   \   000008   90....       MOV     DPTR,#gbProtocol
   \   00000B   F0           MOVX    @DPTR,A
    363              usbSendZeroLengthPacketOnIEP0();
   \   00000C                ; Setup parameters for call to function usbSendZeroLengthPacketOnIEP0
   \   00000C   12....       LCALL   usbSendZeroLengthPacketOnIEP0
    364          }
   \   00000F   D083         POP     DPH
   \   000011   D082         POP     DPL
   \   000013   22           RET
    365          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    366          void usbGetProtocol(void)
   \                     usbGetProtocol:
    367          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    368              wBytesRemainingOnIEP0 = 1;
   \   000004   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000007   7401         MOV     A,#0x1
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   7400         MOV     A,#0x0
   \   00000D   F0           MOVX    @DPTR,A
    369              usbSendDataPacketOnEP0(&gbProtocol);
   \   00000E                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   00000E   7A..         MOV     R2,#(gbProtocol & 0xff)
   \   000010   7B..         MOV     R3,#((gbProtocol >> 8) & 0xff)
   \   000012   12....       LCALL   usbSendDataPacketOnEP0
    370          }
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   22           RET
    371          
    372          // The Get/Set Interface, like the Get/Set Configuration, don't really
    373          // serve any real purpose in this firmware, but they are handled so
    374          // that modifications to the code may be made easily.  As-is, the host
    375          // may Set any interface number, and a Get Interface request will simply
    376          // return the value previously Set.
    377          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    378          void usbGetInterface(void)
   \                     usbGetInterface:
    379          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    380              wBytesRemainingOnIEP0 = 1;
   \   000004   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000007   7401         MOV     A,#0x1
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   7400         MOV     A,#0x0
   \   00000D   F0           MOVX    @DPTR,A
    381              usbSendDataPacketOnEP0((PBYTE) &bInterfaceNumber);
   \   00000E                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   00000E   7A..         MOV     R2,#(bInterfaceNumber & 0xff)
   \   000010   7B..         MOV     R3,#((bInterfaceNumber >> 8) & 0xff)
   \   000012   12....       LCALL   usbSendDataPacketOnEP0
    382          }
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   22           RET
    383          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    384          void usbSetInterface(void)
   \                     usbSetInterface:
    385          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    386              usbStallOEP0;                             // control write without data stage
   \   000004   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 2)
   \   000007   E0           MOVX    A,@DPTR
   \   000008   D2E3         SETB    0xE0 /* A   */.3
   \   00000A   F0           MOVX    @DPTR,A
    387              bInterfaceNumber = tSetupPacket.bIndexL;
   \   00000B   90....       MOV     DPTR,#(tSetupPacket + 4)
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   90....       MOV     DPTR,#bInterfaceNumber
   \   000012   F0           MOVX    @DPTR,A
    388              usbSendZeroLengthPacketOnIEP0();
   \   000013                ; Setup parameters for call to function usbSendZeroLengthPacketOnIEP0
   \   000013   12....       LCALL   usbSendZeroLengthPacketOnIEP0
    389          }
   \   000016   D083         POP     DPH
   \   000018   D082         POP     DPL
   \   00001A   22           RET
    390          
    391          // The GetDeviceStatus function is used to obtain the status of the
    392          // device.  The status is essentially the Remote Wakeup status as 
    393          // well as the "Self-powered" indicator.  The value returned by
    394          // GetDeviceStatus is modified by the SetRemoteWakeup and
    395          // ClearRemoteWakeup requests.
    396          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    397          void usbGetDeviceStatus(void)
   \                     usbGetDeviceStatus:
    398          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    399              wBytesRemainingOnIEP0 = 2;
   \   000004   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000007   7402         MOV     A,#0x2
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   7400         MOV     A,#0x0
   \   00000D   F0           MOVX    @DPTR,A
    400          	usbSendDataPacketOnEP0((PBYTE) &wDeviceFeatures);
   \   00000E                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   00000E   7A..         MOV     R2,#(wDeviceFeatures & 0xff)
   \   000010   7B..         MOV     R3,#((wDeviceFeatures >> 8) & 0xff)
   \   000012   12....       LCALL   usbSendDataPacketOnEP0
    401          }
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   22           RET
    402          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    403          void usbSetRemoteWakeup(void)
   \                     usbSetRemoteWakeup:
    404          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    405          	bUSBCTL |= USBCTL_RWE;
   \   000004   90FFFC       MOV     DPTR,#-0x4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   D2E3         SETB    0xE0 /* A   */.3
   \   00000A   F0           MOVX    @DPTR,A
    406          	wDeviceFeatures |= 0x0200;
   \   00000B   90....       MOV     DPTR,#wDeviceFeatures
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   4400         ORL     A,#0x0
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   4402         ORL     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
    407              usbStallOEP0;
   \   000017   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 2)
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   D2E3         SETB    0xE0 /* A   */.3
   \   00001D   F0           MOVX    @DPTR,A
    408              usbSendZeroLengthPacketOnIEP0();
   \   00001E                ; Setup parameters for call to function usbSendZeroLengthPacketOnIEP0
   \   00001E   12....       LCALL   usbSendZeroLengthPacketOnIEP0
    409          }
   \   000021   D083         POP     DPH
   \   000023   D082         POP     DPL
   \   000025   22           RET
    410          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    411          void usbClearRemoteWakeup(void)
   \                     usbClearRemoteWakeup:
    412          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    413          	bUSBCTL &= ~USBCTL_RWE;
   \   000004   90FFFC       MOV     DPTR,#-0x4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C2E3         CLR     0xE0 /* A   */.3
   \   00000A   F0           MOVX    @DPTR,A
    414          	wDeviceFeatures &= ~0x0200;
   \   00000B   90....       MOV     DPTR,#wDeviceFeatures
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   54FF         ANL     A,#0xff
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   54FD         ANL     A,#0xfd
   \   000016   F0           MOVX    @DPTR,A
    415              usbStallOEP0;
   \   000017   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 2)
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   D2E3         SETB    0xE0 /* A   */.3
   \   00001D   F0           MOVX    @DPTR,A
    416              usbSendZeroLengthPacketOnIEP0();
   \   00001E                ; Setup parameters for call to function usbSendZeroLengthPacketOnIEP0
   \   00001E   12....       LCALL   usbSendZeroLengthPacketOnIEP0
    417          }
   \   000021   D083         POP     DPH
   \   000023   D082         POP     DPL
   \   000025   22           RET
    418          
    419          // The GetInterfaceStatus always returns a 0 as a 2-byte value.
    420          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    421          void usbGetInterfaceStatus(void)
   \                     usbGetInterfaceStatus:
    422          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    423          	WORD wStatusBuffer = 0x00;    	
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   7400         MOV     A,#0x0
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   7400         MOV     A,#0x0
   \   000015   F0           MOVX    @DPTR,A
    424              usbStallOEP0;
   \   000016   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 2)
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   D2E3         SETB    0xE0 /* A   */.3
   \   00001C   F0           MOVX    @DPTR,A
    425              wBytesRemainingOnIEP0 = 2;
   \   00001D   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000020   7402         MOV     A,#0x2
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   7400         MOV     A,#0x0
   \   000026   F0           MOVX    @DPTR,A
    426          	usbSendDataPacketOnEP0((PBYTE) &wStatusBuffer);
   \   000027                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   AA82         MOV     R2,DPL
   \   00002F   AB83         MOV     R3,DPH
   \   000031   12....       LCALL   usbSendDataPacketOnEP0
    427          }
   \   000034   7402         MOV     A,#0x2
   \   000036   12....       LCALL   ?DEALLOC_XSTACK8
   \   000039   D083         POP     DPH
   \   00003B   D082         POP     DPL
   \   00003D   22           RET
    428          
    429          // The SetAddress request allows the host to assign an address to this device.
    430          // The device starts with an address of 00h, as do all USB devices, until
    431          // the host specifically assigns it another address.  This code handles that
    432          // assignment.
    433          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    434          void usbSetAddress(void)
   \                     usbSetAddress:
    435          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    436              if(tSetupPacket.bValueL < 128)
   \   000004   90....       MOV     DPTR,#(tSetupPacket + 2)
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C3           CLR     C
   \   000009   9480         SUBB    A,#-0x80
   \   00000B   501B         JNC     ??usbSetAddress_0
    437              	{
    438                  bFUNADR = tSetupPacket.bValueL;
   \   00000D   90....       MOV     DPTR,#(tSetupPacket + 2)
   \   000010   E0           MOVX    A,@DPTR
   \   000011   90FFFF       MOV     DPTR,#-0x1
   \   000014   F0           MOVX    @DPTR,A
    439                  bUsbDeviceAddress = tSetupPacket.bValueL;
   \   000015   90....       MOV     DPTR,#(tSetupPacket + 2)
   \   000018   E0           MOVX    A,@DPTR
   \   000019   90....       MOV     DPTR,#bUsbDeviceAddress
   \   00001C   F0           MOVX    @DPTR,A
    440                  bStatusAction = STATUS_ACTION_SET_ADDRESS;
   \   00001D   7403         MOV     A,#0x3
   \   00001F   90....       MOV     DPTR,#bStatusAction
   \   000022   F0           MOVX    @DPTR,A
    441                  usbSendZeroLengthPacketOnIEP0();
   \   000023                ; Setup parameters for call to function usbSendZeroLengthPacketOnIEP0
   \   000023   12....       LCALL   usbSendZeroLengthPacketOnIEP0
   \   000026   8003         SJMP    ??usbSetAddress_1
    442              	}
    443              else 
    444              	usbStallEndpoint0();
   \                     ??usbSetAddress_0:
   \   000028                ; Setup parameters for call to function usbStallEndpoint0
   \   000028   12....       LCALL   usbStallEndpoint0
    445          }
   \                     ??usbSetAddress_1:
   \   00002B   D083         POP     DPH
   \   00002D   D082         POP     DPL
   \   00002F   22           RET
    446          
    447          // The SetEndpointHalt allows the USB host to instruct the device to stop sending
    448          // information on IEP1, which is how the firmware delivers keystrokes to the host.
    449          // This is used mostly if a device goes crazy and starts sending too much data,
    450          // this allows the host to shut the endpoint down.  All we do is set or clear
    451          // the endpoint enable bit appropriately.  The GetEndpointStatus request reports
    452          // the status of the endpoint which is affected by Set/Clear EndpointHalt requests.
    453          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    454          void usbSetEndpointHalt(void)
   \                     usbSetEndpointHalt:
    455          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    456          	tInputEndPointDescriptorBlock[0].bEPCNF &= ~EPCNF_UBME;
   \   000004   90....       MOV     DPTR,#tInputEndPointDescriptorBlock
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C2E7         CLR     0xE0 /* A   */.7
   \   00000A   F0           MOVX    @DPTR,A
    457              usbSendZeroLengthPacketOnIEP0();
   \   00000B                ; Setup parameters for call to function usbSendZeroLengthPacketOnIEP0
   \   00000B   12....       LCALL   usbSendZeroLengthPacketOnIEP0
    458          }
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   22           RET
    459          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    460          void usbClearEndpointHalt(void)
   \                     usbClearEndpointHalt:
    461          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    462          	tInputEndPointDescriptorBlock[0].bEPCNF |= EPCNF_UBME;	
   \   000004   90....       MOV     DPTR,#tInputEndPointDescriptorBlock
   \   000007   E0           MOVX    A,@DPTR
   \   000008   D2E7         SETB    0xE0 /* A   */.7
   \   00000A   F0           MOVX    @DPTR,A
    463              usbSendZeroLengthPacketOnIEP0();
   \   00000B                ; Setup parameters for call to function usbSendZeroLengthPacketOnIEP0
   \   00000B   12....       LCALL   usbSendZeroLengthPacketOnIEP0
    464          }
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   22           RET
    465          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    466          void usbGetEndpointStatus(void)
   \                     usbGetEndpointStatus:
    467          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    468          	WORD wEndpointStatus = 0x0100;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   7400         MOV     A,#0x0
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   7401         MOV     A,#0x1
   \   000015   F0           MOVX    @DPTR,A
    469          	if(tInputEndPointDescriptorBlock[0].bEPCNF & EPCNF_UBME)
   \   000016   90....       MOV     DPTR,#tInputEndPointDescriptorBlock
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   A2E7         MOV     C,0xE0 /* A   */.7
   \   00001C   500D         JNC     ??usbGetEndpointStatus_0
    470          		wEndpointStatus = 0x0000;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   7400         MOV     A,#0x0
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   7400         MOV     A,#0x0
   \   00002A   F0           MOVX    @DPTR,A
    471          
    472              wBytesRemainingOnIEP0 = 2;
   \                     ??usbGetEndpointStatus_0:
   \   00002B   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   00002E   7402         MOV     A,#0x2
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   7400         MOV     A,#0x0
   \   000034   F0           MOVX    @DPTR,A
    473          	usbSendDataPacketOnEP0((PBYTE) &wEndpointStatus);
   \   000035                ; Setup parameters for call to function usbSendDataPacketOnEP0
   \   000035   85..82       MOV     DPL,?XSP + 0
   \   000038   85..83       MOV     DPH,?XSP + 1
   \   00003B   AA82         MOV     R2,DPL
   \   00003D   AB83         MOV     R3,DPH
   \   00003F   12....       LCALL   usbSendDataPacketOnEP0
    474          }
   \   000042   7402         MOV     A,#0x2
   \   000044   12....       LCALL   ?DEALLOC_XSTACK8
   \   000047   D083         POP     DPH
   \   000049   D082         POP     DPL
   \   00004B   22           RET
    475          
    476          // Any non-standard or unrecognized request will arrive at the following
    477          // function by default.  We automatically stall the endpoint to indicate
    478          // it's an invalid or unrecognized request.
    479          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    480          void usbNonStandardRequest(void)
   \                     usbNonStandardRequest:
    481          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    482          	usbStallEndpoint0();
   \   000000                ; Setup parameters for call to function usbStallEndpoint0
   \   000000   12....       LCALL   usbStallEndpoint0
    483          }
   \   000003   22           RET
    484          
    485          /***************************************************************************
    486           * Section:    REQUEST STRUCTURE                                           *
    487           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
    488           * Description: This section of code defines the structure of the lookup   *
    489           *    table which determines which 'C' function should be called for each  *
    490           *    supported USB request.                                               * 
    491           ***************************************************************************/
    492          
    493          typedef struct _tDEVICE_REQUEST_COMPARE
    494          {
    495              BYTE    bmRequestType;              // See bit definitions below
    496              BYTE    bRequest;                   // See value definitions below
    497              BYTE    bValueL;                    // Meaning varies with request type
    498              BYTE    bValueH;                    // Meaning varies with request type
    499              BYTE    bIndexL;                    // Meaning varies with request type
    500              BYTE    bIndexH;                    // Meaning varies with request type
    501              BYTE    bLengthL;                   // Number of bytes of data to transfer (LSByte)
    502              BYTE    bLengthH;                   // Number of bytes of data to transfer (MSByte)
    503              BYTE    bCompareMask;               // MSB is bRequest, if set 1, bRequest should be matched, LSB is bLengthH
    504              VOID    (*pUsbFunction)();      // function pointer
    505          } tDEVICE_REQUEST_COMPARE, *ptDEVICE_REQUEST_COMPARE;
    506          
    507          /***************************************************************************
    508           * Section:    USB REQUEST TABLE                                           *
    509           * Programmer: Craig Steiner (csteiner@vaultbbs.com) based on code by      *
    510           *             Lobo Tai (lobotai@ti.com)                                   *
    511           * Description: This section of code defines the lookup table, using the   *
    512           *    structure defined in the previous section of code.  The values of    *
    513           *    the constants used in this structure are defined in usb.h.           * 
    514           * Structure of Table:                                                     * 
    515           *    bmRequestType: Indicates the type of request.  This is a bit-mapped  * 
    516           *          variable defined in the USB spec.  The bits of this variable   * 
    517           *          have the following purpose, and are defined in usb.h.          * 
    518           *          Bit 7: Data Direction (0=Host to Device, 1=Device to Host)     * 
    519           *          Bit 6-5: Type of request (00=Standard, 01=Class, 10=Vendor)    * 
    520           *          Bit 4-0: Recipient (00000=Device, 00001=Interface,             *
    521           *                              00010=Endpoint, 00011=Other                *
    522           *    bRequest: Indicates the request ID (Get descriptor, Get Status, Get  *
    523           *              feature, etc.).  These are defined in the USB and HID spec *
    524           *              and are declared in usb.h.                                 *
    525           *    bValueL/H: Additional values, purpose varies with request.           *
    526           *    bIndexL/H: Additional values, purpose varies with request.           *
    527           *    bLengthL/H: Number of bytes to transfer to or from host.             *
    528           *    bCompareMask: Indicates which of the above bytes should be compared  *
    529           *               to determine the function to call.  For example, the mask *
    530           *               0x80 means only bmRequestType must match. 0xC0 means      *
    531           *               both bmRequestType and bRequest must match.  If this      *
    532           *               variable is 0x00, as is the case in the last entry in the *
    533           *               table, then no bytes are compared and, thus, ANY packet   *
    534           *               will pass the comparsion stage.  This technique is used   *
    535           *               in the last entry of the table as an "else" condition     *
    536           *               so that any requests that haven't been handled by that    *
    537           *               point are handled by the usbNonStandardRequest function.  *
    538           ***************************************************************************/
    539          

   \                                 In  segment CODE_C, align 1
    540          code tDEVICE_REQUEST_COMPARE tUsbRequestList[] =
   \                     tUsbRequestList:
   \   000000   02030000     DB 2, 3, 0, 0, 255, 0, 0, 0, 247
   \            FF000000
   \            F7      
   \   000009   ....         DW usbSetEndpointHalt
   \   00000B   02010000     DB 2, 1, 0, 0, 255, 0, 0, 0, 247
   \            FF000000
   \            F7      
   \   000014   ....         DW usbClearEndpointHalt
   \   000016   80080000     DB 128, 8, 0, 0, 0, 0, 1, 0, 255
   \            00000100
   \            FF      
   \   00001F   ....         DW usbGetConfiguration
   \   000021   0009FF00     DB 0, 9, 255, 0, 0, 0, 0, 0, 223
   \            00000000
   \            DF      
   \   00002A   ....         DW usbSetConfiguration
   \   00002C   8006FF01     DB 128, 6, 255, 1, 255, 255, 255, 255, 208
   \            FFFFFFFF
   \            D0      
   \   000035   ....         DW usbGetDeviceDescriptor
   \   000037   8006FF02     DB 128, 6, 255, 2, 255, 255, 255, 255, 208
   \            FFFFFFFF
   \            D0      
   \   000040   ....         DW usbGetConfigurationDescriptor
   \   000042   8106FF21     DB 129, 6, 255, 33, 255, 255, 255, 255, 208
   \            FFFFFFFF
   \            D0      
   \   00004B   ....         DW usbGetHIDDescriptor
   \   00004D   8006FF03     DB 128, 6, 255, 3, 255, 255, 255, 255, 208
   \            FFFFFFFF
   \            D0      
   \   000056   ....         DW usbGetStringDescriptor
   \   000058   8106FF22     DB 129, 6, 255, 34, 255, 255, 255, 255, 208
   \            FFFFFFFF
   \            D0      
   \   000061   ....         DW usbGetReportDescriptor
   \   000063   2109FFFF     DB 33, 9, 255, 255, 255, 255, 255, 255, 192
   \            FFFFFFFF
   \            C0      
   \   00006C   ....         DW usbSetReport
   \   00006E   210AFFFF     DB 33, 10, 255, 255, 255, 255, 0, 0, 195
   \            FFFF0000
   \            C3      
   \   000077   ....         DW usbSetIdle
   \   000079   210BFFFF     DB 33, 11, 255, 255, 255, 255, 0, 0, 195
   \            FFFF0000
   \            C3      
   \   000082   ....         DW usbSetProtocol
   \   000084   A102FFFF     DB 161, 2, 255, 255, 255, 255, 1, 0, 195
   \            FFFF0100
   \            C3      
   \   00008D   ....         DW usbGetIdle
   \   00008F   A103FFFF     DB 161, 3, 255, 255, 255, 255, 1, 0, 195
   \            FFFF0100
   \            C3      
   \   000098   ....         DW usbGetProtocol
   \   00009A   810A0000     DB 129, 10, 0, 0, 255, 255, 1, 0, 243
   \            FFFF0100
   \            F3      
   \   0000A3   ....         DW usbGetInterface
   \   0000A5   80000000     DB 128, 0, 0, 0, 0, 0, 2, 0, 255
   \            00000200
   \            FF      
   \   0000AE   ....         DW usbGetDeviceStatus
   \   0000B0   81000000     DB 129, 0, 0, 0, 255, 0, 2, 0, 247
   \            FF000200
   \            F7      
   \   0000B9   ....         DW usbGetInterfaceStatus
   \   0000BB   82000000     DB 130, 0, 0, 0, 255, 0, 2, 0, 247
   \            FF000200
   \            F7      
   \   0000C4   ....         DW usbGetEndpointStatus
   \   0000C6   0005FF00     DB 0, 5, 255, 0, 0, 0, 0, 0, 223
   \            00000000
   \            DF      
   \   0000CF   ....         DW usbSetAddress
   \   0000D1   00030100     DB 0, 3, 1, 0, 0, 0, 0, 0, 255
   \            00000000
   \            FF      
   \   0000DA   ....         DW usbSetRemoteWakeup
   \   0000DC   00010100     DB 0, 1, 1, 0, 0, 0, 0, 0, 255
   \            00000000
   \            FF      
   \   0000E5   ....         DW usbClearRemoteWakeup
   \   0000E7   010BFF00     DB 1, 11, 255, 0, 255, 0, 0, 0, 215
   \            FF000000
   \            D7      
   \   0000F0   ....         DW usbSetInterface
   \   0000F2   FFFFFFFF     DB 255, 255, 255, 255, 255, 255, 255, 255, 0
   \            FFFFFFFF
   \            00      
   \   0000FB   ....         DW usbNonStandardRequest
    541          {
    542              // SET ENDPOINT FEATURE
    543              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_ENDPOINT,
    544              USB_REQ_SET_FEATURE,
    545              FEATURE_ENDPOINT_STALL,0x00,
    546              0xff,0x00,
    547              0x00,0x00,
    548              0xf7,&usbSetEndpointHalt,
    549          
    550              // CLEAR ENDPOINT FEATURE
    551              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_ENDPOINT,
    552              USB_REQ_CLEAR_FEATURE,
    553              FEATURE_ENDPOINT_STALL,0x00,
    554              0xff,0x00,
    555              0x00,0x00,
    556              0xf7,&usbClearEndpointHalt,
    557          
    558              // GET CONFIGURATION
    559              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
    560              USB_REQ_GET_CONFIGURATION,
    561              0x00,0x00,
    562              0x00,0x00,
    563              0x01,0x00,
    564              0xff,&usbGetConfiguration,
    565          
    566              // SET CONFIGURATION
    567              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
    568              USB_REQ_SET_CONFIGURATION,
    569              0xff,0x00,
    570              0x00,0x00,
    571              0x00,0x00,
    572              0xdf,&usbSetConfiguration,
    573          
    574              // GET DEVICE DESCRIPTOR
    575              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
    576              USB_REQ_GET_DESCRIPTOR,
    577              0xff,DESC_TYPE_DEVICE,                  // bValueL is index and bValueH is type
    578              0xff,0xff,
    579              0xff,0xff,
    580              0xd0,&usbGetDeviceDescriptor,
    581          
    582              // GET CONFIGURATION DESCRIPTOR
    583              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
    584              USB_REQ_GET_DESCRIPTOR,
    585              0xff,DESC_TYPE_CONFIG,                  // bValueL is index and bValueH is type
    586              0xff,0xff,
    587              0xff,0xff,
    588              0xd0,&usbGetConfigurationDescriptor,
    589          
    590              // GET HID DESCRIPTOR
    591              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
    592              USB_REQ_GET_DESCRIPTOR,
    593              0xff,DESC_TYPE_HID,                  // bValueL is index and bValueH is type
    594              0xff,0xff,
    595              0xff,0xff,
    596              0xd0,&usbGetHIDDescriptor,
    597          
    598              // GET STRING DESCRIPTOR
    599              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
    600              USB_REQ_GET_DESCRIPTOR,
    601              0xff,DESC_TYPE_STRING,                  // bValueL is index and bValueH is type
    602              0xff,0xff,
    603              0xff,0xff,
    604              0xd0,&usbGetStringDescriptor,
    605          
    606              // GET REPORT DESCRIPTOR
    607              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
    608              USB_REQ_GET_DESCRIPTOR,
    609              0xff,DESC_TYPE_REPORT,                 // bValueL is index and bValueH is type
    610              0xff,0xff,
    611              0xff,0xff,
    612              0xd0,&usbGetReportDescriptor,
    613          
    614              // SET REPORT
    615              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
    616              USB_REQ_SET_REPORT,
    617              0xff,0xFF,                 // bValueL is index and bValueH is type
    618              0xff,0xff,
    619              0xff,0xff,
    620              0xC0,&usbSetReport,
    621          
    622              // SET IDLE
    623              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
    624              USB_REQ_SET_IDLE,
    625              0xff,0xFF,                  // bValueL is index and bValueH is type
    626              0xff,0xff,
    627              0x00,0x00,
    628              0xc3,&usbSetIdle,
    629          
    630              // SET PROTOCOL
    631              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
    632              USB_REQ_SET_PROTOCOL,
    633              0xff,0xFF,                  // bValueL is index and bValueH is type
    634              0xff,0xff,
    635              0x00,0x00,
    636              0xc3,&usbSetProtocol,
    637          
    638              // GET IDLE
    639              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
    640              USB_REQ_GET_IDLE,
    641              0xff,0xFF,                  // bValueL is index and bValueH is type
    642              0xff,0xff,
    643              0x01,0x00,
    644              0xc3,&usbGetIdle,
    645          
    646              // GET PROTOCOL
    647              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
    648              USB_REQ_GET_PROTOCOL,
    649              0xff,0xFF,                  // bValueL is index and bValueH is type
    650              0xff,0xff,
    651              0x01,0x00,
    652              0xc3,&usbGetProtocol,
    653          
    654              // GET INTERFACE
    655              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
    656              USB_REQ_GET_INTERFACE,
    657              0x00,0x00,
    658              0xff,0xff,
    659              0x01,0x00,
    660              0xf3,&usbGetInterface,
    661          
    662              // GET DEVICE STATUS
    663              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
    664              USB_REQ_GET_STATUS,
    665              0x00,0x00,
    666              0x00,0x00,
    667              0x02,0x00,
    668              0xff,&usbGetDeviceStatus,
    669          
    670              // GET INTERFACE STATUS
    671              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
    672              USB_REQ_GET_STATUS,
    673              0x00,0x00,
    674              0xff,0x00,
    675              0x02,0x00,
    676              0xf7,&usbGetInterfaceStatus,
    677          
    678              // GET ENDPOINT STATUS
    679              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_ENDPOINT,
    680              USB_REQ_GET_STATUS,
    681              0x00,0x00,
    682              0xff,0x00,
    683              0x02,0x00,
    684              0xf7,&usbGetEndpointStatus,
    685          
    686              // SET ADDRESS
    687              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
    688              USB_REQ_SET_ADDRESS,
    689              0xff,0x00,
    690              0x00,0x00,
    691              0x00,0x00,
    692              0xdf,&usbSetAddress,
    693          
    694              // SET DEVICE FEATURE
    695              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
    696              USB_REQ_SET_FEATURE,
    697              FEATURE_REMOTE_WAKEUP,0x00,           // feature selector
    698              0x00,0x00,
    699              0x00,0x00,
    700              0xff,&usbSetRemoteWakeup, // df, setDeviceFeature
    701              
    702          	// CLEAR DEVICE FEATURE
    703              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
    704              USB_REQ_CLEAR_FEATURE,
    705              FEATURE_REMOTE_WAKEUP,0x00,
    706              0x00,0x00,
    707              0x00,0x00,
    708              0xff,&usbClearRemoteWakeup,
    709          
    710              // SET INTERFACE FEATURE
    711              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
    712              USB_REQ_SET_INTERFACE,
    713              0xff,0x00,                      // alternative setting
    714              0xff,0x00,                      // interface number
    715              0x00,0x00,
    716              0xd7,&usbSetInterface,
    717          
    718          	// END OF LIST CATCH-ALL REQUEST: 
    719          	// This will match any USB request sicne bCompareMask is 0x00.
    720              0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    721              0x00,&usbNonStandardRequest
    722          };
    723          
    724          /***************************************************************************
    725           * Function:   UsbDecodeAndProcessUsbRequest()                             *
    726           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
    727           * Description: This function is called when a USB request has been        *
    728           *    received.  It searches the tUsbRequestList[] structure defined in    * 
    729           *    the previous section for a request that matches a given entry in     * 
    730           *    the table and, when matched, executes the corresponding function.    *  
    731           ***************************************************************************/
    732          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    733          VOID usbDecodeAndProcessUsbRequest()
   \                     usbDecodeAndProcessUsbRequest:
    734          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    735              BYTE bMask,bResult,bTemp;
    736              BYTE *pbUsbRequestList;                 // save code space
    737          
    738          
    739          	// We initialize the pbUsbRequestList pointer to the beginning of the
    740          	// tUsbRequestList[] so that we can subsequently traverse the table
    741          	// by incrementing the pbUsbRequestList pointer.
    742              pbUsbRequestList = (PBYTE) &tUsbRequestList[0];
   \   000005   78..         MOV     R0,#(tUsbRequestList & 0xff)
   \   000007   79..         MOV     R1,#((tUsbRequestList >> 8) & 0xff)
   \   000009   8008         SJMP    ??usbDecodeAndProcessUsbRequest_0
    743          
    744          	// Cycle indefinitely until we've found an entry in the tUsbRequestList[]
    745          	// table.  Since the last entry in the table has a 0x00 mask, we'll
    746          	// *always* find a match, so this cycle will always exit.
    747              while(1)
    748              	{
    749                  bResult = 0x00;
    750                  bMask   = 0x80;
    751          
    752                  // We cycle through fields 0 through 7, which correspond to the 8 fields
    753                  // in each entry of tUsbRequestList.  If the given byte in the packet
    754                  // we just receive is equal to the corresponding byte in the table, we
    755                  // set that bit in the result, indicating a byte which matched.  Otherwise,
    756                  // we don't set the bit which means that byte didn't match.
    757                  for(bTemp = 0; bTemp < 8; bTemp++)
    758                  	{
    759                      if(*(pbEP0_SETUP_ADDRESS+bTemp) == *(pbUsbRequestList+bTemp)) 
    760                      	bResult |= bMask;
    761          			bMask = bMask >> 1;
    762          	        }
    763          
    764                  // At this point, bResult holds 8 bits which indicate whether each of the
    765                  // bytes in the packet matched the corresponding bytes in the tUsbRequestList[]
    766                  // table.  We then AND the mask value in the table with the result so that
    767                  // we only are comparing the bits required in the mask.  If the resulting
    768                  // value is equal to the mask, that means that all significant bytes match.
    769                  // This is done since any bit that is clear in the mask is a "don't care", so
    770                  // the AND makes sure we don't reject a "valid" comparison beause a don't 
    771                  // care bit actually matched.
    772                  if((*(pbUsbRequestList+bTemp) & bResult) == *(pbUsbRequestList+bTemp)) 
    773                  	break;
    774          
    775                  // If we haven't found a matching entry yet, we advenced the pointer to point
    776                  // to the next entry in the table, and keep looking.
    777                  pbUsbRequestList += sizeof(tDEVICE_REQUEST_COMPARE);
   \                     ??usbDecodeAndProcessUsbRequest_1:
   \   00000B   E8           MOV     A,R0
   \   00000C   240B         ADD     A,#0xb
   \   00000E   F8           MOV     R0,A
   \   00000F   E9           MOV     A,R1
   \   000010   3400         ADDC    A,#0x0
   \   000012   F9           MOV     R1,A
   \                     ??usbDecodeAndProcessUsbRequest_0:
   \   000013   75..00       MOV     ?V0 + 1,#0x0
   \   000016   7E80         MOV     R6,#-0x80
   \   000018   75..00       MOV     ?V0 + 0,#0x0
   \   00001B   803B         SJMP    ??usbDecodeAndProcessUsbRequest_2
   \                     ??usbDecodeAndProcessUsbRequest_3:
   \   00001D   85....       MOV     ?V0 + 2,?V0 + 0
   \   000020   75..00       MOV     ?V0 + 3,#0x0
   \   000023   E5..         MOV     A,?V0 + 2
   \   000025   2400         ADD     A,#0x0
   \   000027   F582         MOV     DPL,A
   \   000029   E5..         MOV     A,?V0 + 3
   \   00002B   34FF         ADDC    A,#-0x1
   \   00002D   F583         MOV     DPH,A
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
   \   000031   33           RLC     A
   \   000032   95E0         SUBB    A,0xE0 /* A   */
   \   000034   FB           MOV     R3,A
   \   000035   85....       MOV     ?V0 + 2,?V0 + 0
   \   000038   75..00       MOV     ?V0 + 3,#0x0
   \   00003B   E8           MOV     A,R0
   \   00003C   25..         ADD     A,?V0 + 2
   \   00003E   F582         MOV     DPL,A
   \   000040   E9           MOV     A,R1
   \   000041   35..         ADDC    A,?V0 + 3
   \   000043   F583         MOV     DPH,A
   \   000045   E0           MOVX    A,@DPTR
   \   000046   7D00         MOV     R5,#0x0
   \   000048   6A           XRL     A,R2
   \   000049   7002         JNZ     ??usbDecodeAndProcessUsbRequest_4
   \   00004B   ED           MOV     A,R5
   \   00004C   6B           XRL     A,R3
   \                     ??usbDecodeAndProcessUsbRequest_4:
   \   00004D   7003         JNZ     ??usbDecodeAndProcessUsbRequest_5
   \   00004F   EE           MOV     A,R6
   \   000050   42..         ORL     ?V0 + 1,A
   \                     ??usbDecodeAndProcessUsbRequest_5:
   \   000052   EE           MOV     A,R6
   \   000053   C3           CLR     C
   \   000054   13           RRC     A
   \   000055   FE           MOV     R6,A
   \   000056   05..         INC     ?V0 + 0
   \                     ??usbDecodeAndProcessUsbRequest_2:
   \   000058   E5..         MOV     A,?V0 + 0
   \   00005A   C3           CLR     C
   \   00005B   9408         SUBB    A,#0x8
   \   00005D   40BE         JC      ??usbDecodeAndProcessUsbRequest_3
   \   00005F   85....       MOV     ?V0 + 2,?V0 + 0
   \   000062   75..00       MOV     ?V0 + 3,#0x0
   \   000065   E8           MOV     A,R0
   \   000066   25..         ADD     A,?V0 + 2
   \   000068   F582         MOV     DPL,A
   \   00006A   E9           MOV     A,R1
   \   00006B   35..         ADDC    A,?V0 + 3
   \   00006D   F583         MOV     DPH,A
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   55..         ANL     A,?V0 + 1
   \   000072   FA           MOV     R2,A
   \   000073   75..00       MOV     ?V0 + 1,#0x0
   \   000076   E8           MOV     A,R0
   \   000077   25..         ADD     A,?V0 + 0
   \   000079   F582         MOV     DPL,A
   \   00007B   E9           MOV     A,R1
   \   00007C   35..         ADDC    A,?V0 + 1
   \   00007E   F583         MOV     DPH,A
   \   000080   E0           MOVX    A,@DPTR
   \   000081   6A           XRL     A,R2
   \   000082   7087         JNZ     ??usbDecodeAndProcessUsbRequest_1
    778              	}
    779          
    780              // We check to see if any more setup packet(s) have been received and, if so, we
    781              // anbandon this one to hanlde the next one.
    782              if(bUSBSTA & (USBSTA_SETUP | USBSTA_STPOW) != 0x00) 
   \   000084   90FFFE       MOV     DPTR,#-0x2
   \   000087   E0           MOVX    A,@DPTR
   \   000088   A2E0         MOV     C,0xE0 /* A   */.0
   \   00008A   4018         JC      ??usbDecodeAndProcessUsbRequest_6
    783              	return;
    784          
    785          	// If we've reached this point of the function, we've found the function that should
    786          	// be called given the current request.  So we call it...
    787          	((ptDEVICE_REQUEST_COMPARE)pbUsbRequestList)->pUsbFunction();
   \   00008C                ; Setup parameters for indirect call
   \   00008C   8882         MOV     DPL,R0
   \   00008E   8983         MOV     DPH,R1
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   F8           MOV     R0,A
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   F583         MOV     DPH,A
   \   00009F   8882         MOV     DPL,R0
   \   0000A1   12....       LCALL   ?CALL_IND
    788          }
   \                     ??usbDecodeAndProcessUsbRequest_6:
   \   0000A4   7F04         MOV     R7,#0x4
   \   0000A6   02....       LJMP    ?FUNC_LEAVE_XDATA
    789          
    790          /***************************************************************************
    791           * Function:   usbStallEndpoint0()                                         *
    792           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
    793           * Description: Sets the STALL flag on both IEP0 and OEP0.  Often called   *
    794           *    to reflect an error condition.                                       *
    795           ***************************************************************************/
    796          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    797          void usbStallEndpoint0(void)
   \                     usbStallEndpoint0:
    798          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    799              tEndPoint0DescriptorBlock.bIEPCNFG |= EPCNF_STALL;
   \   000004   90....       MOV     DPTR,#tEndPoint0DescriptorBlock
   \   000007   E0           MOVX    A,@DPTR
   \   000008   D2E3         SETB    0xE0 /* A   */.3
   \   00000A   F0           MOVX    @DPTR,A
    800              tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL;
   \   00000B   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 2)
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   D2E3         SETB    0xE0 /* A   */.3
   \   000011   F0           MOVX    @DPTR,A
    801          }
   \   000012   D083         POP     DPH
   \   000014   D082         POP     DPL
   \   000016   22           RET
    802          
    803          /***************************************************************************
    804           * Function:   usbReceiveDataPacketOnEP0 / ReceiveNextPacket               *
    805           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
    806           * Description: These two functions, together, are used to receive a data  *
    807           *    payload on the OEP0 endpoint.  The reception is first initiated by   *
    808           *    calling usbReceiveDataPacketOnEP0 and indicating the address that the*
    809           *    received data should be placed in.  As each data packet is received, *
    810           *    the usbReceiveNextPacketOnOEP0 will be called to process the packet  *
    811           *    and determine if the packet received was the last packet, or if there*
    812           *    are more packets coming.                                             * 
    813           ***************************************************************************/
    814          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    815          void usbReceiveDataPacketOnEP0(PBYTE pbBuffer)
   \                     usbReceiveDataPacketOnEP0:
    816          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    817              pbOEP0Buffer = pbBuffer;
   \   000004   90....       MOV     DPTR,#pbOEP0Buffer
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    818              wBytesRemainingOnOEP0 = (WORD)(tSetupPacket.bLengthH << 8) | (WORD)tSetupPacket.bLengthL;
   \   00000C   90....       MOV     DPTR,#(tSetupPacket + 7)
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   E4           CLR     A
   \   000012   C8           XCH     A,R0
   \   000013   F9           MOV     R1,A
   \   000014   90....       MOV     DPTR,#(tSetupPacket + 6)
   \   000017   E0           MOVX    A,@DPTR
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   48           ORL     A,R0
   \   00001B   F8           MOV     R0,A
   \   00001C   EB           MOV     A,R3
   \   00001D   49           ORL     A,R1
   \   00001E   F9           MOV     R1,A
   \   00001F   90....       MOV     DPTR,#wBytesRemainingOnOEP0
   \   000022   E8           MOV     A,R0
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   E9           MOV     A,R1
   \   000026   F0           MOVX    @DPTR,A
    819              bStatusAction = STATUS_ACTION_DATA_OUT;
   \   000027   7402         MOV     A,#0x2
   \   000029   90....       MOV     DPTR,#bStatusAction
   \   00002C   F0           MOVX    @DPTR,A
    820              usbClearOEP0ByteCount;            
   \   00002D   7400         MOV     A,#0x0
   \   00002F   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 3)
   \   000032   F0           MOVX    @DPTR,A
    821          }
   \   000033   D083         POP     DPH
   \   000035   D082         POP     DPL
   \   000037   22           RET
    822          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    823          void usbReceiveNextPacketOnOEP0(void)
   \                     usbReceiveNextPacketOnOEP0:
    824          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    825              BYTE bIndex,bByte;
    826          
    827          	// First we must determine how many bytes were received in this data
    828          	// packet.  We AND it with EPBCT_BYTECNT_MASK so that a NAK condition
    829          	// will return "0 bytes."
    830              bByte = tEndPoint0DescriptorBlock.bOEPBCNT & EPBCT_BYTECNT_MASK;
   \   000005   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 3)
   \   000008   E0           MOVX    A,@DPTR
   \   000009   547F         ANL     A,#0x7f
   \   00000B   FA           MOV     R2,A
    831          
    832          	// If the number of bytes remaining to be received is greater than
    833          	// or equal to the number of bytes received in this packet then
    834          	// we handle the packet.  However, if we received more bytes than
    835          	// we had expected we simply ignore the packet since it is
    836          	// presumably erroneous.
    837              if(wBytesRemainingOnOEP0 >= (WORD)bByte)
   \   00000C   90....       MOV     DPTR,#wBytesRemainingOnOEP0
   \   00000F   8A..         MOV     ?V0 + 0,R2
   \   000011   75..00       MOV     ?V0 + 1,#0x0
   \   000014   C3           CLR     C
   \   000015   E0           MOVX    A,@DPTR
   \   000016   95..         SUBB    A,?V0 + 0
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   95..         SUBB    A,?V0 + 1
   \   00001C   5003         JNC     $+5
   \   00001E   02....       LJMP    ??usbReceiveNextPacketOnOEP0_0
    838              	{
    839          		// For each of the bytes received, we copy the value received to the
    840          		// next position in the buffer we set aside for the OEP0 data.
    841                  for(bIndex=0;bIndex<bByte;bIndex++)
   \   000021   7B00         MOV     R3,#0x0
   \   000023   8037         SJMP    ??usbReceiveNextPacketOnOEP0_1
    842                      *pbOEP0Buffer++ = abOEP0Buffer[bIndex];
   \                     ??usbReceiveNextPacketOnOEP0_2:
   \   000025   8B..         MOV     ?V0 + 0,R3
   \   000027   75..00       MOV     ?V0 + 1,#0x0
   \   00002A   E5..         MOV     A,?V0 + 0
   \   00002C   24..         ADD     A,#(abOEP0Buffer & 0xff)
   \   00002E   F582         MOV     DPL,A
   \   000030   E5..         MOV     A,?V0 + 1
   \   000032   34..         ADDC    A,#((abOEP0Buffer >> 8) & 0xff)
   \   000034   F583         MOV     DPH,A
   \   000036   E0           MOVX    A,@DPTR
   \   000037   C0E0         PUSH    A
   \   000039   90....       MOV     DPTR,#pbOEP0Buffer
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F583         MOV     DPH,A
   \   000042   8882         MOV     DPL,R0
   \   000044   D0E0         POP     A
   \   000046   F0           MOVX    @DPTR,A
   \   000047   90....       MOV     DPTR,#pbOEP0Buffer
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   2401         ADD     A,#0x1
   \   00004D   F8           MOV     R0,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   3400         ADDC    A,#0x0
   \   000052   F9           MOV     R1,A
   \   000053   90....       MOV     DPTR,#pbOEP0Buffer
   \   000056   E8           MOV     A,R0
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   E9           MOV     A,R1
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   0B           INC     R3
   \                     ??usbReceiveNextPacketOnOEP0_1:
   \   00005C   EB           MOV     A,R3
   \   00005D   C3           CLR     C
   \   00005E   9A           SUBB    A,R2
   \   00005F   40C4         JC      ??usbReceiveNextPacketOnOEP0_2
    843          
    844          		// We now reduce the number of bytes remaining by the number of bytes
    845          		// received in this packet.                              
    846                  wBytesRemainingOnOEP0 -= (WORD)bByte;
   \   000061   8A..         MOV     ?V0 + 0,R2
   \   000063   75..00       MOV     ?V0 + 1,#0x0
   \   000066   90....       MOV     DPTR,#wBytesRemainingOnOEP0
   \   000069   C3           CLR     C
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   95..         SUBB    A,?V0 + 0
   \   00006D   F0           MOVX    @DPTR,A
   \   00006E   A3           INC     DPTR
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   95..         SUBB    A,?V0 + 1
   \   000072   F0           MOVX    @DPTR,A
    847          
    848                  // If there are still more bytes to be received in additional packets (i.e.,
    849          		// wBytesRemainingOnOEP0 is greater than zero), we clear the byte count and
    850          		// reestablish bStatusAction to indicate that we are still in a DATA_OUT
    851          		// condition.
    852                  if(wBytesRemainingOnOEP0 > 0)
   \   000073   90....       MOV     DPTR,#wBytesRemainingOnOEP0
   \   000076   E0           MOVX    A,@DPTR
   \   000077   6400         XRL     A,#0x0
   \   000079   7004         JNZ     ??usbReceiveNextPacketOnOEP0_3
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   6400         XRL     A,#0x0
   \                     ??usbReceiveNextPacketOnOEP0_3:
   \   00007F   600E         JZ      ??usbReceiveNextPacketOnOEP0_4
    853                  	{
    854                      usbClearOEP0ByteCount;        
   \   000081   7400         MOV     A,#0x0
   \   000083   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 3)
   \   000086   F0           MOVX    @DPTR,A
    855                      bStatusAction = STATUS_ACTION_DATA_OUT;
   \   000087   7402         MOV     A,#0x2
   \   000089   90....       MOV     DPTR,#bStatusAction
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D   801F         SJMP    ??usbReceiveNextPacketOnOEP0_5
    856                  	}
    857                  else
    858                  	{
    859                  	// If we aren't expecting any more data bytes, we terminate the OEP0
    860                  	// transaction by stalling OEP0 and setting the bStatusAction condition
    861                  	// to "Nothing."  Since in this firmware the only USB function that
    862                  	// includes a subsequent data payload is the Set_Report function, we
    863                  	// automatically update the keyboard LEDs with the new value.  If
    864                  	// additional features are added that expect data payloads, calling
    865                  	// the OEP0SetLeds() function when a Set_Report request was not
    866                  	// received will cause no harm.
    867                      usbStallOEP0;
   \                     ??usbReceiveNextPacketOnOEP0_4:
   \   00008F   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 2)
   \   000092   E0           MOVX    A,@DPTR
   \   000093   D2E3         SETB    0xE0 /* A   */.3
   \   000095   F0           MOVX    @DPTR,A
    868                      bStatusAction = STATUS_ACTION_NOTHING;        
   \   000096   7400         MOV     A,#0x0
   \   000098   90....       MOV     DPTR,#bStatusAction
   \   00009B   F0           MOVX    @DPTR,A
    869          			OEP0SetLEDs();
   \   00009C                ; Setup parameters for call to function OEP0SetLEDs
   \   00009C   12....       LCALL   OEP0SetLEDs
   \   00009F   800D         SJMP    ??usbReceiveNextPacketOnOEP0_5
    870                  	}
    871              	}
    872              else
    873              	{
    874              	// If the packet we received include more data than we expected, we ignore
    875              	// the entire packet and abort the transfer.  This is accomplished by
    876              	// stalling OEP0 and resetting the bStatusAction condition to "Nothing."
    877                  usbStallOEP0;
   \                     ??usbReceiveNextPacketOnOEP0_0:
   \   0000A1   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 2)
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   D2E3         SETB    0xE0 /* A   */.3
   \   0000A7   F0           MOVX    @DPTR,A
    878                  bStatusAction = STATUS_ACTION_NOTHING;
   \   0000A8   7400         MOV     A,#0x0
   \   0000AA   90....       MOV     DPTR,#bStatusAction
   \   0000AD   F0           MOVX    @DPTR,A
    879              	}
    880          }
   \                     ??usbReceiveNextPacketOnOEP0_5:
   \   0000AE   7F02         MOV     R7,#0x2
   \   0000B0   02....       LJMP    ?FUNC_LEAVE_XDATA
    881          
    882          /***************************************************************************
    883           * Function:   usbSendZeroLengthPacketOnIEP0()                             *
    884           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
    885           * Description: Sends a 0-lengthg packet back to the host on IEP0. Often   *
    886           *    called to acknowledge a packet received from the host that requires  *
    887           *    no data in the reply, just an acknowledgement of receipt.            *
    888           ***************************************************************************/
    889          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    890          void usbSendZeroLengthPacketOnIEP0(void)
   \                     usbSendZeroLengthPacketOnIEP0:
    891          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    892              wBytesRemainingOnIEP0 = NO_MORE_DATA;
   \   000004   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000007   74FF         MOV     A,#-0x1
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   74FF         MOV     A,#-0x1
   \   00000D   F0           MOVX    @DPTR,A
    893              bStatusAction = STATUS_ACTION_NOTHING;
   \   00000E   7400         MOV     A,#0x0
   \   000010   90....       MOV     DPTR,#bStatusAction
   \   000013   F0           MOVX    @DPTR,A
    894              tEndPoint0DescriptorBlock.bIEPBCNT = 0x00;
   \   000014   7400         MOV     A,#0x0
   \   000016   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 1)
   \   000019   F0           MOVX    @DPTR,A
    895          }
   \   00001A   D083         POP     DPH
   \   00001C   D082         POP     DPL
   \   00001E   22           RET
    896          
    897          /***************************************************************************
    898           * Function:   usbSendDataPacketOnEPO / SendNext                           *
    899           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
    900           * Description: These two functions, together, are responsible for sending *
    901           *    data packets back to the host on IEPO.  The transfer is initiated by *
    902           *    first calling usbSendDataPacketOnEP0 and indicating the address of   *
    903           *    the buffer to send.  This initiates the transfer and sends the first *
    904           *    packet of data.  If there is more data than can be sent in the first *
    905           *    packet, the usbSendNextPacketOnIEP0 function is called to send       *
    906           *    subsequent packets of data when an interrupt indicates the previous  *
    907           *    packet has been sent.                                                *
    908           ***************************************************************************/
    909          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    910          void usbSendDataPacketOnEP0(PBYTE pbBuffer)
   \                     usbSendDataPacketOnEP0:
    911          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    912              WORD wTemp;
    913          
    914              pbIEP0Buffer = pbBuffer;
   \   000004   90....       MOV     DPTR,#pbIEP0Buffer
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    915          
    916              wTemp = (WORD)(tSetupPacket.bLengthH << 8) | (WORD)tSetupPacket.bLengthL;
   \   00000C   90....       MOV     DPTR,#(tSetupPacket + 7)
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   E4           CLR     A
   \   000012   C8           XCH     A,R0
   \   000013   F9           MOV     R1,A
   \   000014   90....       MOV     DPTR,#(tSetupPacket + 6)
   \   000017   E0           MOVX    A,@DPTR
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   48           ORL     A,R0
   \   00001B   F8           MOV     R0,A
   \   00001C   EB           MOV     A,R3
   \   00001D   49           ORL     A,R1
   \   00001E   F9           MOV     R1,A
    917          
    918              // Limit transfer size to wLength if needed
    919              // this prevent USB device sending 'more than require' data back to host
    920              if(wBytesRemainingOnIEP0 >= wTemp)
   \   00001F   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000022   C3           CLR     C
   \   000023   E0           MOVX    A,@DPTR
   \   000024   98           SUBB    A,R0
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   99           SUBB    A,R1
   \   000028   4014         JC      ??usbSendDataPacketOnEP0_0
    921              	{
    922                  wBytesRemainingOnIEP0 = wTemp;
   \   00002A   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   00002D   E8           MOV     A,R0
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   A3           INC     DPTR
   \   000030   E9           MOV     A,R1
   \   000031   F0           MOVX    @DPTR,A
    923                  bHostAskMoreDataThanAvailable = FALSE;
   \   000032   90....       MOV     DPTR,#bHostAskMoreDataThanAvailable
   \   000035   7400         MOV     A,#0x0
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   7400         MOV     A,#0x0
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   800A         SJMP    ??usbSendDataPacketOnEP0_1
    924                  }
    925          	else
    926          		{ 
    927          		bHostAskMoreDataThanAvailable = TRUE;
   \                     ??usbSendDataPacketOnEP0_0:
   \   00003E   90....       MOV     DPTR,#bHostAskMoreDataThanAvailable
   \   000041   7401         MOV     A,#0x1
   \   000043   F0           MOVX    @DPTR,A
   \   000044   A3           INC     DPTR
   \   000045   7400         MOV     A,#0x0
   \   000047   F0           MOVX    @DPTR,A
    928          		}
    929          
    930              usbSendNextPacketOnIEP0();
   \                     ??usbSendDataPacketOnEP0_1:
   \   000048                ; Setup parameters for call to function usbSendNextPacketOnIEP0
   \   000048   12....       LCALL   usbSendNextPacketOnIEP0
    931          }
   \   00004B   D083         POP     DPH
   \   00004D   D082         POP     DPL
   \   00004F   22           RET
    932          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    933          void usbSendNextPacketOnIEP0(void)
   \                     usbSendNextPacketOnIEP0:
    934          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    935              BYTE bPacketSize,bIndex;
    936          
    937              // First check if there are bytes remaining to be transferred
    938              if(wBytesRemainingOnIEP0 != NO_MORE_DATA)
   \   000005   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000008   E0           MOVX    A,@DPTR
   \   000009   64FF         XRL     A,#0xff
   \   00000B   7004         JNZ     ??usbSendNextPacketOnIEP0_0
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   64FF         XRL     A,#0xff
   \                     ??usbSendNextPacketOnIEP0_0:
   \   000011   7003         JNZ     $+5
   \   000013   02....       LJMP    ??usbSendNextPacketOnIEP0_1
    939              	{
    940                  if(wBytesRemainingOnIEP0 > EP0_MAX_PACKET_SIZE)
   \   000016   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000019   C3           CLR     C
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   9409         SUBB    A,#0x9
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   9400         SUBB    A,#0x0
   \   000021   4016         JC      ??usbSendNextPacketOnIEP0_2
    941                  	{
    942                      // More bytes are remaining than will fit in one packet
    943                      // there will be More IN Stage
    944                      bPacketSize = EP0_MAX_PACKET_SIZE;
   \   000023   7B08         MOV     R3,#0x8
    945                      wBytesRemainingOnIEP0 -= EP0_MAX_PACKET_SIZE;
   \   000025   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000028   E0           MOVX    A,@DPTR
   \   000029   24F8         ADD     A,#-0x8
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   34FF         ADDC    A,#-0x1
   \   000030   F0           MOVX    @DPTR,A
    946                      bStatusAction = STATUS_ACTION_DATA_IN;
   \   000031   7401         MOV     A,#0x1
   \   000033   90....       MOV     DPTR,#bStatusAction
   \   000036   F0           MOVX    @DPTR,A
   \   000037   8056         SJMP    ??usbSendNextPacketOnIEP0_3
    947                  	}
    948                  else if (wBytesRemainingOnIEP0 < EP0_MAX_PACKET_SIZE)
   \                     ??usbSendNextPacketOnIEP0_2:
   \   000039   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   00003C   C3           CLR     C
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   9408         SUBB    A,#0x8
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   9400         SUBB    A,#0x0
   \   000044   5017         JNC     ??usbSendNextPacketOnIEP0_4
    949                  	{
    950                      // The remaining data will fit in one packet.
    951                      // This case will properly handle wBytesRemainingOnIEP0 == 0
    952                      bPacketSize = (BYTE)wBytesRemainingOnIEP0;
   \   000046   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   FB           MOV     R3,A
    953                      wBytesRemainingOnIEP0 = NO_MORE_DATA;        // No more data need to be Txed
   \   00004B   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   00004E   74FF         MOV     A,#-0x1
   \   000050   F0           MOVX    @DPTR,A
   \   000051   A3           INC     DPTR
   \   000052   74FF         MOV     A,#-0x1
   \   000054   F0           MOVX    @DPTR,A
    954                      bStatusAction = STATUS_ACTION_NOTHING;
   \   000055   7400         MOV     A,#0x0
   \   000057   90....       MOV     DPTR,#bStatusAction
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   8032         SJMP    ??usbSendNextPacketOnIEP0_3
    955                  	}
    956                  else
    957                  	{
    958                      // wBytesRemainingOnIEP0 == EP0_MAX_PACKET_SIZE
    959                      bPacketSize = EP0_MAX_PACKET_SIZE;
   \                     ??usbSendNextPacketOnIEP0_4:
   \   00005D   7B08         MOV     R3,#0x8
    960                      if(bHostAskMoreDataThanAvailable == TRUE)
   \   00005F   90....       MOV     DPTR,#bHostAskMoreDataThanAvailable
   \   000062   E0           MOVX    A,@DPTR
   \   000063   6401         XRL     A,#0x1
   \   000065   7004         JNZ     ??usbSendNextPacketOnIEP0_5
   \   000067   A3           INC     DPTR
   \   000068   E0           MOVX    A,@DPTR
   \   000069   6400         XRL     A,#0x0
   \                     ??usbSendNextPacketOnIEP0_5:
   \   00006B   7012         JNZ     ??usbSendNextPacketOnIEP0_6
    961                      	{
    962                          wBytesRemainingOnIEP0 = 0;
   \   00006D   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000070   7400         MOV     A,#0x0
   \   000072   F0           MOVX    @DPTR,A
   \   000073   A3           INC     DPTR
   \   000074   7400         MOV     A,#0x0
   \   000076   F0           MOVX    @DPTR,A
    963                          bStatusAction = STATUS_ACTION_DATA_IN;
   \   000077   7401         MOV     A,#0x1
   \   000079   90....       MOV     DPTR,#bStatusAction
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   8010         SJMP    ??usbSendNextPacketOnIEP0_3
    964                      	}
    965                      else
    966                      	{ 
    967                          wBytesRemainingOnIEP0 = NO_MORE_DATA;
   \                     ??usbSendNextPacketOnIEP0_6:
   \   00007F   90....       MOV     DPTR,#wBytesRemainingOnIEP0
   \   000082   74FF         MOV     A,#-0x1
   \   000084   F0           MOVX    @DPTR,A
   \   000085   A3           INC     DPTR
   \   000086   74FF         MOV     A,#-0x1
   \   000088   F0           MOVX    @DPTR,A
    968                          bStatusAction = STATUS_ACTION_NOTHING;
   \   000089   7400         MOV     A,#0x0
   \   00008B   90....       MOV     DPTR,#bStatusAction
   \   00008E   F0           MOVX    @DPTR,A
    969                      	}
    970                  	}
    971          
    972                  for(bIndex=0; bIndex<bPacketSize; bIndex++) 
   \                     ??usbSendNextPacketOnIEP0_3:
   \   00008F   7A00         MOV     R2,#0x0
   \   000091   8037         SJMP    ??usbSendNextPacketOnIEP0_7
    973                      abIEP0Buffer[bIndex] = *pbIEP0Buffer++;
   \                     ??usbSendNextPacketOnIEP0_8:
   \   000093   90....       MOV     DPTR,#pbIEP0Buffer
   \   000096   E0           MOVX    A,@DPTR
   \   000097   F8           MOV     R0,A
   \   000098   A3           INC     DPTR
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   F583         MOV     DPH,A
   \   00009C   8882         MOV     DPL,R0
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   C0E0         PUSH    A
   \   0000A1   8A..         MOV     ?V0 + 0,R2
   \   0000A3   75..00       MOV     ?V0 + 1,#0x0
   \   0000A6   E5..         MOV     A,?V0 + 0
   \   0000A8   24..         ADD     A,#(abIEP0Buffer & 0xff)
   \   0000AA   F582         MOV     DPL,A
   \   0000AC   E5..         MOV     A,?V0 + 1
   \   0000AE   34..         ADDC    A,#((abIEP0Buffer >> 8) & 0xff)
   \   0000B0   F583         MOV     DPH,A
   \   0000B2   D0E0         POP     A
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   90....       MOV     DPTR,#pbIEP0Buffer
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   2401         ADD     A,#0x1
   \   0000BB   F8           MOV     R0,A
   \   0000BC   A3           INC     DPTR
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   3400         ADDC    A,#0x0
   \   0000C0   F9           MOV     R1,A
   \   0000C1   90....       MOV     DPTR,#pbIEP0Buffer
   \   0000C4   E8           MOV     A,R0
   \   0000C5   F0           MOVX    @DPTR,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   E9           MOV     A,R1
   \   0000C8   F0           MOVX    @DPTR,A
   \   0000C9   0A           INC     R2
   \                     ??usbSendNextPacketOnIEP0_7:
   \   0000CA   EA           MOV     A,R2
   \   0000CB   C3           CLR     C
   \   0000CC   9B           SUBB    A,R3
   \   0000CD   40C4         JC      ??usbSendNextPacketOnIEP0_8
    974          
    975                  tEndPoint0DescriptorBlock.bIEPBCNT = bPacketSize;   // & EPBCT_BYTECNT_MASK;
   \   0000CF   EB           MOV     A,R3
   \   0000D0   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 1)
   \   0000D3   F0           MOVX    @DPTR,A
   \   0000D4   8006         SJMP    ??usbSendNextPacketOnIEP0_9
    976          	  	}
    977              else
    978              	{
    979              	bStatusAction = STATUS_ACTION_NOTHING;
   \                     ??usbSendNextPacketOnIEP0_1:
   \   0000D6   7400         MOV     A,#0x0
   \   0000D8   90....       MOV     DPTR,#bStatusAction
   \   0000DB   F0           MOVX    @DPTR,A
    980              	}
    981          }
   \                     ??usbSendNextPacketOnIEP0_9:
   \   0000DC   7F02         MOV     R7,#0x2
   \   0000DE   02....       LJMP    ?FUNC_LEAVE_XDATA
    982          
    983          /***************************************************************************
    984           * Function:   SetupPacketInterruptHandler()                               *
    985           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
    986           * Description: This function is called by the UsbInterrupt function when  *
    987           *    a setup packet is received.  This function immediately sets both     * 
    988           *    OEP0 and IEP0 to a NAK state, sets the bUSBCTL to send/receive based *
    989           *    on the direction of the request, then proceeds to call  the          *
    990           *    usbDecodeAndProcessUsbRequest() function which determines which      *
    991           *    function should be called to handle the given USB request.           *  
    992           ***************************************************************************/
    993          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    994          void SetupPacketInterruptHandler(void)
   \                     SetupPacketInterruptHandler:
    995          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    996              // Hardware clears STALL in both data endpoints once valid setup packet is
    997              // received.  NAK both data endpoints.
    998              tEndPoint0DescriptorBlock.bIEPBCNT  = EPBCNT_NAK;
   \   000004   7480         MOV     A,#-0x80
   \   000006   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 1)
   \   000009   F0           MOVX    @DPTR,A
    999              tEndPoint0DescriptorBlock.bOEPBCNT  = EPBCNT_NAK;
   \   00000A   7480         MOV     A,#-0x80
   \   00000C   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 3)
   \   00000F   F0           MOVX    @DPTR,A
   1000              
   1001              bUSBSTA = USBSTA_SETUP; // from now, hardware will refer NAK bit in I/OEPBCNT
   \   000010   7404         MOV     A,#0x4
   \   000012   90FFFE       MOV     DPTR,#-0x2
   \   000015   F0           MOVX    @DPTR,A
   1002          
   1003              // Copy the MSB of bmRequestType to DIR bit of USBCTL to indicate the
   1004              // direction of the transfer.
   1005              if((tSetupPacket.bmRequestType & USB_REQ_TYPE_INPUT) == USB_REQ_TYPE_INPUT)
   \   000016   90....       MOV     DPTR,#tSetupPacket
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   A2E7         MOV     C,0xE0 /* A   */.7
   \   00001C   5009         JNC     ??SetupPacketInterruptHandler_0
   1006                  bUSBCTL |= USBCTL_DIR;
   \   00001E   90FFFC       MOV     DPTR,#-0x4
   \   000021   E0           MOVX    A,@DPTR
   \   000022   D2E0         SETB    0xE0 /* A   */.0
   \   000024   F0           MOVX    @DPTR,A
   \   000025   8007         SJMP    ??SetupPacketInterruptHandler_1
   1007              else 
   1008              	bUSBCTL &= ~USBCTL_DIR;
   \                     ??SetupPacketInterruptHandler_0:
   \   000027   90FFFC       MOV     DPTR,#-0x4
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   C2E0         CLR     0xE0 /* A   */.0
   \   00002D   F0           MOVX    @DPTR,A
   1009          
   1010          	// Clear the bStatusAction to indicate that, at this point, nothing is 
   1011          	// happening (it may be set to DATA_OUT by specific functions that
   1012          	// expect a DATA packet following the setup packet).
   1013              bStatusAction = STATUS_ACTION_NOTHING;
   \                     ??SetupPacketInterruptHandler_1:
   \   00002E   7400         MOV     A,#0x0
   \   000030   90....       MOV     DPTR,#bStatusAction
   \   000033   F0           MOVX    @DPTR,A
   1014          
   1015          	// Call the function that determines which function should be called to
   1016          	// handle the specific USB request.
   1017              usbDecodeAndProcessUsbRequest();
   \   000034                ; Setup parameters for call to function usbDecodeAndProcessUsbRequest
   \   000034   12....       LCALL   usbDecodeAndProcessUsbRequest
   1018          }
   \   000037   D083         POP     DPH
   \   000039   D082         POP     DPL
   \   00003B   22           RET
   1019          
   1020          /***************************************************************************
   1021           * Function:   OEP0InterruptHandler()                                      *
   1022           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
   1023           * Description: This function is called by the UsbInterrupt function when  *
   1024           *    a USB interrupt is called by OEP0.  This will happen once a data     *
   1025           *    transfer has been initialized by a USB function handler by calling   *
   1026           *    usbReceiveDataPacketOnEP0.                                           *
   1027           ***************************************************************************/
   1028          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   1029          void OEP0InterruptHandler(void)
   \                     OEP0InterruptHandler:
   1030          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1031          	// We clear the IEP0 byte count since we have nothing to send out.
   1032              tEndPoint0DescriptorBlock.bIEPBCNT = 0x00;
   \   000004   7400         MOV     A,#0x0
   \   000006   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 1)
   \   000009   F0           MOVX    @DPTR,A
   1033          
   1034          	// We now handle the interrupt based on the bStatusAction condition.
   1035          	// If we are in a DATA_OUT condition, we call the usbReceiveNextPacketOnEP0
   1036          	// function to copy the data payload to its correct buffer.  If we are
   1037          	// not expecting any data on OEP0, we set the stall flag to stall the
   1038          	// endpoint and abort any additional data that may otherwise be
   1039          	// sent.
   1040              if(bStatusAction == STATUS_ACTION_DATA_OUT) 
   \   00000A   90....       MOV     DPTR,#bStatusAction
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6402         XRL     A,#0x2
   \   000010   7005         JNZ     ??OEP0InterruptHandler_0
   1041              	usbReceiveNextPacketOnOEP0(); // Handle this data packet
   \   000012                ; Setup parameters for call to function usbReceiveNextPacketOnOEP0
   \   000012   12....       LCALL   usbReceiveNextPacketOnOEP0
   \   000015   8007         SJMP    ??OEP0InterruptHandler_1
   1042              else 
   1043              	tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL; // We weren't expecting data
   \                     ??OEP0InterruptHandler_0:
   \   000017   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 2)
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   D2E3         SETB    0xE0 /* A   */.3
   \   00001D   F0           MOVX    @DPTR,A
   1044          }
   \                     ??OEP0InterruptHandler_1:
   \   00001E   D083         POP     DPH
   \   000020   D082         POP     DPL
   \   000022   22           RET
   1045          
   1046          /***************************************************************************
   1047           * Function:   IEP0InterruptHandler()                                      *
   1048           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
   1049           * Description: This function is called by the UsbInterrupt function when  *
   1050           *    a USB interrupt is caused by IEP0.  This will happen once the data   *
   1051           *    sent by calling usbSendNextPacketOnIEP0 and means the previous data  *
   1052           *    packet has been sent.  At that point, there are two conditions:      *
   1053           *    either there is more data to send or there isn't.  If there is, we   *
   1054           *    call usbSendNextPacketOnIEP0 to send the next packet of data.  If    *
   1055           *    there isn't anymore data, we stall.  However, if the bStatusAction   *
   1056           *    condition indicates that we were changing the devices address, we    *
   1057           *    do so at this point.                                                 *
   1058           ***************************************************************************/
   1059          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   1060          void IEP0InterruptHandler(void)
   \                     IEP0InterruptHandler:
   1061          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1062          	// We clear the OEP0 byte count since we are not expecting any data.
   1063              tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
   \   000004   7400         MOV     A,#0x0
   \   000006   90....       MOV     DPTR,#(tEndPoint0DescriptorBlock + 3)
   \   000009   F0           MOVX    @DPTR,A
   1064          
   1065          	// We now handle the interrupt based on the bStatusAction condition.
   1066          	// If we are in a DATA_IN condition, we call the usbSendNextPacketOnIEP0  
   1067          	// function to send the next data payload packet.  If we are in a
   1068          	// Set Address mode, we modify the address.  In any other case, we've
   1069          	// sent all teh data we had to send, so we stall the endpoint to indicate
   1070          	// there is no more data to send.
   1071              if(bStatusAction == STATUS_ACTION_DATA_IN) 
   \   00000A   90....       MOV     DPTR,#bStatusAction
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6401         XRL     A,#0x1
   \   000010   7005         JNZ     ??IEP0InterruptHandler_0
   1072              	usbSendNextPacketOnIEP0(); // Send the next data packet
   \   000012                ; Setup parameters for call to function usbSendNextPacketOnIEP0
   \   000012   12....       LCALL   usbSendNextPacketOnIEP0
   \   000015   8019         SJMP    ??IEP0InterruptHandler_1
   1073              else if(bStatusAction == STATUS_ACTION_SET_ADDRESS) 
   \                     ??IEP0InterruptHandler_0:
   \   000017   90....       MOV     DPTR,#bStatusAction
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   6403         XRL     A,#0x3
   \   00001D   700A         JNZ     ??IEP0InterruptHandler_2
   1074              	bFUNADR = bUsbDeviceAddress; // Set the device's address
   \   00001F   90....       MOV     DPTR,#bUsbDeviceAddress
   \   000022   E0           MOVX    A,@DPTR
   \   000023   90FFFF       MOV     DPTR,#-0x1
   \   000026   F0           MOVX    @DPTR,A
   \   000027   8007         SJMP    ??IEP0InterruptHandler_1
   1075              else 
   1076              	tEndPoint0DescriptorBlock.bIEPCNFG |= EPCNF_STALL; // No more data to send
   \                     ??IEP0InterruptHandler_2:
   \   000029   90....       MOV     DPTR,#tEndPoint0DescriptorBlock
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   D2E3         SETB    0xE0 /* A   */.3
   \   00002F   F0           MOVX    @DPTR,A
   1077          }
   \                     ??IEP0InterruptHandler_1:
   \   000030   D083         POP     DPH
   \   000032   D082         POP     DPL
   \   000034   22           RET
   1078          
   1079          /***************************************************************************
   1080           * Function:   USBInterrupt                                                *
   1081           * Programmer: Craig Steiner (csteiner@vaultbbs.com)                       *
   1082           * Description: Handles the USB interrupts generated by the USB sectiob of *
   1083           *    the part.  This is actually External 0 interrupt on the 8051 at      *
   1084           *    0x0003 in memory, but is used exclusively for USB interrupts on the  *
   1085           *    TUSB2136.                                                            * 
   1086           *                                                                         * 
   1087           * Note: VECINT is cleared after being handled successfully so that the    * 
   1088           *       next USB-related interrupt is made available to the handler.      *  
   1089           ***************************************************************************/
   1090          
   1091          #pragma vector=0x0003

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   1092          __interrupt void USBInterrupt(void)
   \                     USBInterrupt:
   1093          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
   1094          	// Disable all interrupts because this is critical code
   1095          	IE_bit.EA = DISABLE;
   \   000007   C2AF         CLR     0xa8.7
   1096          
   1097          	// Select the appropriate interrupt handler depending on the VECINT value
   1098              switch (bVECINT)
   \   000009   90FF92       MOV     DPTR,#-0x6e
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for USBInterrupt>_0`:
   \   000010   00           DB        0
   \   000011   09           DB        9
   \   000012   12           DB        18
   \   000013   ....         DW        ??USBInterrupt_0
   \   000015   22           DB        34
   \   000016   ....         DW        ??USBInterrupt_0
   \   000018   30           DB        48
   \   000019   ....         DW        ??USBInterrupt_1
   \   00001B   32           DB        50
   \   00001C   ....         DW        ??USBInterrupt_2
   \   00001E   38           DB        56
   \   00001F   ....         DW        ??USBInterrupt_3
   \   000021   3A           DB        58
   \   000022   ....         DW        ??USBInterrupt_4
   \   000024   3C           DB        60
   \   000025   ....         DW        ??USBInterrupt_5
   \   000027   44           DB        68
   \   000028   ....         DW        ??USBInterrupt_6
   \   00002A   46           DB        70
   \   00002B   ....         DW        ??USBInterrupt_7
   \   00002D   ....         DW        ??USBInterrupt_8
   1099              	{
   1100          		case VECINT_OUTPUT_ENDPOINT0:
   1101          			bVECINT  = 0x00;
   \                     ??USBInterrupt_7:
   \   00002F   7400         MOV     A,#0x0
   \   000031   90FF92       MOV     DPTR,#-0x6e
   \   000034   F0           MOVX    @DPTR,A
   1102          			OEP0InterruptHandler();
   \   000035                ; Setup parameters for call to function OEP0InterruptHandler
   \   000035   12....       LCALL   OEP0InterruptHandler
   \   000038   8071         SJMP    ??USBInterrupt_9
   1103          			break;
   1104          
   1105                  case VECINT_INPUT_ENDPOINT0:
   1106          			bVECINT  = 0x00;
   \                     ??USBInterrupt_6:
   \   00003A   7400         MOV     A,#0x0
   \   00003C   90FF92       MOV     DPTR,#-0x6e
   \   00003F   F0           MOVX    @DPTR,A
   1107          			IEP0InterruptHandler();
   \   000040                ; Setup parameters for call to function IEP0InterruptHandler
   \   000040   12....       LCALL   IEP0InterruptHandler
   \   000043   8066         SJMP    ??USBInterrupt_9
   1108          			break;
   1109          
   1110          		case VECINT_INPUT_ENDPOINT1:
   1111          		case 0x12:
   1112          			bVECINT = 0x00;
   \                     ??USBInterrupt_0:
   \   000045   7400         MOV     A,#0x0
   \   000047   90FF92       MOV     DPTR,#-0x6e
   \   00004A   F0           MOVX    @DPTR,A
   1113          			IEP1InterruptHandler();
   \   00004B                ; Setup parameters for call to function IEP1InterruptHandler
   \   00004B   12....       LCALL   IEP1InterruptHandler
   \   00004E   805B         SJMP    ??USBInterrupt_9
   1114          			break;
   1115          
   1116                  case VECINT_STPOW_PACKET_RECEIVED:
   1117          			bVECINT  = 0x00;
   \                     ??USBInterrupt_1:
   \   000050   7400         MOV     A,#0x0
   \   000052   90FF92       MOV     DPTR,#-0x6e
   \   000055   F0           MOVX    @DPTR,A
   1118          			bUSBSTA = USBSTA_STPOW;
   \   000056   7401         MOV     A,#0x1
   \   000058   90FFFE       MOV     DPTR,#-0x2
   \   00005B   F0           MOVX    @DPTR,A
   1119          			SetupPacketInterruptHandler();
   \   00005C                ; Setup parameters for call to function SetupPacketInterruptHandler
   \   00005C   12....       LCALL   SetupPacketInterruptHandler
   \   00005F   804A         SJMP    ??USBInterrupt_9
   1120          			break;
   1121          
   1122                  case VECINT_SETUP_PACKET_RECEIVED:
   1123                  // hardware will NAK data stage, no matter NAK bit in I/OEPBCNT
   1124          
   1125          			bVECINT  = 0x00;
   \                     ??USBInterrupt_2:
   \   000061   7400         MOV     A,#0x0
   \   000063   90FF92       MOV     DPTR,#-0x6e
   \   000066   F0           MOVX    @DPTR,A
   1126          //			bUSBSTA = USBSTA_SETUP; // from now, hardware will refer NAK bit in I/OEPBCNT
   1127          			SetupPacketInterruptHandler();
   \   000067                ; Setup parameters for call to function SetupPacketInterruptHandler
   \   000067   12....       LCALL   SetupPacketInterruptHandler
   \   00006A   803F         SJMP    ??USBInterrupt_9
   1128          			break;
   1129          
   1130                  case VECINT_RSTR_INTERRUPT:
   1131          			bVECINT  = 0x00;
   \                     ??USBInterrupt_5:
   \   00006C   7400         MOV     A,#0x0
   \   00006E   90FF92       MOV     DPTR,#-0x6e
   \   000071   F0           MOVX    @DPTR,A
   1132          			bUSBSTA = USBSTA_RSTR;
   \   000072   7480         MOV     A,#-0x80
   \   000074   90FFFE       MOV     DPTR,#-0x2
   \   000077   F0           MOVX    @DPTR,A
   1133          			UsbReset();
   \   000078                ; Setup parameters for call to function UsbReset
   \   000078   12....       LCALL   UsbReset
   \   00007B   802E         SJMP    ??USBInterrupt_9
   1134          			break;
   1135          		
   1136          		case VECINT_RESR_INTERRUPT:
   1137          			bVECINT = 0x00;
   \                     ??USBInterrupt_3:
   \   00007D   7400         MOV     A,#0x0
   \   00007F   90FF92       MOV     DPTR,#-0x6e
   \   000082   F0           MOVX    @DPTR,A
   1138          			bUSBSTA = USBSTA_RESR;
   \   000083   7420         MOV     A,#0x20
   \   000085   90FFFE       MOV     DPTR,#-0x2
   \   000088   F0           MOVX    @DPTR,A
   1139          			bSuspended = FALSE;
   \   000089   7400         MOV     A,#0x0
   \   00008B   90....       MOV     DPTR,#bSuspended
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   801A         SJMP    ??USBInterrupt_9
   1140          			break;
   1141          		
   1142          		case VECINT_SUSR_INTERRUPT:
   1143          			bVECINT = 0x00;
   \                     ??USBInterrupt_4:
   \   000091   7400         MOV     A,#0x0
   \   000093   90FF92       MOV     DPTR,#-0x6e
   \   000096   F0           MOVX    @DPTR,A
   1144          			bUSBSTA = USBSTA_SUSR;
   \   000097   7440         MOV     A,#0x40
   \   000099   90FFFE       MOV     DPTR,#-0x2
   \   00009C   F0           MOVX    @DPTR,A
   1145          			bSuspended = TRUE;
   \   00009D   7401         MOV     A,#0x1
   \   00009F   90....       MOV     DPTR,#bSuspended
   \   0000A2   F0           MOVX    @DPTR,A
   \   0000A3   8006         SJMP    ??USBInterrupt_9
   1146          			break;
   1147          
   1148          		default:
   1149          			bVECINT  = 0x00;
   \                     ??USBInterrupt_8:
   \   0000A5   7400         MOV     A,#0x0
   \   0000A7   90FF92       MOV     DPTR,#-0x6e
   \   0000AA   F0           MOVX    @DPTR,A
   1150          			break;
   1151          		}
   1152          
   1153          	// End of ciritical code section, reenable interrupts
   1154              IE_bit.EA = ENABLE;
   \                     ??USBInterrupt_9:
   \   0000AB   D2AF         SETB    0xa8.7
   1155          }
   \   0000AD   7F01         MOV     R7,#0x1
   \   0000AF   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   0000B2                REQUIRE _A_IE
   1156          #pragma vector=0x0013

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   1157          __interrupt void P33Interrupt(void)
   \                     P33Interrupt:
   1158          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   C082         PUSH    DPL
   \   000006   C083         PUSH    DPH
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
   1159          	// Disable all interrupts because this is critical code
   1160          
   1161          	bUSBCTL |= USBCTL_RWUP;
   \   000008   90FFFC       MOV     DPTR,#-0x4
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   D2E5         SETB    0xE0 /* A   */.5
   \   00000E   F0           MOVX    @DPTR,A
   1162          	bSuspended = FALSE;
   \   00000F   7400         MOV     A,#0x0
   \   000011   90....       MOV     DPTR,#bSuspended
   \   000014   F0           MOVX    @DPTR,A
   1163          }
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   D0D0         POP     PSW
   \   00001B   D0E0         POP     A
   \   00001D   32           RETI

   \                                 In  segment INTVEC, offset 0x3, root
   \                     `??USBInterrupt??INTVEC 3`:
   \   000003   02....       LJMP       (USBInterrupt)

   \                                 In  segment INTVEC, offset 0x13, root
   \                     `??P33Interrupt??INTVEC 19`:
   \   000013   02....       LJMP       (P33Interrupt)

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gbProtocol>`:
   \   000000   01           DB 1

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     IEP0InterruptHandler               2      0      0
       -> usbSendNextPacketOnIEP0       4      0      0
     OEP0InterruptHandler               2      0      0
       -> usbReceiveNextPacketOnOEP0
                                        4      0      0
     P33Interrupt                       4      0      0
     SetupPacketInterruptHandler        2      0      0
       -> usbDecodeAndProcessUsbRequest
                                        4      0      0
     USBInterrupt                      15      0      0
       -> OEP0InterruptHandler         30      0      0
       -> IEP0InterruptHandler         30      0      0
       -> IEP1InterruptHandler         30      0      0
       -> SetupPacketInterruptHandler
                                       30      0      0
       -> SetupPacketInterruptHandler
                                       30      0      0
       -> UsbReset                     30      0      0
     usbClearEndpointHalt               2      0      0
       -> usbSendZeroLengthPacketOnIEP0
                                        4      0      0
     usbClearRemoteWakeup               2      0      0
       -> usbSendZeroLengthPacketOnIEP0
                                        4      0      0
     usbDecodeAndProcessUsbRequest      0      0     11
     usbGetConfiguration                2      0      0
       -> usbSendDataPacketOnEP0        4      0      0
     usbGetConfigurationDescriptor      1      0      9
       -> usbSendDataPacketOnEP0        0      0     18
     usbGetDeviceDescriptor             1      0      9
       -> usbSendDataPacketOnEP0        0      0     18
     usbGetDeviceStatus                 2      0      0
       -> usbSendDataPacketOnEP0        4      0      0
     usbGetEndpointStatus               2      0      2
       -> usbSendDataPacketOnEP0        4      0      4
     usbGetHIDDescriptor                1      0      9
       -> usbSendDataPacketOnEP0        0      0     18
     usbGetIdle                         2      0      0
       -> usbSendDataPacketOnEP0        4      0      0
     usbGetInterface                    2      0      0
       -> usbSendDataPacketOnEP0        4      0      0
     usbGetInterfaceStatus              2      0      2
       -> usbSendDataPacketOnEP0        4      0      4
     usbGetProtocol                     2      0      0
       -> usbSendDataPacketOnEP0        4      0      0
     usbGetReportDescriptor             2      0      0
       -> usbSendDataPacketOnEP0        4      0      0
     usbGetStringDescriptor             1      0      9
       -> strlen                        2      0     18
       -> strlen                        2      0     18
       -> strlen                        2      0     18
       -> strlen                        2      0     18
       -> strlen                        2      0     18
       -> strlen                        2      0     18
       -> usbSendDataPacketOnEP0        0      0     18
     usbNonStandardRequest              0      0      0
       -> usbStallEndpoint0             0      0      0
     usbReceiveDataPacketOnEP0          2      0      0
     usbReceiveNextPacketOnOEP0         1      0      9
       -> OEP0SetLEDs                   0      0     18
     usbSendDataPacketOnEP0             2      0      9
       -> usbSendNextPacketOnIEP0       4      0      0
     usbSendNextPacketOnIEP0            1      0      9
     usbSendZeroLengthPacketOnIEP0      2      0      0
     usbSetAddress                      2      0      0
       -> usbSendZeroLengthPacketOnIEP0
                                        4      0      0
       -> usbStallEndpoint0             4      0      0
     usbSetConfiguration                2      0      0
       -> usbSendZeroLengthPacketOnIEP0
                                        4      0      0
     usbSetEndpointHalt                 2      0      0
       -> usbSendZeroLengthPacketOnIEP0
                                        4      0      0
     usbSetIdle                         2      0      0
       -> usbSendZeroLengthPacketOnIEP0
                                        4      0      0
     usbSetInterface                    2      0      0
       -> usbSendZeroLengthPacketOnIEP0
                                        4      0      0
     usbSetProtocol                     2      0      0
       -> usbSendZeroLengthPacketOnIEP0
                                        4      0      0
     usbSetRemoteWakeup                 2      0      0
       -> usbSendZeroLengthPacketOnIEP0
                                        4      0      0
     usbSetReport                       2      0      0
       -> usbReceiveDataPacketOnEP0     4      0      0
     usbStallEndpoint0                  2      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_IE                             1
     tSetupPacket                      8
     tEndPoint0DescriptorBlock         4
     tInputEndPointDescriptorBlock    24
     tOutputEndPointDescriptorBlock   24
     abIEP0Buffer                      8
     abOEP0Buffer                      8
     abDescriptor                     18
     pbXBufferAddress                 64
     pbYBufferAddress                 64
     deviceReady                       1
     bSuspended                        1
     bStatusAction                     1
     bUsbDeviceAddress                 1
     wBytesRemainingOnIEP0             2
     bHostAskMoreDataThanAvailable     2
     pbIEP0Buffer                      2
     bConfigurationNumber              1
     bInterfaceNumber                  1
     wDeviceFeatures                   2
     wBytesRemainingOnOEP0             2
     pbOEP0Buffer                      2
     usbGetConfiguration              26
     usbSetConfiguration              27
     usbSetReport                     26
     usbGetDeviceDescriptor          547
     usbGetHIDDescriptor              85
     usbGetConfigurationDescriptor    85
     usbGetStringDescriptor          921
     usbGetReportDescriptor           32
     gbIdleRateL                       1
     gbIdleRateH                       1
     usbSetIdle                       28
     usbGetIdle                       26
     gbProtocol                        1
     usbSetProtocol                   20
     usbGetProtocol                   26
     usbGetInterface                  26
     usbSetInterface                  27
     usbGetDeviceStatus               26
     usbSetRemoteWakeup               38
     usbClearRemoteWakeup             38
     usbGetInterfaceStatus            62
     usbSetAddress                    48
     usbSetEndpointHalt               19
     usbClearEndpointHalt             19
     usbGetEndpointStatus             76
     usbNonStandardRequest             4
     tUsbRequestList                 253
     usbDecodeAndProcessUsbRequest   169
     usbStallEndpoint0                23
     usbReceiveDataPacketOnEP0        56
     usbReceiveNextPacketOnOEP0      179
     usbSendZeroLengthPacketOnIEP0    31
     usbSendDataPacketOnEP0           80
     usbSendNextPacketOnIEP0         225
     SetupPacketInterruptHandler      60
     OEP0InterruptHandler             35
     IEP0InterruptHandler             53
     USBInterrupt                    178
     P33Interrupt                     30
     ??USBInterrupt??INTVEC 3          3
     ??P33Interrupt??INTVEC 19         3
     ?<Initializer for gbProtocol>     1

 
   253 bytes in segment CODE_C
     6 bytes in segment INTVEC
 3 351 bytes in segment NEAR_CODE
     1 byte  in segment SFR_AN
    18 bytes in segment TUSB2136_DESC_SEG
     4 bytes in segment TUSB2136_EP0_EDB_SEG
     8 bytes in segment TUSB2136_IEP0BUFFER_SEG
    24 bytes in segment TUSB2136_IEP_EDB_SEG
     8 bytes in segment TUSB2136_OEP0BUFFER_SEG
    64 bytes in segment TUSB2136_OEP1_X_BUFFER_SEG
    64 bytes in segment TUSB2136_OEP1_Y_BUFFER_SEG
    24 bytes in segment TUSB2136_OEP_EDB_SEG
     8 bytes in segment TUSB2136_SETUPPACKET_SEG
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
    20 bytes in segment XDATA_Z
 
 3 605 bytes of CODE  memory (+ 6 bytes shared)
     0 bytes of DATA  memory (+ 1 byte  shared)
   243 bytes of XDATA memory

Errors: none
Warnings: none
