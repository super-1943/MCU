C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE USB
OBJECT MODULE PLACED IN usb.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE usb.c BROWSE DEFINE(WORK_AROUND_192) DEBUG OBJECTEXTEND CODE

line level    source

   1          #include "reg52modified.h"
   2          #include "types.h"
   3          #include "tusb2136.h"
   4          #include "usb.h"
   5          #include "serial.h"
   6          
   7          
   8          tDEVICE_REQUEST xdata tSetupPacket _at_ 0xff00;
   9          tEDB0 xdata tEndPoint0DescriptorBlock  _at_ 0xff80;
  10          tEDB xdata tInputEndPointDescriptorBlock[3]_at_ 0xff48;
  11          tEDB xdata tOutputEndPointDescriptorBlock[3] _at_ 0xff08;
  12          BYTE xdata abIEP0Buffer[EP0_MAX_PACKET_SIZE]  _at_ 0xfef8;
  13          BYTE xdata abOEP0Buffer[EP0_MAX_PACKET_SIZE] _at_ 0xfef0;
  14          BYTE xdata abDescriptor[SIZEOF_DEVICE_DESCRIPTOR]  _at_ 0xfe80;
  15          BYTE xdata pbOutBufferAddress[EP_MAX_PACKET_SIZE] _at_ 0xfd80; // ENDPOINT 1 OUT X buffer
  16          BYTE xdata pb48BufferAddress[EP_MAX_PACKET_SIZE] _at_ 0xfdc0;  // use ENDPOINT 1 OUT Y buffer space for bu
             -ffering the 1st 
  17                                                                         // half of 96-byte block write for UCD9110 
             -flash programming
  18          BYTE xdata pbInBufferAddress[EP_MAX_PACKET_SIZE] _at_ 0xfe00;  // ENDPOINT 1 IN X buffer
  19          
  20          #ifdef WORK_AROUND_192
  21          BYTE xdata pb145BufferAddress[160] _at_ 0xfe40;  // WW
  22          #endif
  23          
  24          /***************************************************************************
  25           * Section:    Declarations                                                *
  26           * Programmer: Craig Steiner (csteiner@vaultbbs.com)                       *
  27           * Description: This section of the code declares global and external      *
  28           *    variables, as well as functions, etc.                                *
  29           ***************************************************************************/
  30          
  31          // EXTERNAL DECLARATIONS 
  32          extern BYTE code abromReportDescriptor[SIZEOF_REPORT_DESCRIPTOR];
  33          extern unsigned char intFlags; // From keyboard.c
  34          extern unsigned char otherFlags; // From keyboard.c
  35          extern void IEP1InterruptHandler(void); // From keyboard.c
  36          extern void UsbReset(void); // From usbinit.c
  37          extern void OEP0SetLEDs(void);
  38          extern BYTE code abromReportDescriptor[SIZEOF_REPORT_DESCRIPTOR];
  39          extern BYTE code abromConfigurationDescriptorGroup[SIZEOF_BOOTCODE_CONFIG_DESC_GROUP];
  40          extern BYTE code abromDeviceDescriptor[SIZEOF_DEVICE_DESCRIPTOR];
  41          extern BYTE code LanguageId[];
  42          extern BYTE code ProductStringDescriptor[];
  43          extern BYTE code SerialNumberStringDescriptor[];
  44          extern BYTE code ManufacturerStringDescriptor[];
  45          
  46          // for PMBus/SMBus transactions. WW
  47          extern BYTE i2c_start(void);
  48          extern BYTE i2c_restart(void);
  49          extern BYTE i2c_stop(void);
  50          extern BYTE i2c_write_bytes(BYTE num_of_bytes, BYTE * source_buf);
  51          extern BYTE i2c_read_bytes(BYTE num_of_bytes, BYTE * destination_buf, BYTE nack_byte);
  52          extern void i2c_reset(void);
  53          extern BYTE calc_pec(BYTE start_crc8, BYTE length, BYTE* start_addr);
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 2   

  54          
  55          
  56          extern BYTE eeprom_read(WORD wAddress, BYTE bNumber, PBYTE pbDataArray);
  57          extern BYTE eeprom_write(WORD wAddress, BYTE bNumber, PBYTE pbDataArray);
  58          
  59          
  60          // GLOBAL VARIABLE DECLARATIONS
  61          bit deviceReady = FALSE;                // Indicates whether the device has been
  62                                                                          // properly initialized on the USB bus.
  63          bit bSuspended = FALSE;             // Indicates whether the device is suspended or not
  64          BYTE bStatusAction;                             // Indicates the current state of sending
  65                                                                          // receiving data packets.
  66          BYTE bUsbDeviceAddress;                 // The device's USB address.
  67          WORD wBytesRemainingOnIEP0;     // For endpoint zero transmitter only
  68                                          // Holds count of bytes remaining to be
  69                                          // transmitted by endpoint 0.  A value
  70                                          // of 0 means that a 0-length data packet
  71                                          // A value of 0xFFFF means that transfer
  72                                          // is complete.
  73          bit bHostAskMoreDataThanAvailable;
  74                                          // If host ask more data then TUSB2136 has
  75                                          // It will send one zero-length packet
  76                                          // if the asked lenght is a multiple of
  77                                          // max. size of endpoint 0
  78          PBYTE pbIEP0Buffer;             // A buffer pointer to input end point 0
  79                                          // Data sent back to host is copied from
  80                                          // this pointed memory location
  81          BYTE bConfigurationNumber = 0;  // Set to 1 when USB device has been
  82                                          // configured, set to 0 when unconfigured
  83          BYTE bInterfaceNumber = 0;              // The interface number selected
  84          WORD wDeviceFeatures = 0;               // The device features
  85          WORD wBytesRemainingOnOEP0;     // For endpoint zero transmitter only
  86                                          // Holds count of bytes remaining to be
  87                                          // received by endpoint 0.  A value
  88                                          // of 0 means that a 0-length data packet
  89                                          // A value of 0xFFFF means that transfer
  90          PBYTE pbOEP0Buffer;             // A buffer pointer to output end point 0
  91                                          // Data sent from host is copied to
  92                                          // this pointed memory location
  93                                          // is complete.
  94          
  95          WORD pmb_clk_low_stretch_timer;
  96          BYTE previous_crc8;
  97          bit PMBus_Error; // 0 - success; 1 - fail. WW
  98          bit PMBus_Busy; // 1 - busy; 0 - idle. WW
  99          bit PMBus_Group_Command_Busy; // 1 - busy; 0 - idle. WW
 100          bit With_PEC; 
 101          bit Set_400KHz; // 1 for 400KHz; 0 for 100KHz
 102          
 103          BYTE volatile bdata my_bits; // create a global bit-addressable variable. WW
 104          sbit my_bit7 = my_bits ^ 7;
 105          sbit my_bit6 = my_bits ^ 6;
 106          sbit my_bit5 = my_bits ^ 5;
 107          sbit my_bit4 = my_bits ^ 4;
 108          sbit my_bit3 = my_bits ^ 3;
 109          sbit my_bit2 = my_bits ^ 2;
 110          sbit my_bit1 = my_bits ^ 1;
 111          sbit my_bit0 = my_bits ^ 0;
 112          
 113          
 114          #define usbClearOEP0ByteCount tEndPoint0DescriptorBlock.bOEPBCNT = 0x00
 115          #define usbStallOEP0          tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 3   

 116          
 117          void usbGetConfiguration(void);
 118          void usbSetConfiguration(void);
 119          void usbSetReport(void);
 120          void OEP1InterruptHandler(void);
 121          void usbGetDeviceDescriptor(void);
 122          void usbGetHIDDescriptor(void);
 123          void usbGetConfigurationDescriptor(void);
 124          void usbGetStringDescriptor(void);
 125          void usbGetReportDescriptor(void);
 126          void usbSetIdle(void);
 127          void usbGetIdle(void);
 128          void usbSetProtocol(void);
 129          void usbGetProtocol(void);
 130          void usbGetInterface(void);
 131          void usbSetInterface(void);
 132          void usbGetDeviceStatus(void);
 133          void usbSetRemoteWakeup(void);
 134          void usbClearRemoteWakeup(void);
 135          void usbGetInterfaceStatus(void);
 136          void usbSetAddress(void);
 137          void usbSetEndpointHalt(void);
 138          void usbClearEndpointHalt(void);
 139          void usbGetEndpointStatus(void);
 140          void usbNonStandardRequest(void);
 141          void usbDecodeAndProcessUsbRequest(void);
 142          void usbReceiveNextPacketOnOEP0(void);
 143          void SetupPacketInterruptHandler(void);
 144          void OEP0InterruptHandler(void);
 145          void IEP0InterruptHandler(void);
 146          
 147          void usbReceiveDataPacketOnEP0(PBYTE pbBuffer);
 148          void usbStallEndpoint0(void);
 149          void usbSendZeroLengthPacketOnIEP0(void);
 150          void usbSendNextPacketOnIEP0(void);
 151          void usbSendDataPacketOnEP0(PBYTE pbBuffer);
 152          
 153          
 154          
 155          
 156          /***************************************************************************
 157           * Section:    USB REQUEST FUNCTIONS                                       *
 158           * Programmer: Craig Steiner (csteiner@vaultbbs.com) based on code by      *
 159           *             Lobo Tai (lobotai@ti.com)                                   *
 160           * Description: The functions in this section of code are called by the    *
 161           *    usbDecodeAndProcessUsbRequest function when a Setup packet is        *
 162           *    received.  Each function handles a specific USB/Class/Endpoint       *
 163           *    function.                                                            *
 164           ***************************************************************************/
 165          
 166          // The Get/Set configuration functions allow the host to select one of various
 167          // configurations that the keyboard may support.  This firmware only supports
 168          // one configuration, but the following functions allow the firmware to accept
 169          // any given configuration number.  The code, as-is, will function identically
 170          // in any given configuration, but additional configurations may be supported
 171          // by simply adding support for the configurations, presumably in keyboard.c.
 172          
 173          void usbGetConfiguration(void)
 174          {
 175   1              rs232_printstr("GetCFG\r\n");
 176   1          wBytesRemainingOnIEP0 = 1;
 177   1          usbSendDataPacketOnEP0((PBYTE) &bConfigurationNumber);
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 4   

 178   1      }
 179          
 180          void usbSetConfiguration(void)
 181          {
 182   1              rs232_printstr("SetCFG\r\n");
 183   1          usbStallOEP0;
 184   1          bConfigurationNumber = tSetupPacket.bValueL;
 185   1              tInputEndPointDescriptorBlock[0].bEPCNF |= EPCNF_UBME|EPCNF_USBIE;      
 186   1              tInputEndPointDescriptorBlock[0].bEPBCTX = 0x00;
 187   1          usbSendZeroLengthPacketOnIEP0();
 188   1      }
 189          
 190          
 191          // we don't use this function. WW
 192          // The Set_Report request is sent by the host to a typical HID device,
 193          // such as this keyboard, to update the LEDs that correspond to the
 194          // scroll lock, caps lock, and num lock.  When the Set_Report setup
 195          // packet is received, we initiate a "Receive Data Packet" sequence
 196          // since the actual 1-byte data value will be in the following
 197          // packet on OEP0.  Thus we initicate that we will receive 1 byte
 198          // (since the LED data is contained in a single byte) and we
 199          // instruct the receive routine to receive the data at the address
 200          // at which the bLED variable is located.  Thus bLed will automatically
 201          // be updated with the new value after the transfer is completed.
 202          void usbSetReport(void)
 203          {
 204   1              rs232_printstr("SetRp\r\n");
 205   1          wBytesRemainingOnOEP0 = 1;
 206   1          usbReceiveDataPacketOnEP0((PBYTE) 0xFEA0); // point to output endpoint 2 X buffer since we don't use i
             -t
 207   1      }
 208          
 209          void OEP1InterruptHandler(void)
 210          {
 211   1          // clear NAK bit so that more OUT packet can go out of the host
 212   1          tOutputEndPointDescriptorBlock[0].bEPBCTX = 0x00;
 213   1      }
 214          
 215          
 216          // The following functions are called at initial device enumeration, and are used
 217          // to obtain the device, configuration, and string descriptors from the
 218          // device.
 219          void usbGetDeviceDescriptor(void)
 220          {
 221   1              
 222   1              BYTE bTemp;
 223   1              rs232_printstr("GDD\r\n");
 224   1              // Copy the DEVICE DESCRIPTOR from program "ROM" to XRAM
 225   1          for(bTemp=0;bTemp<SIZEOF_DEVICE_DESCRIPTOR;bTemp++)
 226   1              abDescriptor[bTemp] = abromDeviceDescriptor[bTemp];
 227   1      
 228   1          usbClearOEP0ByteCount;
 229   1          wBytesRemainingOnIEP0 = SIZEOF_DEVICE_DESCRIPTOR;
 230   1          usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
 231   1          
 232   1          // Once the Device Descriptor has been sent, the device can essentially
 233   1          // function.  Thus we enable the deviceReady variable so that the main
 234   1          // code in keyboard.c knows that it can begin the service loop.
 235   1              deviceReady = TRUE;    
 236   1      }
 237          
 238          void usbGetHIDDescriptor(void)
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 5   

 239          {
 240   1              BYTE bTemp;
 241   1              // Copy the DEVICE DESCRIPTOR from program "ROM" to XRAM
 242   1          for(bTemp=0;bTemp<SIZEOF_DEVICE_DESCRIPTOR;bTemp++)
 243   1              abDescriptor[bTemp] = abromConfigurationDescriptorGroup[SIZEOF_CONFIG_DESCRIPTOR+SIZEOF_INTERFACE_
             -DESCRIPTOR + bTemp];
 244   1      
 245   1          usbClearOEP0ByteCount;
 246   1          wBytesRemainingOnIEP0 = SIZEOF_KEYBD_HID_DESCRIPTOR;
 247   1          usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
 248   1      }
 249          
 250          void usbGetConfigurationDescriptor(void)
 251          {
 252   1              BYTE bTemp;
 253   1              rs232_printstr("GDC\r\n");
 254   1              // Copy the DEVICE DESCRIPTOR from program "ROM" to XRAM
 255   1          for(bTemp=0;bTemp<abromConfigurationDescriptorGroup[2];bTemp++)
 256   1              abDescriptor[bTemp] = abromConfigurationDescriptorGroup[bTemp];
 257   1          usbClearOEP0ByteCount;
 258   1          wBytesRemainingOnIEP0 = SIZEOF_BOOTCODE_CONFIG_DESC_GROUP;
 259   1          usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
 260   1      }
 261          
 262          void usbGetStringDescriptor(void)
 263          {
 264   1              BYTE bTemp;
 265   1              rs232_printstr("GDS");
 266   1              rs232_printhex(tSetupPacket.bValueL);
 267   1              rs232_printstr("\r\n");
 268   1              // Copy the DEVICE DESCRIPTOR from program "ROM" to XRAM
 269   1              switch(tSetupPacket.bValueL)
 270   1              {
 271   2              case 0://Language ID    
 272   2                  for(bTemp=0;bTemp<LanguageId[0];bTemp++)
 273   2                      abDescriptor[bTemp] = LanguageId[bTemp];
 274   2                  usbClearOEP0ByteCount;
 275   2                  wBytesRemainingOnIEP0 = LanguageId[0];
 276   2                      break;
 277   2              case 1://Manufacturer
 278   2                  for(bTemp=0;bTemp<ManufacturerStringDescriptor[0];bTemp++)
 279   2                      abDescriptor[bTemp] = ManufacturerStringDescriptor[bTemp];
 280   2                  usbClearOEP0ByteCount;
 281   2                  wBytesRemainingOnIEP0 = ManufacturerStringDescriptor[0];
 282   2                      break;
 283   2              case 2://Prod
 284   2                  for(bTemp=0;bTemp<ProductStringDescriptor[0];bTemp++)
 285   2                      abDescriptor[bTemp] = ProductStringDescriptor[bTemp];
 286   2                  usbClearOEP0ByteCount;
 287   2                  wBytesRemainingOnIEP0 = ProductStringDescriptor[0];
 288   2                      break;
 289   2              case 3://serial
 290   2                  for(bTemp=0;bTemp<SerialNumberStringDescriptor[0];bTemp++)
 291   2                      abDescriptor[bTemp] = SerialNumberStringDescriptor[bTemp];
 292   2                  usbClearOEP0ByteCount;
 293   2                  wBytesRemainingOnIEP0 = SerialNumberStringDescriptor[0];
 294   2                      break;
 295   2              }
 296   1          usbSendDataPacketOnEP0((PBYTE)&abDescriptor);
 297   1      }
 298          
 299          void usbGetReportDescriptor(void)
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 6   

 300          {
 301   1          usbClearOEP0ByteCount;
 302   1              rs232_printstr("GDRp\r\n");
 303   1          wBytesRemainingOnIEP0 = SIZEOF_REPORT_DESCRIPTOR;
 304   1          usbSendDataPacketOnEP0((PBYTE)&abromReportDescriptor);
 305   1      }
 306          
 307          // Support of the following two functions is optional.  Supporting these
 308          // features allows the host to set the Idle rate.  By default, an HID
 309          // device should always report the current status of the keys, even
 310          // if they haven't changed.  However, to save bandwidth, Windows will
 311          // attempt to set the Idle rate to 0 which means the firmware should
 312          // only report keypresses when their state changes.
 313          
 314          BYTE gbIdleRateL;
 315          BYTE gbIdleRateH;
 316          void usbSetIdle(void)
 317          {
 318   1      //    usbStallOEP0;
 319   1              rs232_printstr("SETIDLE\r\n");
 320   1          gbIdleRateL = tSetupPacket.bValueL;
 321   1          gbIdleRateH = tSetupPacket.bValueH;
 322   1          usbSendZeroLengthPacketOnIEP0();
 323   1      }
 324          
 325          void usbGetIdle(void)
 326          {
 327   1              rs232_printstr("GETIDLE\r\n");
 328   1          wBytesRemainingOnIEP0 = 1;
 329   1          usbSendDataPacketOnEP0(&gbIdleRateH);
 330   1      }
 331          
 332          BYTE gbProtocol=1; // default is report protocol
 333          void usbSetProtocol(void)
 334          {
 335   1      //    usbStallOEP0;
 336   1              rs232_printstr("SET_Protocol\r\n");
 337   1          gbProtocol = tSetupPacket.bValueL;
 338   1          usbSendZeroLengthPacketOnIEP0();
 339   1      }
 340          
 341          void usbGetProtocol(void)
 342          {
 343   1              rs232_printstr("GET_Protocol\r\n");
 344   1          wBytesRemainingOnIEP0 = 1;
 345   1          usbSendDataPacketOnEP0(&gbProtocol);
 346   1      }
 347          
 348          // The Get/Set Interface, like the Get/Set Configuration, don't really
 349          // serve any real purpose in this firmware, but they are handled so
 350          // that modifications to the code may be made easily.  As-is, the host
 351          // may Set any interface number, and a Get Interface request will simply
 352          // return the value previously Set.
 353          
 354          void usbGetInterface(void)
 355          {
 356   1              rs232_printstr("GET_Interface\r\n");
 357   1          wBytesRemainingOnIEP0 = 1;
 358   1          usbSendDataPacketOnEP0((PBYTE) &bInterfaceNumber);
 359   1      }
 360          
 361          void usbSetInterface(void)
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 7   

 362          {
 363   1              rs232_printstr("SET_Interface\r\n");
 364   1          usbStallOEP0;                             // control write without data stage
 365   1          bInterfaceNumber = tSetupPacket.bIndexL;
 366   1          usbSendZeroLengthPacketOnIEP0();
 367   1      }
 368          
 369          // The GetDeviceStatus function is used to obtain the status of the
 370          // device.  The status is essentially the Remote Wakeup status as 
 371          // well as the "Self-powered" indicator.  The value returned by
 372          // GetDeviceStatus is modified by the SetRemoteWakeup and
 373          // ClearRemoteWakeup requests.
 374          
 375          void usbGetDeviceStatus(void)
 376          {
 377   1              rs232_printstr("GET_DevSta\r\n");
 378   1          wBytesRemainingOnIEP0 = 2;
 379   1              usbSendDataPacketOnEP0((PBYTE) &wDeviceFeatures);
 380   1      }
 381          
 382          void usbSetRemoteWakeup(void)
 383          {
 384   1              rs232_printstr("SET_RotWk\r\n");
 385   1              bUSBCTL |= USBCTL_RWE;
 386   1              wDeviceFeatures |= 0x0200;
 387   1          usbStallOEP0;
 388   1          usbSendZeroLengthPacketOnIEP0();
 389   1      }
 390          
 391          void usbClearRemoteWakeup(void)
 392          {
 393   1              rs232_printstr("CLR_RotWk\r\n");
 394   1              bUSBCTL &= ~USBCTL_RWE;
 395   1              wDeviceFeatures &= ~0x0200;
 396   1          usbStallOEP0;
 397   1          usbSendZeroLengthPacketOnIEP0();
 398   1      }
 399          
 400          // The GetInterfaceStatus always returns a 0 as a 2-byte value.
 401          
 402          void usbGetInterfaceStatus(void)
 403          {
 404   1              WORD wStatusBuffer = 0x00;    
 405   1              rs232_printstr("GetInfSta\r\n");        
 406   1          usbStallOEP0;
 407   1          wBytesRemainingOnIEP0 = 2;
 408   1              usbSendDataPacketOnEP0((PBYTE) &wStatusBuffer);
 409   1      }
 410          
 411          // The SetAddress request allows the host to assign an address to this device.
 412          // The device starts with an address of 00h, as do all USB devices, until
 413          // the host specifically assigns it another address.  This code handles that
 414          // assignment.
 415          
 416          void usbSetAddress(void)
 417          {
 418   1              rs232_printstr("SetAddr:");
 419   1              rs232_printhex(tSetupPacket.bValueL);
 420   1              rs232_printstr("\r\n");
 421   1          if(tSetupPacket.bValueL < 128)
 422   1              {
 423   2              bFUNADR = tSetupPacket.bValueL;
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 8   

 424   2              bUsbDeviceAddress = tSetupPacket.bValueL;
 425   2              bStatusAction = STATUS_ACTION_SET_ADDRESS;
 426   2              usbSendZeroLengthPacketOnIEP0();
 427   2              }
 428   1          else 
 429   1              usbStallEndpoint0();
 430   1      }
 431          
 432          // The SetEndpointHalt allows the USB host to instruct the device to stop sending
 433          // information on IEP1, which is how the firmware delivers keystrokes to the host.
 434          // This is used mostly if a device goes crazy and starts sending too much data,
 435          // this allows the host to shut the endpoint down.  All we do is set or clear
 436          // the endpoint enable bit appropriately.  The GetEndpointStatus request reports
 437          // the status of the endpoint which is affected by Set/Clear EndpointHalt requests.
 438          
 439          void usbSetEndpointHalt(void)
 440          {
 441   1              rs232_printstr("SetEpHalt\r\n");
 442   1              tInputEndPointDescriptorBlock[0].bEPCNF &= ~EPCNF_UBME;
 443   1          usbSendZeroLengthPacketOnIEP0();
 444   1      }
 445          
 446          void usbClearEndpointHalt(void)
 447          {
 448   1              rs232_printstr("ClrEpHalt\r\n");
 449   1              tInputEndPointDescriptorBlock[0].bEPCNF |= EPCNF_UBME;  
 450   1          usbSendZeroLengthPacketOnIEP0();
 451   1      }
 452          
 453          void usbGetEndpointStatus(void)
 454          {
 455   1              WORD wEndpointStatus = 0x0100;
 456   1              rs232_printstr("GetEpSta\r\n");
 457   1              if(tInputEndPointDescriptorBlock[0].bEPCNF & EPCNF_UBME)
 458   1                      wEndpointStatus = 0x0000;
 459   1      
 460   1          wBytesRemainingOnIEP0 = 2;
 461   1              usbSendDataPacketOnEP0((PBYTE) &wEndpointStatus);
 462   1      }
 463          
 464          // Any non-standard or unrecognized request will arrive at the following
 465          // function by default.  We automatically stall the endpoint to indicate
 466          // it's an invalid or unrecognized request.
 467          
 468          void usbNonStandardRequest(void)
 469          {
 470   1              rs232_printstr("NonStandardReq\r\n");
 471   1              usbStallEndpoint0();
 472   1      }
 473          
 474          /***************************************************************************
 475           * Section:    REQUEST STRUCTURE                                           *
 476           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 477           * Description: This section of code defines the structure of the lookup   *
 478           *    table which determines which 'C' function should be called for each  *
 479           *    supported USB request.                                               * 
 480           ***************************************************************************/
 481          
 482          typedef struct _tDEVICE_REQUEST_COMPARE
 483          {
 484              BYTE    bmRequestType;              // See bit definitions below
 485              BYTE    bRequest;                   // See value definitions below
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 9   

 486              BYTE    bValueL;                    // Meaning varies with request type
 487              BYTE    bValueH;                    // Meaning varies with request type
 488              BYTE    bIndexL;                    // Meaning varies with request type
 489              BYTE    bIndexH;                    // Meaning varies with request type
 490              BYTE    bLengthL;                   // Number of bytes of data to transfer (LSByte)
 491              BYTE    bLengthH;                   // Number of bytes of data to transfer (MSByte)
 492              BYTE    bCompareMask;               // MSB is bRequest, if set 1, bRequest should be matched, LSB is b
             -LengthH
 493              VOID    (*pUsbFunction)(VOID);      // function pointer
 494          } tDEVICE_REQUEST_COMPARE, *ptDEVICE_REQUEST_COMPARE;
 495          
 496          /***************************************************************************
 497           * Section:    USB REQUEST TABLE                                           *
 498           * Programmer: Craig Steiner (csteiner@vaultbbs.com) based on code by      *
 499           *             Lobo Tai (lobotai@ti.com)                                   *
 500           * Description: This section of code defines the lookup table, using the   *
 501           *    structure defined in the previous section of code.  The values of    *
 502           *    the constants used in this structure are defined in usb.h.           * 
 503           * Structure of Table:                                                     * 
 504           *    bmRequestType: Indicates the type of request.  This is a bit-mapped  * 
 505           *          variable defined in the USB spec.  The bits of this variable   * 
 506           *          have the following purpose, and are defined in usb.h.          * 
 507           *          Bit 7: Data Direction (0=Host to Device, 1=Device to Host)     * 
 508           *          Bit 6-5: Type of request (00=Standard, 01=Class, 10=Vendor)    * 
 509           *          Bit 4-0: Recipient (00000=Device, 00001=Interface,             *
 510           *                              00010=Endpoint, 00011=Other                *
 511           *    bRequest: Indicates the request ID (Get descriptor, Get Status, Get  *
 512           *              feature, etc.).  These are defined in the USB and HID spec *
 513           *              and are declared in usb.h.                                 *
 514           *    bValueL/H: Additional values, purpose varies with request.           *
 515           *    bIndexL/H: Additional values, purpose varies with request.           *
 516           *    bLengthL/H: Number of bytes to transfer to or from host.             *
 517           *    bCompareMask: Indicates which of the above bytes should be compared  *
 518           *               to determine the function to call.  For example, the mask *
 519           *               0x80 means only bmRequestType must match. 0xC0 means      *
 520           *               both bmRequestType and bRequest must match.  If this      *
 521           *               variable is 0x00, as is the case in the last entry in the *
 522           *               table, then no bytes are compared and, thus, ANY packet   *
 523           *               will pass the comparsion stage.  This technique is used   *
 524           *               in the last entry of the table as an "else" condition     *
 525           *               so that any requests that haven't been handled by that    *
 526           *               point are handled by the usbNonStandardRequest function.  *
 527           ***************************************************************************/
 528          
 529          code tDEVICE_REQUEST_COMPARE tUsbRequestList[] =
 530          {
 531              // SET ENDPOINT FEATURE
 532              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_ENDPOINT,
 533              USB_REQ_SET_FEATURE,
 534              FEATURE_ENDPOINT_STALL,0x00,
 535              0xff,0x00,
 536              0x00,0x00,
 537              0xf7,&usbSetEndpointHalt,
 538          
 539              // CLEAR ENDPOINT FEATURE
 540              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_ENDPOINT,
 541              USB_REQ_CLEAR_FEATURE,
 542              FEATURE_ENDPOINT_STALL,0x00,
 543              0xff,0x00,
 544              0x00,0x00,
 545              0xf7,&usbClearEndpointHalt,
 546          
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 10  

 547              // GET CONFIGURATION
 548              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 549              USB_REQ_GET_CONFIGURATION,
 550              0x00,0x00,
 551              0x00,0x00,
 552              0x01,0x00,
 553              0xff,&usbGetConfiguration,
 554          
 555              // SET CONFIGURATION
 556              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 557              USB_REQ_SET_CONFIGURATION,
 558              0xff,0x00,
 559              0x00,0x00,
 560              0x00,0x00,
 561              0xdf,&usbSetConfiguration,
 562          
 563              // GET DEVICE DESCRIPTOR
 564              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 565              USB_REQ_GET_DESCRIPTOR,
 566              0xff,DESC_TYPE_DEVICE,                  // bValueL is index and bValueH is type
 567              0xff,0xff,
 568              0xff,0xff,
 569              0xd0,&usbGetDeviceDescriptor,
 570          
 571              // GET CONFIGURATION DESCRIPTOR
 572              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 573              USB_REQ_GET_DESCRIPTOR,
 574              0xff,DESC_TYPE_CONFIG,                  // bValueL is index and bValueH is type
 575              0xff,0xff,
 576              0xff,0xff,
 577              0xd0,&usbGetConfigurationDescriptor,
 578          
 579              // GET HID DESCRIPTOR
 580              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
 581              USB_REQ_GET_DESCRIPTOR,
 582              0xff,DESC_TYPE_HID,                  // bValueL is index and bValueH is type
 583              0xff,0xff,
 584              0xff,0xff,
 585              0xd0,&usbGetHIDDescriptor,
 586          
 587              // GET STRING DESCRIPTOR
 588              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 589              USB_REQ_GET_DESCRIPTOR,
 590              0xff,DESC_TYPE_STRING,                  // bValueL is index and bValueH is type
 591              0xff,0xff,
 592              0xff,0xff,
 593              0xd0,&usbGetStringDescriptor,
 594          
 595              // GET REPORT DESCRIPTOR
 596              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
 597              USB_REQ_GET_DESCRIPTOR,
 598              0xff,DESC_TYPE_REPORT,                 // bValueL is index and bValueH is type
 599              0xff,0xff,
 600              0xff,0xff,
 601              0xd0,&usbGetReportDescriptor,
 602          
 603              // SET REPORT
 604              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
 605              USB_REQ_SET_REPORT,
 606              0xff,0xFF,                 // bValueL is index and bValueH is type
 607              0xff,0xff,
 608              0xff,0xff,
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 11  

 609              0xC0,&usbSetReport,
 610          
 611              // SET IDLE
 612              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
 613              USB_REQ_SET_IDLE,
 614              0xff,0xFF,                  // bValueL is index and bValueH is type
 615              0xff,0xff,
 616              0x00,0x00,
 617              0xc3,&usbSetIdle,
 618          
 619              // SET PROTOCOL
 620              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
 621              USB_REQ_SET_PROTOCOL,
 622              0xff,0xFF,                  // bValueL is index and bValueH is type
 623              0xff,0xff,
 624              0x00,0x00,
 625              0xc3,&usbSetProtocol,
 626          
 627              // GET IDLE
 628              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
 629              USB_REQ_GET_IDLE,
 630              0xff,0xFF,                  // bValueL is index and bValueH is type
 631              0xff,0xff,
 632              0x01,0x00,
 633              0xc3,&usbGetIdle,
 634          
 635              // GET PROTOCOL
 636              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_CLASS | USB_REQ_TYPE_INTERFACE,
 637              USB_REQ_GET_PROTOCOL,
 638              0xff,0xFF,                  // bValueL is index and bValueH is type
 639              0xff,0xff,
 640              0x01,0x00,
 641              0xc3,&usbGetProtocol,
 642          
 643              // GET INTERFACE
 644              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
 645              USB_REQ_GET_INTERFACE,
 646              0x00,0x00,
 647              0xff,0xff,
 648              0x01,0x00,
 649              0xf3,&usbGetInterface,
 650          
 651              // GET DEVICE STATUS
 652              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 653              USB_REQ_GET_STATUS,
 654              0x00,0x00,
 655              0x00,0x00,
 656              0x02,0x00,
 657              0xff,&usbGetDeviceStatus,
 658          
 659              // GET INTERFACE STATUS
 660              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
 661              USB_REQ_GET_STATUS,
 662              0x00,0x00,
 663              0xff,0x00,
 664              0x02,0x00,
 665              0xf7,&usbGetInterfaceStatus,
 666          
 667              // GET ENDPOINT STATUS
 668              USB_REQ_TYPE_INPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_ENDPOINT,
 669              USB_REQ_GET_STATUS,
 670              0x00,0x00,
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 12  

 671              0xff,0x00,
 672              0x02,0x00,
 673              0xf7,&usbGetEndpointStatus,
 674          
 675              // SET ADDRESS
 676              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 677              USB_REQ_SET_ADDRESS,
 678              0xff,0x00,
 679              0x00,0x00,
 680              0x00,0x00,
 681              0xdf,&usbSetAddress,
 682          
 683              // SET DEVICE FEATURE
 684              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 685              USB_REQ_SET_FEATURE,
 686              FEATURE_REMOTE_WAKEUP,0x00,           // feature selector
 687              0x00,0x00,
 688              0x00,0x00,
 689              0xff,&usbSetRemoteWakeup, // df, setDeviceFeature
 690              
 691                  // CLEAR DEVICE FEATURE
 692              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_DEVICE,
 693              USB_REQ_CLEAR_FEATURE,
 694              FEATURE_REMOTE_WAKEUP,0x00,
 695              0x00,0x00,
 696              0x00,0x00,
 697              0xff,&usbClearRemoteWakeup,
 698          
 699              // SET INTERFACE FEATURE
 700              USB_REQ_TYPE_OUTPUT | USB_REQ_TYPE_STANDARD | USB_REQ_TYPE_INTERFACE,
 701              USB_REQ_SET_INTERFACE,
 702              0xff,0x00,                      // alternative setting
 703              0xff,0x00,                      // interface number
 704              0x00,0x00,
 705              0xd7,&usbSetInterface,
 706          
 707                  // END OF LIST CATCH-ALL REQUEST: 
 708                  // This will match any USB request sicne bCompareMask is 0x00.
 709              0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
 710              0x00,&usbNonStandardRequest
 711          };
 712          
 713          /***************************************************************************
 714           * Function:   UsbDecodeAndProcessUsbRequest()                             *
 715           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 716           * Description: This function is called when a USB request has been        *
 717           *    received.  It searches the tUsbRequestList[] structure defined in    * 
 718           *    the previous section for a request that matches a given entry in     * 
 719           *    the table and, when matched, executes the corresponding function.    *  
 720           ***************************************************************************/
 721          
 722          void usbDecodeAndProcessUsbRequest(void)
 723          {
 724   1          BYTE bMask,bResult,bTemp;
 725   1          BYTE *pbUsbRequestList;                 // save code space
 726   1      
 727   1      
 728   1              // We initialize the pbUsbRequestList pointer to the beginning of the
 729   1              // tUsbRequestList[] so that we can subsequently traverse the table
 730   1              // by incrementing the pbUsbRequestList pointer.
 731   1          pbUsbRequestList = (PBYTE) &tUsbRequestList[0];
 732   1      
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 13  

 733   1              // Cycle indefinitely until we've found an entry in the tUsbRequestList[]
 734   1              // table.  Since the last entry in the table has a 0x00 mask, we'll
 735   1              // *always* find a match, so this cycle will always exit.
 736   1          while(1)
 737   1              {
 738   2              bResult = 0x00;
 739   2              bMask   = 0x80;
 740   2      
 741   2              // We cycle through fields 0 through 7, which correspond to the 8 fields
 742   2              // in each entry of tUsbRequestList.  If the given byte in the packet
 743   2              // we just receive is equal to the corresponding byte in the table, we
 744   2              // set that bit in the result, indicating a byte which matched.  Otherwise,
 745   2              // we don't set the bit which means that byte didn't match.
 746   2              for(bTemp = 0; bTemp < 8; bTemp++)
 747   2                      {
 748   3                  if(*(pbEP0_SETUP_ADDRESS+bTemp) == *(pbUsbRequestList+bTemp)) 
 749   3                      bResult |= bMask;
 750   3                              bMask = bMask >> 1;
 751   3                      }
 752   2      
 753   2              // At this point, bResult holds 8 bits which indicate whether each of the
 754   2              // bytes in the packet matched the corresponding bytes in the tUsbRequestList[]
 755   2              // table.  We then AND the mask value in the table with the result so that
 756   2              // we only are comparing the bits required in the mask.  If the resulting
 757   2              // value is equal to the mask, that means that all significant bytes match.
 758   2              // This is done since any bit that is clear in the mask is a "don't care", so
 759   2              // the AND makes sure we don't reject a "valid" comparison beause a don't 
 760   2              // care bit actually matched.
 761   2              if((*(pbUsbRequestList+bTemp) & bResult) == *(pbUsbRequestList+bTemp)) 
 762   2                      break;
 763   2      
 764   2              // If we haven't found a matching entry yet, we advenced the pointer to point
 765   2              // to the next entry in the table, and keep looking.
 766   2              pbUsbRequestList += sizeof(tDEVICE_REQUEST_COMPARE);
 767   2              }
 768   1      
 769   1          // We check to see if any more setup packet(s) have been received and, if so, we
 770   1          // anbandon this one to hanlde the next one.
 771   1          if(bUSBSTA & (USBSTA_SETUP | USBSTA_STPOW) != 0x00) 
 772   1              return;
 773   1      
 774   1              // If we've reached this point of the function, we've found the function that should
 775   1              // be called given the current request.  So we call it...
 776   1              ((ptDEVICE_REQUEST_COMPARE)pbUsbRequestList)->pUsbFunction();
 777   1      }
 778          
 779          /***************************************************************************
 780           * Function:   usbStallEndpoint0()                                         *
 781           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 782           * Description: Sets the STALL flag on both IEP0 and OEP0.  Often called   *
 783           *    to reflect an error condition.                                       *
 784           ***************************************************************************/
 785          
 786          void usbStallEndpoint0(void)
 787          {
 788   1          tEndPoint0DescriptorBlock.bIEPCNFG |= EPCNF_STALL;
 789   1          tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL;
 790   1      }
 791          
 792          /***************************************************************************
 793           * Function:   usbReceiveDataPacketOnEP0 / ReceiveNextPacket               *
 794           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 14  

 795           * Description: These two functions, together, are used to receive a data  *
 796           *    payload on the OEP0 endpoint.  The reception is first initiated by   *
 797           *    calling usbReceiveDataPacketOnEP0 and indicating the address that the*
 798           *    received data should be placed in.  As each data packet is received, *
 799           *    the usbReceiveNextPacketOnOEP0 will be called to process the packet  *
 800           *    and determine if the packet received was the last packet, or if there*
 801           *    are more packets coming.                                             * 
 802           ***************************************************************************/
 803          
 804          void usbReceiveDataPacketOnEP0(PBYTE pbBuffer)
 805          {
 806   1          pbOEP0Buffer = pbBuffer;
 807   1          wBytesRemainingOnOEP0 = (WORD)(tSetupPacket.bLengthH << 8) | (WORD)tSetupPacket.bLengthL;
 808   1          bStatusAction = STATUS_ACTION_DATA_OUT;
 809   1          usbClearOEP0ByteCount;            
 810   1      }
 811          
 812          void usbReceiveNextPacketOnOEP0(void)
 813          {
 814   1          BYTE bIndex,bByte;
 815   1      
 816   1              // First we must determine how many bytes were received in this data
 817   1              // packet.  We AND it with EPBCT_BYTECNT_MASK so that a NAK condition
 818   1              // will return "0 bytes."
 819   1          bByte = tEndPoint0DescriptorBlock.bOEPBCNT & EPBCT_BYTECNT_MASK;
 820   1      
 821   1              // If the number of bytes remaining to be received is greater than
 822   1              // or equal to the number of bytes received in this packet then
 823   1              // we handle the packet.  However, if we received more bytes than
 824   1              // we had expected we simply ignore the packet since it is
 825   1              // presumably erroneous.
 826   1          if(wBytesRemainingOnOEP0 >= (WORD)bByte)
 827   1              {
 828   2                      // For each of the bytes received, we copy the value received to the
 829   2                      // next position in the buffer we set aside for the OEP0 data.
 830   2              for(bIndex=0;bIndex<bByte;bIndex++)
 831   2                  *pbOEP0Buffer++ = abOEP0Buffer[bIndex];
 832   2      
 833   2                      // We now reduce the number of bytes remaining by the number of bytes
 834   2                      // received in this packet.                              
 835   2              wBytesRemainingOnOEP0 -= (WORD)bByte;
 836   2      
 837   2              // If there are still more bytes to be received in additional packets (i.e.,
 838   2                      // wBytesRemainingOnOEP0 is greater than zero), we clear the byte count and
 839   2                      // reestablish bStatusAction to indicate that we are still in a DATA_OUT
 840   2                      // condition.
 841   2              if(wBytesRemainingOnOEP0 > 0)
 842   2                      {
 843   3                  usbClearOEP0ByteCount;        
 844   3                  bStatusAction = STATUS_ACTION_DATA_OUT;
 845   3                      }
 846   2              else
 847   2                      {
 848   3                      // If we aren't expecting any more data bytes, we terminate the OEP0
 849   3                      // transaction by stalling OEP0 and setting the bStatusAction condition
 850   3                      // to "Nothing."  Since in this firmware the only USB function that
 851   3                      // includes a subsequent data payload is the Set_Report function, we
 852   3                      // automatically update the keyboard LEDs with the new value.  If
 853   3                      // additional features are added that expect data payloads, calling
 854   3                      // the OEP0SetLeds() function when a Set_Report request was not
 855   3                      // received will cause no harm.
 856   3                  usbStallOEP0;
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 15  

 857   3                  bStatusAction = STATUS_ACTION_NOTHING;        
 858   3                              OEP0SetLEDs();
 859   3                      }
 860   2              }
 861   1          else
 862   1              {
 863   2              // If the packet we received include more data than we expected, we ignore
 864   2              // the entire packet and abort the transfer.  This is accomplished by
 865   2              // stalling OEP0 and resetting the bStatusAction condition to "Nothing."
 866   2              usbStallOEP0;
 867   2              bStatusAction = STATUS_ACTION_NOTHING;
 868   2              }
 869   1      }
 870          
 871          /***************************************************************************
 872           * Function:   usbSendZeroLengthPacketOnIEP0()                             *
 873           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 874           * Description: Sends a 0-lengthg packet back to the host on IEP0. Often   *
 875           *    called to acknowledge a packet received from the host that requires  *
 876           *    no data in the reply, just an acknowledgement of receipt.            *
 877           ***************************************************************************/
 878          
 879          void usbSendZeroLengthPacketOnIEP0(void)
 880          {
 881   1          wBytesRemainingOnIEP0 = NO_MORE_DATA;
 882   1          bStatusAction = STATUS_ACTION_NOTHING;
 883   1          tEndPoint0DescriptorBlock.bIEPBCNT = 0x00;
 884   1      }
 885          
 886          /***************************************************************************
 887           * Function:   usbSendDataPacketOnEPO / SendNext                           *
 888           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 889           * Description: These two functions, together, are responsible for sending *
 890           *    data packets back to the host on IEPO.  The transfer is initiated by *
 891           *    first calling usbSendDataPacketOnEP0 and indicating the address of   *
 892           *    the buffer to send.  This initiates the transfer and sends the first *
 893           *    packet of data.  If there is more data than can be sent in the first *
 894           *    packet, the usbSendNextPacketOnIEP0 function is called to send       *
 895           *    subsequent packets of data when an interrupt indicates the previous  *
 896           *    packet has been sent.                                                *
 897           ***************************************************************************/
 898          
 899          void usbSendDataPacketOnEP0(PBYTE pbBuffer)
 900          {
 901   1          WORD wTemp;
 902   1      
 903   1          pbIEP0Buffer = pbBuffer;
 904   1      
 905   1          wTemp = (WORD)(tSetupPacket.bLengthH << 8) | (WORD)tSetupPacket.bLengthL;
 906   1      
 907   1          // Limit transfer size to wLength if needed
 908   1          // this prevent USB device sending 'more than require' data back to host
 909   1          if(wBytesRemainingOnIEP0 >= wTemp)
 910   1              {
 911   2              wBytesRemainingOnIEP0 = wTemp;
 912   2              bHostAskMoreDataThanAvailable = FALSE;
 913   2              }
 914   1              else
 915   1                      { 
 916   2                      bHostAskMoreDataThanAvailable = TRUE;
 917   2                      }
 918   1      
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 16  

 919   1          usbSendNextPacketOnIEP0();
 920   1      }
 921          
 922          void usbSendNextPacketOnIEP0(void)
 923          {
 924   1          BYTE bPacketSize,bIndex;
 925   1      
 926   1          // First check if there are bytes remaining to be transferred
 927   1          if(wBytesRemainingOnIEP0 != NO_MORE_DATA)
 928   1              {
 929   2              if(wBytesRemainingOnIEP0 > EP0_MAX_PACKET_SIZE)
 930   2                      {
 931   3                  // More bytes are remaining than will fit in one packet
 932   3                  // there will be More IN Stage
 933   3                  bPacketSize = EP0_MAX_PACKET_SIZE;
 934   3                  wBytesRemainingOnIEP0 -= EP0_MAX_PACKET_SIZE;
 935   3                  bStatusAction = STATUS_ACTION_DATA_IN;
 936   3                      }
 937   2              else if (wBytesRemainingOnIEP0 < EP0_MAX_PACKET_SIZE)
 938   2                      {
 939   3                  // The remaining data will fit in one packet.
 940   3                  // This case will properly handle wBytesRemainingOnIEP0 == 0
 941   3                  bPacketSize = (BYTE)wBytesRemainingOnIEP0;
 942   3                  wBytesRemainingOnIEP0 = NO_MORE_DATA;        // No more data need to be Txed
 943   3                  bStatusAction = STATUS_ACTION_NOTHING;
 944   3                      }
 945   2              else
 946   2                      {
 947   3                  // wBytesRemainingOnIEP0 == EP0_MAX_PACKET_SIZE
 948   3                  bPacketSize = EP0_MAX_PACKET_SIZE;
 949   3                  if(bHostAskMoreDataThanAvailable == TRUE)
 950   3                      {
 951   4                      wBytesRemainingOnIEP0 = 0;
 952   4                      bStatusAction = STATUS_ACTION_DATA_IN;
 953   4                      }
 954   3                  else
 955   3                      { 
 956   4                      wBytesRemainingOnIEP0 = NO_MORE_DATA;
 957   4                      bStatusAction = STATUS_ACTION_NOTHING;
 958   4                      }
 959   3                      }
 960   2      
 961   2              for(bIndex=0; bIndex<bPacketSize; bIndex++) 
 962   2                  abIEP0Buffer[bIndex] = *pbIEP0Buffer++;
 963   2      
 964   2              tEndPoint0DescriptorBlock.bIEPBCNT = bPacketSize;   // & EPBCT_BYTECNT_MASK;
 965   2                      }
 966   1          else
 967   1              {
 968   2              bStatusAction = STATUS_ACTION_NOTHING;
 969   2              }
 970   1      }
 971          
 972          /***************************************************************************
 973           * Function:   SetupPacketInterruptHandler()                               *
 974           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
 975           * Description: This function is called by the UsbInterrupt function when  *
 976           *    a setup packet is received.  This function immediately sets both     * 
 977           *    OEP0 and IEP0 to a NAK state, sets the bUSBCTL to send/receive based *
 978           *    on the direction of the request, then proceeds to call  the          *
 979           *    usbDecodeAndProcessUsbRequest() function which determines which      *
 980           *    function should be called to handle the given USB request.           *  
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 17  

 981           ***************************************************************************/
 982          
 983          void SetupPacketInterruptHandler(void)
 984          {
 985   1          // Hardware clears STALL in both data endpoints once valid setup packet is
 986   1          // received.  NAK both data endpoints.
 987   1          tEndPoint0DescriptorBlock.bIEPBCNT  = EPBCNT_NAK;
 988   1          tEndPoint0DescriptorBlock.bOEPBCNT  = EPBCNT_NAK;
 989   1          
 990   1          bUSBSTA = USBSTA_SETUP; // from now, hardware will refer NAK bit in I/OEPBCNT
 991   1      
 992   1          // Copy the MSB of bmRequestType to DIR bit of USBCTL to indicate the
 993   1          // direction of the transfer.
 994   1          if((tSetupPacket.bmRequestType & USB_REQ_TYPE_INPUT) == USB_REQ_TYPE_INPUT)
 995   1              bUSBCTL |= USBCTL_DIR;
 996   1          else 
 997   1              bUSBCTL &= ~USBCTL_DIR;
 998   1      
 999   1              // Clear the bStatusAction to indicate that, at this point, nothing is 
1000   1              // happening (it may be set to DATA_OUT by specific functions that
1001   1              // expect a DATA packet following the setup packet).
1002   1          bStatusAction = STATUS_ACTION_NOTHING;
1003   1      
1004   1              // Call the function that determines which function should be called to
1005   1              // handle the specific USB request.
1006   1          usbDecodeAndProcessUsbRequest();
1007   1      }
1008          
1009          /***************************************************************************
1010           * Function:   OEP0InterruptHandler()                                      *
1011           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
1012           * Description: This function is called by the UsbInterrupt function when  *
1013           *    a USB interrupt is called by OEP0.  This will happen once a data     *
1014           *    transfer has been initialized by a USB function handler by calling   *
1015           *    usbReceiveDataPacketOnEP0.                                           *
1016           ***************************************************************************/
1017          
1018          void OEP0InterruptHandler(void)
1019          {
1020   1              // We clear the IEP0 byte count since we have nothing to send out.
1021   1          tEndPoint0DescriptorBlock.bIEPBCNT = 0x00;
1022   1              rs232_printstr("\r\nOUT RP:");
1023   1              rs232_printhex(abOEP0Buffer[0]);
1024   1              rs232_printstr("\r\n");
1025   1              // We now handle the interrupt based on the bStatusAction condition.
1026   1              // If we are in a DATA_OUT condition, we call the usbReceiveNextPacketOnEP0
1027   1              // function to copy the data payload to its correct buffer.  If we are
1028   1              // not expecting any data on OEP0, we set the stall flag to stall the
1029   1              // endpoint and abort any additional data that may otherwise be
1030   1              // sent.
1031   1          if(bStatusAction == STATUS_ACTION_DATA_OUT) 
1032   1              usbReceiveNextPacketOnOEP0(); // Handle this data packet
1033   1          else 
1034   1              tEndPoint0DescriptorBlock.bOEPCNFG |= EPCNF_STALL; // We weren't expecting data
1035   1      }
1036          
1037          /***************************************************************************
1038           * Function:   IEP0InterruptHandler()                                      *
1039           * Programmer: Lobo Tai (lobotai@ti.com)                                   *
1040           * Description: This function is called by the UsbInterrupt function when  *
1041           *    a USB interrupt is caused by IEP0.  This will happen once the data   *
1042           *    sent by calling usbSendNextPacketOnIEP0 and means the previous data  *
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 18  

1043           *    packet has been sent.  At that point, there are two conditions:      *
1044           *    either there is more data to send or there isn't.  If there is, we   *
1045           *    call usbSendNextPacketOnIEP0 to send the next packet of data.  If    *
1046           *    there isn't anymore data, we stall.  However, if the bStatusAction   *
1047           *    condition indicates that we were changing the devices address, we    *
1048           *    do so at this point.                                                 *
1049           ***************************************************************************/
1050          
1051          void IEP0InterruptHandler(void)
1052          {
1053   1              // We clear the OEP0 byte count since we are not expecting any data.
1054   1          tEndPoint0DescriptorBlock.bOEPBCNT = 0x00;
1055   1      
1056   1              // We now handle the interrupt based on the bStatusAction condition.
1057   1              // If we are in a DATA_IN condition, we call the usbSendNextPacketOnIEP0  
1058   1              // function to send the next data payload packet.  If we are in a
1059   1              // Set Address mode, we modify the address.  In any other case, we've
1060   1              // sent all teh data we had to send, so we stall the endpoint to indicate
1061   1              // there is no more data to send.
1062   1          if(bStatusAction == STATUS_ACTION_DATA_IN) 
1063   1              usbSendNextPacketOnIEP0(); // Send the next data packet
1064   1          else if(bStatusAction == STATUS_ACTION_SET_ADDRESS) 
1065   1              bFUNADR = bUsbDeviceAddress; // Set the device's address
1066   1          else 
1067   1              tEndPoint0DescriptorBlock.bIEPCNFG |= EPCNF_STALL; // No more data to send
1068   1      }
1069          
1070          /***************************************************************************
1071           * Function:   USBInterrupt                                                *
1072           * Programmer: Craig Steiner (csteiner@vaultbbs.com)                       *
1073           * Description: Handles the USB interrupts generated by the USB sectiob of *
1074           *    the part.  This is actually External 0 interrupt on the 8051 at      *
1075           *    0x0003 in memory, but is used exclusively for USB interrupts on the  *
1076           *    TUSB2136.                                                            * 
1077           *                                                                         * 
1078           * Note: VECINT is cleared after being handled successfully so that the    * 
1079           *       next USB-related interrupt is made available to the handler.      *  
1080           ***************************************************************************/
1081          
1082          void USBInterrupt(void) interrupt 0
1083          {
1084   1              // Disable all interrupts because this is critical code
1085   1              EA = DISABLE;
1086   1              // Select the appropriate interrupt handler depending on the VECINT value
1087   1          switch (bVECINT)
1088   1              {
1089   2                      case VECINT_OUTPUT_ENDPOINT0:
1090   2                              bVECINT  = 0x00;
1091   2                              rs232_printstr("EP0_out  ");
1092   2                              OEP0InterruptHandler();                 
1093   2                              break;
1094   2      
1095   2              case VECINT_INPUT_ENDPOINT0:
1096   2                              bVECINT  = 0x00;
1097   2                              rs232_printstr("EP0_in  ");
1098   2                              IEP0InterruptHandler();                 
1099   2                              break;
1100   2      
1101   2                      case VECINT_INPUT_ENDPOINT1:
1102   2                              bVECINT = 0x00;
1103   2                              rs232_printstr("EP1_in  ");
1104   2                              IEP1InterruptHandler();
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 19  

1105   2                              break;
1106   2      
1107   2                      case VECINT_OUTPUT_ENDPOINT1:
1108   2                              bVECINT = 0x00;
1109   2                              rs232_printstr("EP1_out  ");
1110   2                              OEP1InterruptHandler();
1111   2                              break;
1112   2      
1113   2              case VECINT_STPOW_PACKET_RECEIVED:
1114   2                              bVECINT  = 0x00;
1115   2                              bUSBSTA = USBSTA_STPOW;
1116   2                              rs232_printstr("STPOW  ");
1117   2                              SetupPacketInterruptHandler();
1118   2                              break;
1119   2      
1120   2              case VECINT_SETUP_PACKET_RECEIVED:
1121   2              // hardware will NAK data stage, no matter NAK bit in I/OEPBCNT
1122   2                              bVECINT  = 0x00;
1123   2      //                      bUSBSTA = USBSTA_SETUP; // from now, hardware will refer NAK bit in I/OEPBCNT
1124   2                              rs232_printstr("\r\nSETUP  ");
1125   2                              SetupPacketInterruptHandler();
1126   2                              break;
1127   2      
1128   2              case VECINT_RSTR_INTERRUPT:
1129   2                              bVECINT  = 0x00;
1130   2                              bUSBSTA = USBSTA_RSTR;
1131   2                              UsbReset();
1132   2                              break;
1133   2                      
1134   2                      case VECINT_RESR_INTERRUPT:
1135   2                              bVECINT = 0x00;
1136   2                              bUSBSTA = USBSTA_RESR;
1137   2                              bSuspended = FALSE;
1138   2                              break;
1139   2                      
1140   2                      case VECINT_SUSR_INTERRUPT:
1141   2                              bVECINT = 0x00;
1142   2                              bUSBSTA = USBSTA_SUSR;
1143   2                              rs232_printstr("SUSP  ");
1144   2                              bSuspended = TRUE;
1145   2                              break;
1146   2      
1147   2                      default:
1148   2                              bVECINT  = 0x00;
1149   2                              rs232_printhex(bVECINT);
1150   2                              break;
1151   2                      }
1152   1      
1153   1              // End of ciritical code section, reenable interrupts
1154   1          EA = ENABLE;
1155   1      }
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 20  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION usbGetConfiguration (BEGIN)
                                           ; SOURCE LINE # 173
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_0
0004 7900        R     MOV     R1,#LOW ?SC_0
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 176
0009 750000      R     MOV     wBytesRemainingOnIEP0,#00H
000C 750001      R     MOV     wBytesRemainingOnIEP0+01H,#01H
                                           ; SOURCE LINE # 177
000F 7B00              MOV     R3,#00H
0011 7A00        R     MOV     R2,#HIGH bConfigurationNumber
0013 7900        R     MOV     R1,#LOW bConfigurationNumber
0015 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetConfiguration (END)

             ; FUNCTION usbSetConfiguration (BEGIN)
                                           ; SOURCE LINE # 180
                                           ; SOURCE LINE # 181
                                           ; SOURCE LINE # 182
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_9
0004 7900        R     MOV     R1,#LOW ?SC_9
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 183
0009 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
000C E0                MOVX    A,@DPTR
000D 4408              ORL     A,#08H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 184
0010 90FF02            MOV     DPTR,#tSetupPacket+02H
0013 E0                MOVX    A,@DPTR
0014 F500        R     MOV     bConfigurationNumber,A
                                           ; SOURCE LINE # 185
0016 90FF48            MOV     DPTR,#tInputEndPointDescriptorBlock
0019 E0                MOVX    A,@DPTR
001A 4484              ORL     A,#084H
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 186
001D E4                CLR     A
001E 90FF4A            MOV     DPTR,#tInputEndPointDescriptorBlock+02H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 187
0022 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetConfiguration (END)

             ; FUNCTION usbSetReport (BEGIN)
                                           ; SOURCE LINE # 202
                                           ; SOURCE LINE # 203
                                           ; SOURCE LINE # 204
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_18
0004 7900        R     MOV     R1,#LOW ?SC_18
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 205
0009 750000      R     MOV     wBytesRemainingOnOEP0,#00H
000C 750001      R     MOV     wBytesRemainingOnOEP0+01H,#01H
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 21  

                                           ; SOURCE LINE # 206
000F 7B00              MOV     R3,#00H
0011 7AFE              MOV     R2,#0FEH
0013 79A0              MOV     R1,#0A0H
0015 020000      R     LJMP    _usbReceiveDataPacketOnEP0
             ; FUNCTION usbSetReport (END)

             ; FUNCTION OEP1InterruptHandler (BEGIN)
                                           ; SOURCE LINE # 209
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 212
0000 E4                CLR     A
0001 90FF0A            MOV     DPTR,#tOutputEndPointDescriptorBlock+02H
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 213
0005 22                RET     
             ; FUNCTION OEP1InterruptHandler (END)

             ; FUNCTION usbGetDeviceDescriptor (BEGIN)
                                           ; SOURCE LINE # 219
                                           ; SOURCE LINE # 220
                                           ; SOURCE LINE # 223
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_26
0004 7900        R     MOV     R1,#LOW ?SC_26
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 225
;---- Variable 'bTemp' assigned to Register 'R7' ----
0009 E4                CLR     A
000A FF                MOV     R7,A
000B         ?C0005:
                                           ; SOURCE LINE # 226
000B EF                MOV     A,R7
000C 900000      E     MOV     DPTR,#abromDeviceDescriptor
000F 93                MOVC    A,@A+DPTR
0010 FE                MOV     R6,A
0011 7480              MOV     A,#LOW abDescriptor
0013 2F                ADD     A,R7
0014 F582              MOV     DPL,A
0016 E4                CLR     A
0017 34FE              ADDC    A,#HIGH abDescriptor
0019 F583              MOV     DPH,A
001B EE                MOV     A,R6
001C F0                MOVX    @DPTR,A
001D 0F                INC     R7
001E BF12EA            CJNE    R7,#012H,?C0005
0021         ?C0006:
                                           ; SOURCE LINE # 228
0021 E4                CLR     A
0022 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 229
0026 F500        R     MOV     wBytesRemainingOnIEP0,A
0028 750012      R     MOV     wBytesRemainingOnIEP0+01H,#012H
                                           ; SOURCE LINE # 230
002B 7B01              MOV     R3,#01H
002D 7AFE              MOV     R2,#HIGH abDescriptor
002F 7980              MOV     R1,#LOW abDescriptor
0031 120000      R     LCALL   _usbSendDataPacketOnEP0
                                           ; SOURCE LINE # 235
0034 D200        R     SETB    deviceReady
                                           ; SOURCE LINE # 236
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 22  

0036 22                RET     
             ; FUNCTION usbGetDeviceDescriptor (END)

             ; FUNCTION usbGetHIDDescriptor (BEGIN)
                                           ; SOURCE LINE # 238
                                           ; SOURCE LINE # 239
                                           ; SOURCE LINE # 242
;---- Variable 'bTemp' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
0002         ?C0009:
                                           ; SOURCE LINE # 243
0002 EF                MOV     A,R7
0003 900000      E     MOV     DPTR,#abromConfigurationDescriptorGroup+012H
0006 93                MOVC    A,@A+DPTR
0007 FE                MOV     R6,A
0008 7480              MOV     A,#LOW abDescriptor
000A 2F                ADD     A,R7
000B F582              MOV     DPL,A
000D E4                CLR     A
000E 34FE              ADDC    A,#HIGH abDescriptor
0010 F583              MOV     DPH,A
0012 EE                MOV     A,R6
0013 F0                MOVX    @DPTR,A
0014 0F                INC     R7
0015 BF12EA            CJNE    R7,#012H,?C0009
0018         ?C0010:
                                           ; SOURCE LINE # 245
0018 E4                CLR     A
0019 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 246
001D F500        R     MOV     wBytesRemainingOnIEP0,A
001F 750009      R     MOV     wBytesRemainingOnIEP0+01H,#09H
                                           ; SOURCE LINE # 247
0022 7B01              MOV     R3,#01H
0024 7AFE              MOV     R2,#HIGH abDescriptor
0026 7980              MOV     R1,#LOW abDescriptor
0028 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetHIDDescriptor (END)

             ; FUNCTION usbGetConfigurationDescriptor (BEGIN)
                                           ; SOURCE LINE # 250
                                           ; SOURCE LINE # 251
                                           ; SOURCE LINE # 253
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_32
0004 7900        R     MOV     R1,#LOW ?SC_32
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 255
;---- Variable 'bTemp' assigned to Register 'R7' ----
0009 E4                CLR     A
000A FF                MOV     R7,A
000B         ?C0013:
000B 900000      E     MOV     DPTR,#abromConfigurationDescriptorGroup+02H
000E E4                CLR     A
000F 93                MOVC    A,@A+DPTR
0010 FE                MOV     R6,A
0011 EF                MOV     A,R7
0012 C3                CLR     C
0013 9E                SUBB    A,R6
0014 5015              JNC     ?C0014
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 23  

                                           ; SOURCE LINE # 256
0016 EF                MOV     A,R7
0017 900000      E     MOV     DPTR,#abromConfigurationDescriptorGroup
001A 93                MOVC    A,@A+DPTR
001B FE                MOV     R6,A
001C 7480              MOV     A,#LOW abDescriptor
001E 2F                ADD     A,R7
001F F582              MOV     DPL,A
0021 E4                CLR     A
0022 34FE              ADDC    A,#HIGH abDescriptor
0024 F583              MOV     DPH,A
0026 EE                MOV     A,R6
0027 F0                MOVX    @DPTR,A
0028 0F                INC     R7
0029 80E0              SJMP    ?C0013
002B         ?C0014:
                                           ; SOURCE LINE # 257
002B E4                CLR     A
002C 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 258
0030 F500        R     MOV     wBytesRemainingOnIEP0,A
0032 750029      R     MOV     wBytesRemainingOnIEP0+01H,#029H
                                           ; SOURCE LINE # 259
0035 7B01              MOV     R3,#01H
0037 7AFE              MOV     R2,#HIGH abDescriptor
0039 7980              MOV     R1,#LOW abDescriptor
003B 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetConfigurationDescriptor (END)

             ; FUNCTION usbGetStringDescriptor (BEGIN)
                                           ; SOURCE LINE # 262
                                           ; SOURCE LINE # 263
                                           ; SOURCE LINE # 265
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_38
0004 7900        R     MOV     R1,#LOW ?SC_38
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 266
0009 90FF02            MOV     DPTR,#tSetupPacket+02H
000C E0                MOVX    A,@DPTR
000D FF                MOV     R7,A
000E 120000      E     LCALL   _rs232_printhex
                                           ; SOURCE LINE # 267
0011 7BFF              MOV     R3,#0FFH
0013 7A00        R     MOV     R2,#HIGH ?SC_42
0015 7900        R     MOV     R1,#LOW ?SC_42
0017 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 269
001A 90FF02            MOV     DPTR,#tSetupPacket+02H
001D E0                MOVX    A,@DPTR
001E 14                DEC     A
001F 6031              JZ      ?C0022
0021 14                DEC     A
0022 6054              JZ      ?C0026
0024 14                DEC     A
0025 6077              JZ      ?C0030
0027 2403              ADD     A,#03H
0029 6003              JZ      $ + 5H
002B 020000      R     LJMP    ?C0017
                                           ; SOURCE LINE # 270
                                           ; SOURCE LINE # 271
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 24  

002E         ?C0018:
                                           ; SOURCE LINE # 272
002E E4                CLR     A
002F F500        R     MOV     bTemp,A
0031         ?C0019:
0031 900000      E     MOV     DPTR,#LanguageId
0034 E4                CLR     A
0035 93                MOVC    A,@A+DPTR
0036 FF                MOV     R7,A
0037 E500        R     MOV     A,bTemp
0039 C3                CLR     C
003A 9F                SUBB    A,R7
003B 5039              JNC     ?C0115
                                           ; SOURCE LINE # 273
003D E500        R     MOV     A,bTemp
003F 93                MOVC    A,@A+DPTR
0040 FE                MOV     R6,A
0041 7480              MOV     A,#LOW abDescriptor
0043 2500        R     ADD     A,bTemp
0045 F582              MOV     DPL,A
0047 E4                CLR     A
0048 34FE              ADDC    A,#HIGH abDescriptor
004A F583              MOV     DPH,A
004C EE                MOV     A,R6
004D F0                MOVX    @DPTR,A
004E 0500        R     INC     bTemp
0050 80DF              SJMP    ?C0019
                                           ; SOURCE LINE # 277
0052         ?C0022:
                                           ; SOURCE LINE # 278
0052 E4                CLR     A
0053 F500        R     MOV     bTemp,A
0055         ?C0023:
0055 900000      E     MOV     DPTR,#ManufacturerStringDescriptor
0058 E4                CLR     A
0059 93                MOVC    A,@A+DPTR
005A FF                MOV     R7,A
005B E500        R     MOV     A,bTemp
005D C3                CLR     C
005E 9F                SUBB    A,R7
005F 5015              JNC     ?C0024
                                           ; SOURCE LINE # 279
0061 E500        R     MOV     A,bTemp
0063 93                MOVC    A,@A+DPTR
0064 FE                MOV     R6,A
0065 7480              MOV     A,#LOW abDescriptor
0067 2500        R     ADD     A,bTemp
0069 F582              MOV     DPL,A
006B E4                CLR     A
006C 34FE              ADDC    A,#HIGH abDescriptor
006E F583              MOV     DPH,A
0070 EE                MOV     A,R6
0071 F0                MOVX    @DPTR,A
0072 0500        R     INC     bTemp
0074 80DF              SJMP    ?C0023
0076         ?C0024:
                                           ; SOURCE LINE # 280
0076         ?C0115:
                                           ; SOURCE LINE # 281
                                           ; SOURCE LINE # 282
0076 804A              SJMP    ?C0117
                                           ; SOURCE LINE # 283
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 25  

0078         ?C0026:
                                           ; SOURCE LINE # 284
0078 E4                CLR     A
0079 F500        R     MOV     bTemp,A
007B         ?C0027:
007B 900000      E     MOV     DPTR,#ProductStringDescriptor
007E E4                CLR     A
007F 93                MOVC    A,@A+DPTR
0080 FF                MOV     R7,A
0081 E500        R     MOV     A,bTemp
0083 C3                CLR     C
0084 9F                SUBB    A,R7
0085 5015              JNC     ?C0028
                                           ; SOURCE LINE # 285
0087 E500        R     MOV     A,bTemp
0089 93                MOVC    A,@A+DPTR
008A FE                MOV     R6,A
008B 7480              MOV     A,#LOW abDescriptor
008D 2500        R     ADD     A,bTemp
008F F582              MOV     DPL,A
0091 E4                CLR     A
0092 34FE              ADDC    A,#HIGH abDescriptor
0094 F583              MOV     DPH,A
0096 EE                MOV     A,R6
0097 F0                MOVX    @DPTR,A
0098 0500        R     INC     bTemp
009A 80DF              SJMP    ?C0027
009C         ?C0028:
                                           ; SOURCE LINE # 286
009C         ?C0116:
                                           ; SOURCE LINE # 287
                                           ; SOURCE LINE # 288
009C 8024              SJMP    ?C0117
                                           ; SOURCE LINE # 289
009E         ?C0030:
                                           ; SOURCE LINE # 290
009E E4                CLR     A
009F F500        R     MOV     bTemp,A
00A1         ?C0031:
00A1 900000      E     MOV     DPTR,#SerialNumberStringDescriptor
00A4 E4                CLR     A
00A5 93                MOVC    A,@A+DPTR
00A6 FF                MOV     R7,A
00A7 E500        R     MOV     A,bTemp
00A9 C3                CLR     C
00AA 9F                SUBB    A,R7
00AB 5015              JNC     ?C0032
                                           ; SOURCE LINE # 291
00AD E500        R     MOV     A,bTemp
00AF 93                MOVC    A,@A+DPTR
00B0 FE                MOV     R6,A
00B1 7480              MOV     A,#LOW abDescriptor
00B3 2500        R     ADD     A,bTemp
00B5 F582              MOV     DPL,A
00B7 E4                CLR     A
00B8 34FE              ADDC    A,#HIGH abDescriptor
00BA F583              MOV     DPH,A
00BC EE                MOV     A,R6
00BD F0                MOVX    @DPTR,A
00BE 0500        R     INC     bTemp
00C0 80DF              SJMP    ?C0031
00C2         ?C0032:
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 26  

                                           ; SOURCE LINE # 292
00C2         ?C0117:
00C2 E4                CLR     A
00C3 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
00C6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 293
00C7 F500        R     MOV     wBytesRemainingOnIEP0,A
00C9 8F00        R     MOV     wBytesRemainingOnIEP0+01H,R7
                                           ; SOURCE LINE # 294
                                           ; SOURCE LINE # 295
00CB         ?C0017:
                                           ; SOURCE LINE # 296
00CB 7B01              MOV     R3,#01H
00CD 7AFE              MOV     R2,#HIGH abDescriptor
00CF 7980              MOV     R1,#LOW abDescriptor
00D1 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetStringDescriptor (END)

             ; FUNCTION usbGetReportDescriptor (BEGIN)
                                           ; SOURCE LINE # 299
                                           ; SOURCE LINE # 300
                                           ; SOURCE LINE # 301
0000 E4                CLR     A
0001 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 302
0005 7BFF              MOV     R3,#0FFH
0007 7A00        R     MOV     R2,#HIGH ?SC_45
0009 7900        R     MOV     R1,#LOW ?SC_45
000B 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 303
000E 750000      R     MOV     wBytesRemainingOnIEP0,#00H
0011 75003F      R     MOV     wBytesRemainingOnIEP0+01H,#03FH
                                           ; SOURCE LINE # 304
0014 7BFF              MOV     R3,#0FFH
0016 7A00        E     MOV     R2,#HIGH abromReportDescriptor
0018 7900        E     MOV     R1,#LOW abromReportDescriptor
001A 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetReportDescriptor (END)

             ; FUNCTION usbSetIdle (BEGIN)
                                           ; SOURCE LINE # 316
                                           ; SOURCE LINE # 317
                                           ; SOURCE LINE # 319
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_52
0004 7900        R     MOV     R1,#LOW ?SC_52
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 320
0009 90FF02            MOV     DPTR,#tSetupPacket+02H
000C E0                MOVX    A,@DPTR
000D F500        R     MOV     gbIdleRateL,A
                                           ; SOURCE LINE # 321
000F A3                INC     DPTR
0010 E0                MOVX    A,@DPTR
0011 F500        R     MOV     gbIdleRateH,A
                                           ; SOURCE LINE # 322
0013 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetIdle (END)

             ; FUNCTION usbGetIdle (BEGIN)
                                           ; SOURCE LINE # 325
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 27  

                                           ; SOURCE LINE # 326
                                           ; SOURCE LINE # 327
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_62
0004 7900        R     MOV     R1,#LOW ?SC_62
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 328
0009 750000      R     MOV     wBytesRemainingOnIEP0,#00H
000C 750001      R     MOV     wBytesRemainingOnIEP0+01H,#01H
                                           ; SOURCE LINE # 329
000F 7B00              MOV     R3,#00H
0011 7A00        R     MOV     R2,#HIGH gbIdleRateH
0013 7900        R     MOV     R1,#LOW gbIdleRateH
0015 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetIdle (END)

             ; FUNCTION usbSetProtocol (BEGIN)
                                           ; SOURCE LINE # 333
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 336
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_72
0004 7900        R     MOV     R1,#LOW ?SC_72
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 337
0009 90FF02            MOV     DPTR,#tSetupPacket+02H
000C E0                MOVX    A,@DPTR
000D F500        R     MOV     gbProtocol,A
                                           ; SOURCE LINE # 338
000F 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetProtocol (END)

             ; FUNCTION usbGetProtocol (BEGIN)
                                           ; SOURCE LINE # 341
                                           ; SOURCE LINE # 342
                                           ; SOURCE LINE # 343
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_87
0004 7900        R     MOV     R1,#LOW ?SC_87
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 344
0009 750000      R     MOV     wBytesRemainingOnIEP0,#00H
000C 750001      R     MOV     wBytesRemainingOnIEP0+01H,#01H
                                           ; SOURCE LINE # 345
000F 7B00              MOV     R3,#00H
0011 7A00        R     MOV     R2,#HIGH gbProtocol
0013 7900        R     MOV     R1,#LOW gbProtocol
0015 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetProtocol (END)

             ; FUNCTION usbGetInterface (BEGIN)
                                           ; SOURCE LINE # 354
                                           ; SOURCE LINE # 355
                                           ; SOURCE LINE # 356
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_102
0004 7900        R     MOV     R1,#LOW ?SC_102
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 357
0009 750000      R     MOV     wBytesRemainingOnIEP0,#00H
000C 750001      R     MOV     wBytesRemainingOnIEP0+01H,#01H
                                           ; SOURCE LINE # 358
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 28  

000F 7B00              MOV     R3,#00H
0011 7A00        R     MOV     R2,#HIGH bInterfaceNumber
0013 7900        R     MOV     R1,#LOW bInterfaceNumber
0015 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetInterface (END)

             ; FUNCTION usbSetInterface (BEGIN)
                                           ; SOURCE LINE # 361
                                           ; SOURCE LINE # 362
                                           ; SOURCE LINE # 363
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_118
0004 7900        R     MOV     R1,#LOW ?SC_118
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 364
0009 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
000C E0                MOVX    A,@DPTR
000D 4408              ORL     A,#08H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 365
0010 90FF04            MOV     DPTR,#tSetupPacket+04H
0013 E0                MOVX    A,@DPTR
0014 F500        R     MOV     bInterfaceNumber,A
                                           ; SOURCE LINE # 366
0016 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetInterface (END)

             ; FUNCTION usbGetDeviceStatus (BEGIN)
                                           ; SOURCE LINE # 375
                                           ; SOURCE LINE # 376
                                           ; SOURCE LINE # 377
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_134
0004 7900        R     MOV     R1,#LOW ?SC_134
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 378
0009 750000      R     MOV     wBytesRemainingOnIEP0,#00H
000C 750002      R     MOV     wBytesRemainingOnIEP0+01H,#02H
                                           ; SOURCE LINE # 379
000F 7B00              MOV     R3,#00H
0011 7A00        R     MOV     R2,#HIGH wDeviceFeatures
0013 7900        R     MOV     R1,#LOW wDeviceFeatures
0015 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetDeviceStatus (END)

             ; FUNCTION usbSetRemoteWakeup (BEGIN)
                                           ; SOURCE LINE # 382
                                           ; SOURCE LINE # 383
                                           ; SOURCE LINE # 384
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_147
0004 7900        R     MOV     R1,#LOW ?SC_147
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 385
0009 90FFFC            MOV     DPTR,#0FFFCH
000C E0                MOVX    A,@DPTR
000D 4408              ORL     A,#08H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 386
0010 430002      R     ORL     wDeviceFeatures,#02H
                                           ; SOURCE LINE # 387
0013 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 29  

0016 E0                MOVX    A,@DPTR
0017 4408              ORL     A,#08H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 388
001A 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetRemoteWakeup (END)

             ; FUNCTION usbClearRemoteWakeup (BEGIN)
                                           ; SOURCE LINE # 391
                                           ; SOURCE LINE # 392
                                           ; SOURCE LINE # 393
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_159
0004 7900        R     MOV     R1,#LOW ?SC_159
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 394
0009 90FFFC            MOV     DPTR,#0FFFCH
000C E0                MOVX    A,@DPTR
000D 54F7              ANL     A,#0F7H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 395
0010 5300FD      R     ANL     wDeviceFeatures,#0FDH
                                           ; SOURCE LINE # 396
0013 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
0016 E0                MOVX    A,@DPTR
0017 4408              ORL     A,#08H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 397
001A 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbClearRemoteWakeup (END)

             ; FUNCTION usbGetInterfaceStatus (BEGIN)
                                           ; SOURCE LINE # 402
                                           ; SOURCE LINE # 403
                                           ; SOURCE LINE # 404
0000 E4                CLR     A
0001 F500        R     MOV     wStatusBuffer,A
0003 F500        R     MOV     wStatusBuffer+01H,A
                                           ; SOURCE LINE # 405
0005 7BFF              MOV     R3,#0FFH
0007 7A00        R     MOV     R2,#HIGH ?SC_171
0009 7900        R     MOV     R1,#LOW ?SC_171
000B 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 406
000E 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
0011 E0                MOVX    A,@DPTR
0012 4408              ORL     A,#08H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 407
0015 750000      R     MOV     wBytesRemainingOnIEP0,#00H
0018 750002      R     MOV     wBytesRemainingOnIEP0+01H,#02H
                                           ; SOURCE LINE # 408
001B 7B00              MOV     R3,#00H
001D 7A00        R     MOV     R2,#HIGH wStatusBuffer
001F 7900        R     MOV     R1,#LOW wStatusBuffer
0021 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetInterfaceStatus (END)

             ; FUNCTION usbSetAddress (BEGIN)
                                           ; SOURCE LINE # 416
                                           ; SOURCE LINE # 417
                                           ; SOURCE LINE # 418
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 30  

0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_183
0004 7900        R     MOV     R1,#LOW ?SC_183
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 419
0009 90FF02            MOV     DPTR,#tSetupPacket+02H
000C E0                MOVX    A,@DPTR
000D FF                MOV     R7,A
000E 120000      E     LCALL   _rs232_printhex
                                           ; SOURCE LINE # 420
0011 7BFF              MOV     R3,#0FFH
0013 7A00        R     MOV     R2,#HIGH ?SC_42
0015 7900        R     MOV     R1,#LOW ?SC_42
0017 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 421
001A 90FF02            MOV     DPTR,#tSetupPacket+02H
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F C3                CLR     C
0020 9480              SUBB    A,#080H
0022 500D              JNC     ?C0046
                                           ; SOURCE LINE # 422
                                           ; SOURCE LINE # 423
0024 90FFFF            MOV     DPTR,#0FFFFH
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 424
0029 F500        R     MOV     bUsbDeviceAddress,A
                                           ; SOURCE LINE # 425
002B 750003      R     MOV     bStatusAction,#03H
                                           ; SOURCE LINE # 426
002E 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
                                           ; SOURCE LINE # 427
0031         ?C0046:
                                           ; SOURCE LINE # 429
0031 120000      R     LCALL   usbStallEndpoint0
                                           ; SOURCE LINE # 430
0034         ?C0048:
0034 22                RET     
             ; FUNCTION usbSetAddress (END)

             ; FUNCTION usbSetEndpointHalt (BEGIN)
                                           ; SOURCE LINE # 439
                                           ; SOURCE LINE # 440
                                           ; SOURCE LINE # 441
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_192
0004 7900        R     MOV     R1,#LOW ?SC_192
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 442
0009 90FF48            MOV     DPTR,#tInputEndPointDescriptorBlock
000C E0                MOVX    A,@DPTR
000D 547F              ANL     A,#07FH
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 443
0010 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbSetEndpointHalt (END)

             ; FUNCTION usbClearEndpointHalt (BEGIN)
                                           ; SOURCE LINE # 446
                                           ; SOURCE LINE # 447
                                           ; SOURCE LINE # 448
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 31  

0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_204
0004 7900        R     MOV     R1,#LOW ?SC_204
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 449
0009 90FF48            MOV     DPTR,#tInputEndPointDescriptorBlock
000C E0                MOVX    A,@DPTR
000D 4480              ORL     A,#080H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 450
0010 020000      R     LJMP    usbSendZeroLengthPacketOnIEP0
             ; FUNCTION usbClearEndpointHalt (END)

             ; FUNCTION usbGetEndpointStatus (BEGIN)
                                           ; SOURCE LINE # 453
                                           ; SOURCE LINE # 454
                                           ; SOURCE LINE # 455
0000 750001      R     MOV     wEndpointStatus,#01H
0003 750000      R     MOV     wEndpointStatus+01H,#00H
                                           ; SOURCE LINE # 456
0006 7BFF              MOV     R3,#0FFH
0008 7A00        R     MOV     R2,#HIGH ?SC_216
000A 7900        R     MOV     R1,#LOW ?SC_216
000C 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 457
000F 90FF48            MOV     DPTR,#tInputEndPointDescriptorBlock
0012 E0                MOVX    A,@DPTR
0013 30E705            JNB     ACC.7,?C0051
                                           ; SOURCE LINE # 458
0016 E4                CLR     A
0017 F500        R     MOV     wEndpointStatus,A
0019 F500        R     MOV     wEndpointStatus+01H,A
001B         ?C0051:
                                           ; SOURCE LINE # 460
001B 750000      R     MOV     wBytesRemainingOnIEP0,#00H
001E 750002      R     MOV     wBytesRemainingOnIEP0+01H,#02H
                                           ; SOURCE LINE # 461
0021 7B00              MOV     R3,#00H
0023 7A00        R     MOV     R2,#HIGH wEndpointStatus
0025 7900        R     MOV     R1,#LOW wEndpointStatus
0027 020000      R     LJMP    _usbSendDataPacketOnEP0
             ; FUNCTION usbGetEndpointStatus (END)

             ; FUNCTION usbNonStandardRequest (BEGIN)
                                           ; SOURCE LINE # 468
                                           ; SOURCE LINE # 469
                                           ; SOURCE LINE # 470
0000 7BFF              MOV     R3,#0FFH
0002 7A00        R     MOV     R2,#HIGH ?SC_227
0004 7900        R     MOV     R1,#LOW ?SC_227
0006 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 471
0009 020000      R     LJMP    usbStallEndpoint0
             ; FUNCTION usbNonStandardRequest (END)

             ; FUNCTION usbDecodeAndProcessUsbRequest (BEGIN)
                                           ; SOURCE LINE # 722
                                           ; SOURCE LINE # 723
                                           ; SOURCE LINE # 731
0000 7500FF      R     MOV     pbUsbRequestList,#0FFH
0003 750000      R     MOV     pbUsbRequestList+01H,#HIGH tUsbRequestList
0006 750000      R     MOV     pbUsbRequestList+02H,#LOW tUsbRequestList
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 32  

0009         ?C0054:
                                           ; SOURCE LINE # 736
                                           ; SOURCE LINE # 737
                                           ; SOURCE LINE # 738
0009 E4                CLR     A
000A F500        R     MOV     bResult,A
                                           ; SOURCE LINE # 739
;---- Variable 'bMask' assigned to Register 'R7' ----
000C 7F80              MOV     R7,#080H
                                           ; SOURCE LINE # 746
;---- Variable 'bTemp' assigned to Register 'R6' ----
000E FE                MOV     R6,A
000F         ?C0056:
                                           ; SOURCE LINE # 747
                                           ; SOURCE LINE # 748
000F AB00        R     MOV     R3,pbUsbRequestList
0011 AA00        R     MOV     R2,pbUsbRequestList+01H
0013 A900        R     MOV     R1,pbUsbRequestList+02H
0015 8E82              MOV     DPL,R6
0017 758300            MOV     DPH,#00H
001A 120000      E     LCALL   ?C?CLDOPTR
001D FD                MOV     R5,A
001E E4                CLR     A
001F 2E                ADD     A,R6
0020 F582              MOV     DPL,A
0022 E4                CLR     A
0023 34FF              ADDC    A,#0FFH
0025 F583              MOV     DPH,A
0027 E0                MOVX    A,@DPTR
0028 B50503            CJNE    A,AR5,?C0059
                                           ; SOURCE LINE # 749
002B EF                MOV     A,R7
002C 4200        R     ORL     bResult,A
002E         ?C0059:
                                           ; SOURCE LINE # 750
002E EF                MOV     A,R7
002F C3                CLR     C
0030 13                RRC     A
0031 FF                MOV     R7,A
                                           ; SOURCE LINE # 751
0032 0E                INC     R6
0033 BE08D9            CJNE    R6,#08H,?C0056
0036         ?C0057:
                                           ; SOURCE LINE # 761
0036 AB00        R     MOV     R3,pbUsbRequestList
0038 AA00        R     MOV     R2,pbUsbRequestList+01H
003A A900        R     MOV     R1,pbUsbRequestList+02H
003C 8E82              MOV     DPL,R6
003E 758300            MOV     DPH,#00H
0041 120000      E     LCALL   ?C?CLDOPTR
0044 FF                MOV     R7,A
0045 5500        R     ANL     A,bResult
0047 6F                XRL     A,R7
0048 600D              JZ      ?C0055
                                           ; SOURCE LINE # 762
004A         ?C0060:
                                           ; SOURCE LINE # 766
004A 740C              MOV     A,#0CH
004C 2500        R     ADD     A,pbUsbRequestList+02H
004E F500        R     MOV     pbUsbRequestList+02H,A
0050 E4                CLR     A
0051 3500        R     ADDC    A,pbUsbRequestList+01H
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 33  

0053 F500        R     MOV     pbUsbRequestList+01H,A
                                           ; SOURCE LINE # 767
0055 80B2              SJMP    ?C0054
0057         ?C0055:
                                           ; SOURCE LINE # 771
0057 90FFFE            MOV     DPTR,#0FFFEH
005A E0                MOVX    A,@DPTR
005B 20E00F            JB      ACC.0,?C0062
005E         ?C0061:
                                           ; SOURCE LINE # 776
005E AB00        R     MOV     R3,pbUsbRequestList
0060 AA00        R     MOV     R2,pbUsbRequestList+01H
0062 A900        R     MOV     R1,pbUsbRequestList+02H
0064 900009            MOV     DPTR,#09H
0067 120000      E     LCALL   ?C?PLDOPTR
006A 120000      E     LCALL   ?C?ICALL
                                           ; SOURCE LINE # 777
006D         ?C0062:
006D 22                RET     
             ; FUNCTION usbDecodeAndProcessUsbRequest (END)

             ; FUNCTION usbStallEndpoint0 (BEGIN)
                                           ; SOURCE LINE # 786
                                           ; SOURCE LINE # 787
                                           ; SOURCE LINE # 788
0000 90FF80            MOV     DPTR,#tEndPoint0DescriptorBlock
0003 E0                MOVX    A,@DPTR
0004 4408              ORL     A,#08H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 789
0007 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
000A E0                MOVX    A,@DPTR
000B 4408              ORL     A,#08H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 790
000E 22                RET     
             ; FUNCTION usbStallEndpoint0 (END)

             ; FUNCTION _usbReceiveDataPacketOnEP0 (BEGIN)
                                           ; SOURCE LINE # 804
;---- Variable 'pbBuffer' assigned to Register 'R1/R2/R3' ----
                                           ; SOURCE LINE # 805
                                           ; SOURCE LINE # 806
0000 8B00        R     MOV     pbOEP0Buffer,R3
0002 8A00        R     MOV     pbOEP0Buffer+01H,R2
0004 8900        R     MOV     pbOEP0Buffer+02H,R1
                                           ; SOURCE LINE # 807
0006 90FF07            MOV     DPTR,#tSetupPacket+07H
0009 E0                MOVX    A,@DPTR
000A FE                MOV     R6,A
000B 90FF06            MOV     DPTR,#tSetupPacket+06H
000E E0                MOVX    A,@DPTR
000F FD                MOV     R5,A
0010 EE                MOV     A,R6
0011 F500        R     MOV     wBytesRemainingOnOEP0,A
0013 ED                MOV     A,R5
0014 F500        R     MOV     wBytesRemainingOnOEP0+01H,A
                                           ; SOURCE LINE # 808
0016 750002      R     MOV     bStatusAction,#02H
                                           ; SOURCE LINE # 809
0019 E4                CLR     A
001A 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 34  

001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 810
001E 22                RET     
             ; FUNCTION _usbReceiveDataPacketOnEP0 (END)

             ; FUNCTION usbReceiveNextPacketOnOEP0 (BEGIN)
                                           ; SOURCE LINE # 812
                                           ; SOURCE LINE # 813
                                           ; SOURCE LINE # 819
0000 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0003 E0                MOVX    A,@DPTR
0004 547F              ANL     A,#07FH
0006 FF                MOV     R7,A
;---- Variable 'bByte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 826
0007 FD                MOV     R5,A
0008 C3                CLR     C
0009 E500        R     MOV     A,wBytesRemainingOnOEP0+01H
000B 9D                SUBB    A,R5
000C E500        R     MOV     A,wBytesRemainingOnOEP0
000E 9400              SUBB    A,#00H
0010 4055              JC      ?C0065
                                           ; SOURCE LINE # 827
                                           ; SOURCE LINE # 830
;---- Variable 'bIndex' assigned to Register 'R6' ----
0012 E4                CLR     A
0013 FE                MOV     R6,A
0014         ?C0066:
0014 EE                MOV     A,R6
0015 C3                CLR     C
0016 9F                SUBB    A,R7
0017 5021              JNC     ?C0067
                                           ; SOURCE LINE # 831
0019 74F0              MOV     A,#LOW abOEP0Buffer
001B 2E                ADD     A,R6
001C F582              MOV     DPL,A
001E E4                CLR     A
001F 34FE              ADDC    A,#HIGH abOEP0Buffer
0021 F583              MOV     DPH,A
0023 E0                MOVX    A,@DPTR
0024 FD                MOV     R5,A
0025 AB00        R     MOV     R3,pbOEP0Buffer
0027 0500        R     INC     pbOEP0Buffer+02H
0029 E500        R     MOV     A,pbOEP0Buffer+02H
002B AA00        R     MOV     R2,pbOEP0Buffer+01H
002D 7002              JNZ     ?C0112
002F 0500        R     INC     pbOEP0Buffer+01H
0031         ?C0112:
0031 14                DEC     A
0032 F9                MOV     R1,A
0033 ED                MOV     A,R5
0034 120000      E     LCALL   ?C?CSTPTR
0037 0E                INC     R6
0038 80DA              SJMP    ?C0066
003A         ?C0067:
                                           ; SOURCE LINE # 835
003A C3                CLR     C
003B E500        R     MOV     A,wBytesRemainingOnOEP0+01H
003D 9F                SUBB    A,R7
003E F500        R     MOV     wBytesRemainingOnOEP0+01H,A
0040 E500        R     MOV     A,wBytesRemainingOnOEP0
0042 9400              SUBB    A,#00H
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 35  

0044 F500        R     MOV     wBytesRemainingOnOEP0,A
                                           ; SOURCE LINE # 841
0046 D3                SETB    C
0047 E500        R     MOV     A,wBytesRemainingOnOEP0+01H
0049 9400              SUBB    A,#00H
004B E500        R     MOV     A,wBytesRemainingOnOEP0
004D 9400              SUBB    A,#00H
004F 4009              JC      ?C0069
                                           ; SOURCE LINE # 842
                                           ; SOURCE LINE # 843
0051 E4                CLR     A
0052 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 844
0056 750002      R     MOV     bStatusAction,#02H
                                           ; SOURCE LINE # 845
0059 22                RET     
005A         ?C0069:
                                           ; SOURCE LINE # 847
                                           ; SOURCE LINE # 856
005A 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
005D E0                MOVX    A,@DPTR
005E 4408              ORL     A,#08H
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 857
0061 E4                CLR     A
0062 F500        R     MOV     bStatusAction,A
                                           ; SOURCE LINE # 858
0064 020000      E     LJMP    OEP0SetLEDs
                                           ; SOURCE LINE # 859
                                           ; SOURCE LINE # 860
0067         ?C0065:
                                           ; SOURCE LINE # 862
                                           ; SOURCE LINE # 866
0067 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
006A E0                MOVX    A,@DPTR
006B 4408              ORL     A,#08H
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 867
006E E4                CLR     A
006F F500        R     MOV     bStatusAction,A
                                           ; SOURCE LINE # 868
                                           ; SOURCE LINE # 869
0071         ?C0072:
0071 22                RET     
             ; FUNCTION usbReceiveNextPacketOnOEP0 (END)

             ; FUNCTION usbSendZeroLengthPacketOnIEP0 (BEGIN)
                                           ; SOURCE LINE # 879
                                           ; SOURCE LINE # 880
                                           ; SOURCE LINE # 881
0000 74FF              MOV     A,#0FFH
0002 F500        R     MOV     wBytesRemainingOnIEP0,A
0004 F500        R     MOV     wBytesRemainingOnIEP0+01H,A
                                           ; SOURCE LINE # 882
0006 E4                CLR     A
0007 F500        R     MOV     bStatusAction,A
                                           ; SOURCE LINE # 883
0009 90FF81            MOV     DPTR,#tEndPoint0DescriptorBlock+01H
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 884
000D 22                RET     
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 36  

             ; FUNCTION usbSendZeroLengthPacketOnIEP0 (END)

             ; FUNCTION _usbSendDataPacketOnEP0 (BEGIN)
                                           ; SOURCE LINE # 899
;---- Variable 'pbBuffer' assigned to Register 'R1/R2/R3' ----
                                           ; SOURCE LINE # 900
                                           ; SOURCE LINE # 903
0000 8B00        R     MOV     pbIEP0Buffer,R3
0002 8A00        R     MOV     pbIEP0Buffer+01H,R2
0004 8900        R     MOV     pbIEP0Buffer+02H,R1
                                           ; SOURCE LINE # 905
0006 90FF07            MOV     DPTR,#tSetupPacket+07H
0009 E0                MOVX    A,@DPTR
000A FE                MOV     R6,A
000B 90FF06            MOV     DPTR,#tSetupPacket+06H
000E E0                MOVX    A,@DPTR
000F FD                MOV     R5,A
0010 ED                MOV     A,R5
0011 FF                MOV     R7,A
;---- Variable 'wTemp' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 909
0012 C3                CLR     C
0013 E500        R     MOV     A,wBytesRemainingOnIEP0+01H
0015 9F                SUBB    A,R7
0016 E500        R     MOV     A,wBytesRemainingOnIEP0
0018 9E                SUBB    A,R6
0019 4008              JC      ?C0074
                                           ; SOURCE LINE # 910
                                           ; SOURCE LINE # 911
001B 8E00        R     MOV     wBytesRemainingOnIEP0,R6
001D 8F00        R     MOV     wBytesRemainingOnIEP0+01H,R7
                                           ; SOURCE LINE # 912
001F C200        R     CLR     bHostAskMoreDataThanAvailable
                                           ; SOURCE LINE # 913
0021 8002              SJMP    ?C0075
0023         ?C0074:
                                           ; SOURCE LINE # 915
                                           ; SOURCE LINE # 916
0023 D200        R     SETB    bHostAskMoreDataThanAvailable
                                           ; SOURCE LINE # 917
0025         ?C0075:
                                           ; SOURCE LINE # 919
0025 020000      R     LJMP    usbSendNextPacketOnIEP0
             ; FUNCTION _usbSendDataPacketOnEP0 (END)

             ; FUNCTION usbSendNextPacketOnIEP0 (BEGIN)
                                           ; SOURCE LINE # 922
;---- Variable 'bPacketSize' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 923
                                           ; SOURCE LINE # 927
0000 E500        R     MOV     A,wBytesRemainingOnIEP0+01H
0002 F4                CPL     A
0003 7003              JNZ     ?C0113
0005 E500        R     MOV     A,wBytesRemainingOnIEP0
0007 F4                CPL     A
0008         ?C0113:
0008 6070              JZ      ?C0077
                                           ; SOURCE LINE # 928
                                           ; SOURCE LINE # 929
000A D3                SETB    C
000B E500        R     MOV     A,wBytesRemainingOnIEP0+01H
000D 9408              SUBB    A,#08H
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 37  

000F E500        R     MOV     A,wBytesRemainingOnIEP0
0011 9400              SUBB    A,#00H
0013 4010              JC      ?C0078
                                           ; SOURCE LINE # 930
                                           ; SOURCE LINE # 933
0015 7F08              MOV     R7,#08H
                                           ; SOURCE LINE # 934
0017 74F8              MOV     A,#0F8H
0019 2500        R     ADD     A,wBytesRemainingOnIEP0+01H
001B F500        R     MOV     wBytesRemainingOnIEP0+01H,A
001D 74FF              MOV     A,#0FFH
001F 3500        R     ADDC    A,wBytesRemainingOnIEP0
0021 F500        R     MOV     wBytesRemainingOnIEP0,A
                                           ; SOURCE LINE # 935
                                           ; SOURCE LINE # 936
0023 8019              SJMP    ?C0118
0025         ?C0078:
                                           ; SOURCE LINE # 937
0025 C3                CLR     C
0026 E500        R     MOV     A,wBytesRemainingOnIEP0+01H
0028 9408              SUBB    A,#08H
002A E500        R     MOV     A,wBytesRemainingOnIEP0
002C 9400              SUBB    A,#00H
002E 5004              JNC     ?C0080
                                           ; SOURCE LINE # 938
                                           ; SOURCE LINE # 941
0030 AF00        R     MOV     R7,wBytesRemainingOnIEP0+01H
                                           ; SOURCE LINE # 942
                                           ; SOURCE LINE # 943
                                           ; SOURCE LINE # 944
0032 800F              SJMP    ?C0119
0034         ?C0080:
                                           ; SOURCE LINE # 946
                                           ; SOURCE LINE # 948
0034 7F08              MOV     R7,#08H
                                           ; SOURCE LINE # 949
0036 30000A      R     JNB     bHostAskMoreDataThanAvailable,?C0082
                                           ; SOURCE LINE # 950
                                           ; SOURCE LINE # 951
0039 E4                CLR     A
003A F500        R     MOV     wBytesRemainingOnIEP0,A
003C F500        R     MOV     wBytesRemainingOnIEP0+01H,A
                                           ; SOURCE LINE # 952
003E         ?C0118:
003E 750001      R     MOV     bStatusAction,#01H
                                           ; SOURCE LINE # 953
0041 8009              SJMP    ?C0079
0043         ?C0082:
                                           ; SOURCE LINE # 955
                                           ; SOURCE LINE # 956
0043         ?C0119:
0043 74FF              MOV     A,#0FFH
0045 F500        R     MOV     wBytesRemainingOnIEP0,A
0047 F500        R     MOV     wBytesRemainingOnIEP0+01H,A
                                           ; SOURCE LINE # 957
0049 E4                CLR     A
004A F500        R     MOV     bStatusAction,A
                                           ; SOURCE LINE # 958
                                           ; SOURCE LINE # 959
004C         ?C0079:
                                           ; SOURCE LINE # 961
;---- Variable 'bIndex' assigned to Register 'R6' ----
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 38  

004C E4                CLR     A
004D FE                MOV     R6,A
004E         ?C0084:
004E EE                MOV     A,R6
004F C3                CLR     C
0050 9F                SUBB    A,R7
0051 5021              JNC     ?C0085
                                           ; SOURCE LINE # 962
0053 AB00        R     MOV     R3,pbIEP0Buffer
0055 0500        R     INC     pbIEP0Buffer+02H
0057 E500        R     MOV     A,pbIEP0Buffer+02H
0059 AA00        R     MOV     R2,pbIEP0Buffer+01H
005B 7002              JNZ     ?C0114
005D 0500        R     INC     pbIEP0Buffer+01H
005F         ?C0114:
005F 14                DEC     A
0060 F9                MOV     R1,A
0061 120000      E     LCALL   ?C?CLDPTR
0064 FD                MOV     R5,A
0065 74F8              MOV     A,#LOW abIEP0Buffer
0067 2E                ADD     A,R6
0068 F582              MOV     DPL,A
006A E4                CLR     A
006B 34FE              ADDC    A,#HIGH abIEP0Buffer
006D F583              MOV     DPH,A
006F ED                MOV     A,R5
0070 F0                MOVX    @DPTR,A
0071 0E                INC     R6
0072 80DA              SJMP    ?C0084
0074         ?C0085:
                                           ; SOURCE LINE # 964
0074 90FF81            MOV     DPTR,#tEndPoint0DescriptorBlock+01H
0077 EF                MOV     A,R7
0078 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 965
0079 22                RET     
007A         ?C0077:
                                           ; SOURCE LINE # 967
                                           ; SOURCE LINE # 968
007A E4                CLR     A
007B F500        R     MOV     bStatusAction,A
                                           ; SOURCE LINE # 969
                                           ; SOURCE LINE # 970
007D         ?C0088:
007D 22                RET     
             ; FUNCTION usbSendNextPacketOnIEP0 (END)

             ; FUNCTION SetupPacketInterruptHandler (BEGIN)
                                           ; SOURCE LINE # 983
                                           ; SOURCE LINE # 984
                                           ; SOURCE LINE # 987
0000 90FF81            MOV     DPTR,#tEndPoint0DescriptorBlock+01H
0003 7480              MOV     A,#080H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 988
0006 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 990
000A 90FFFE            MOV     DPTR,#0FFFEH
000D 7404              MOV     A,#04H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 994
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 39  

0010 90FF00            MOV     DPTR,#tSetupPacket
0013 E0                MOVX    A,@DPTR
0014 90FFFC            MOV     DPTR,#0FFFCH
0017 30E706            JNB     ACC.7,?C0089
                                           ; SOURCE LINE # 995
001A E0                MOVX    A,@DPTR
001B 4401              ORL     A,#01H
001D F0                MOVX    @DPTR,A
001E 8004              SJMP    ?C0090
0020         ?C0089:
                                           ; SOURCE LINE # 997
0020 E0                MOVX    A,@DPTR
0021 54FE              ANL     A,#0FEH
0023 F0                MOVX    @DPTR,A
0024         ?C0090:
                                           ; SOURCE LINE # 1002
0024 E4                CLR     A
0025 F500        R     MOV     bStatusAction,A
                                           ; SOURCE LINE # 1006
0027 020000      R     LJMP    usbDecodeAndProcessUsbRequest
             ; FUNCTION SetupPacketInterruptHandler (END)

             ; FUNCTION OEP0InterruptHandler (BEGIN)
                                           ; SOURCE LINE # 1018
                                           ; SOURCE LINE # 1019
                                           ; SOURCE LINE # 1021
0000 E4                CLR     A
0001 90FF81            MOV     DPTR,#tEndPoint0DescriptorBlock+01H
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1022
0005 7BFF              MOV     R3,#0FFH
0007 7A00        R     MOV     R2,#HIGH ?SC_244
0009 7900        R     MOV     R1,#LOW ?SC_244
000B 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1023
000E 90FEF0            MOV     DPTR,#abOEP0Buffer
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 120000      E     LCALL   _rs232_printhex
                                           ; SOURCE LINE # 1024
0016 7BFF              MOV     R3,#0FFH
0018 7A00        R     MOV     R2,#HIGH ?SC_42
001A 7900        R     MOV     R1,#LOW ?SC_42
001C 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1031
001F E500        R     MOV     A,bStatusAction
0021 B40203            CJNE    A,#02H,?C0092
                                           ; SOURCE LINE # 1032
0024 020000      R     LJMP    usbReceiveNextPacketOnOEP0
0027         ?C0092:
                                           ; SOURCE LINE # 1034
0027 90FF82            MOV     DPTR,#tEndPoint0DescriptorBlock+02H
002A E0                MOVX    A,@DPTR
002B 4408              ORL     A,#08H
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1035
002E         ?C0094:
002E 22                RET     
             ; FUNCTION OEP0InterruptHandler (END)

             ; FUNCTION IEP0InterruptHandler (BEGIN)
                                           ; SOURCE LINE # 1051
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 40  

                                           ; SOURCE LINE # 1052
                                           ; SOURCE LINE # 1054
0000 E4                CLR     A
0001 90FF83            MOV     DPTR,#tEndPoint0DescriptorBlock+03H
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1062
0005 E500        R     MOV     A,bStatusAction
0007 B40103            CJNE    A,#01H,?C0095
                                           ; SOURCE LINE # 1063
000A 020000      R     LJMP    usbSendNextPacketOnIEP0
000D         ?C0095:
                                           ; SOURCE LINE # 1064
000D E500        R     MOV     A,bStatusAction
000F B40307            CJNE    A,#03H,?C0097
                                           ; SOURCE LINE # 1065
0012 90FFFF            MOV     DPTR,#0FFFFH
0015 E500        R     MOV     A,bUsbDeviceAddress
0017 F0                MOVX    @DPTR,A
0018 22                RET     
0019         ?C0097:
                                           ; SOURCE LINE # 1067
0019 90FF80            MOV     DPTR,#tEndPoint0DescriptorBlock
001C E0                MOVX    A,@DPTR
001D 4408              ORL     A,#08H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1068
0020         ?C0099:
0020 22                RET     
             ; FUNCTION IEP0InterruptHandler (END)

             ; FUNCTION USBInterrupt (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
000A 75D000            MOV     PSW,#00H
000D C000              PUSH    AR0
000F C001              PUSH    AR1
0011 C002              PUSH    AR2
0013 C003              PUSH    AR3
0015 C004              PUSH    AR4
0017 C005              PUSH    AR5
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
                                           ; SOURCE LINE # 1082
                                           ; SOURCE LINE # 1085
001D C2AF              CLR     EA
                                           ; SOURCE LINE # 1087
001F 90FF92            MOV     DPTR,#0FF92H
0022 E0                MOVX    A,@DPTR
0023 120000      E     LCALL   ?C?CCASE
0026 0000        R     DW      ?C0104
0028 12                DB      012H
0029 0000        R     DW      ?C0103
002B 22                DB      022H
002C 0000        R     DW      ?C0105
002E 30                DB      030H
002F 0000        R     DW      ?C0106
0031 32                DB      032H
0032 0000        R     DW      ?C0108
0034 38                DB      038H
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 41  

0035 0000        R     DW      ?C0109
0037 3A                DB      03AH
0038 0000        R     DW      ?C0107
003A 3C                DB      03CH
003B 0000        R     DW      ?C0102
003D 44                DB      044H
003E 0000        R     DW      ?C0101
0040 46                DB      046H
0041 0000              DW      00H
0043 0000        R     DW      ?C0110
                                           ; SOURCE LINE # 1088
                                           ; SOURCE LINE # 1089
0045         ?C0101:
                                           ; SOURCE LINE # 1090
0045 90FF92            MOV     DPTR,#0FF92H
0048 E4                CLR     A
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1091
004A 7BFF              MOV     R3,#0FFH
004C 7A00        R     MOV     R2,#HIGH ?SC_254
004E 7900        R     MOV     R1,#LOW ?SC_254
0050 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1092
0053 120000      R     LCALL   OEP0InterruptHandler
                                           ; SOURCE LINE # 1093
0056 020000      R     LJMP    ?C0100
                                           ; SOURCE LINE # 1095
0059         ?C0102:
                                           ; SOURCE LINE # 1096
0059 90FF92            MOV     DPTR,#0FF92H
005C E4                CLR     A
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1097
005E 7BFF              MOV     R3,#0FFH
0060 7A00        R     MOV     R2,#HIGH ?SC_264
0062 7900        R     MOV     R1,#LOW ?SC_264
0064 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1098
0067 120000      R     LCALL   IEP0InterruptHandler
                                           ; SOURCE LINE # 1099
006A 020000      R     LJMP    ?C0100
                                           ; SOURCE LINE # 1101
006D         ?C0103:
                                           ; SOURCE LINE # 1102
006D 90FF92            MOV     DPTR,#0FF92H
0070 E4                CLR     A
0071 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1103
0072 7BFF              MOV     R3,#0FFH
0074 7A00        R     MOV     R2,#HIGH ?SC_273
0076 7900        R     MOV     R1,#LOW ?SC_273
0078 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1104
007B 120000      E     LCALL   IEP1InterruptHandler
                                           ; SOURCE LINE # 1105
007E 8079              SJMP    ?C0100
                                           ; SOURCE LINE # 1107
0080         ?C0104:
                                           ; SOURCE LINE # 1108
0080 90FF92            MOV     DPTR,#0FF92H
0083 E4                CLR     A
0084 F0                MOVX    @DPTR,A
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 42  

                                           ; SOURCE LINE # 1109
0085 7BFF              MOV     R3,#0FFH
0087 7A00        R     MOV     R2,#HIGH ?SC_282
0089 7900        R     MOV     R1,#LOW ?SC_282
008B 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1110
008E 120000      R     LCALL   OEP1InterruptHandler
                                           ; SOURCE LINE # 1111
0091 8066              SJMP    ?C0100
                                           ; SOURCE LINE # 1113
0093         ?C0105:
                                           ; SOURCE LINE # 1114
0093 90FF92            MOV     DPTR,#0FF92H
0096 E4                CLR     A
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1115
0098 90FFFE            MOV     DPTR,#0FFFEH
009B 04                INC     A
009C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1116
009D 7BFF              MOV     R3,#0FFH
009F 7A00        R     MOV     R2,#HIGH ?SC_292
00A1 7900        R     MOV     R1,#LOW ?SC_292
                                           ; SOURCE LINE # 1117
                                           ; SOURCE LINE # 1118
00A3 800B              SJMP    ?C0120
                                           ; SOURCE LINE # 1120
00A5         ?C0106:
                                           ; SOURCE LINE # 1122
00A5 90FF92            MOV     DPTR,#0FF92H
00A8 E4                CLR     A
00A9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1124
00AA 7BFF              MOV     R3,#0FFH
00AC 7A00        R     MOV     R2,#HIGH ?SC_300
00AE 7900        R     MOV     R1,#LOW ?SC_300
00B0         ?C0120:
00B0 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1125
00B3 120000      R     LCALL   SetupPacketInterruptHandler
                                           ; SOURCE LINE # 1126
00B6 8041              SJMP    ?C0100
                                           ; SOURCE LINE # 1128
00B8         ?C0107:
                                           ; SOURCE LINE # 1129
00B8 90FF92            MOV     DPTR,#0FF92H
00BB E4                CLR     A
00BC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1130
00BD 90FFFE            MOV     DPTR,#0FFFEH
00C0 7480              MOV     A,#080H
00C2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1131
00C3 120000      E     LCALL   UsbReset
                                           ; SOURCE LINE # 1132
00C6 8031              SJMP    ?C0100
                                           ; SOURCE LINE # 1134
00C8         ?C0108:
                                           ; SOURCE LINE # 1135
00C8 90FF92            MOV     DPTR,#0FF92H
00CB E4                CLR     A
00CC F0                MOVX    @DPTR,A
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 43  

                                           ; SOURCE LINE # 1136
00CD 90FFFE            MOV     DPTR,#0FFFEH
00D0 7420              MOV     A,#020H
00D2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1137
00D3 C200        R     CLR     bSuspended
                                           ; SOURCE LINE # 1138
00D5 8022              SJMP    ?C0100
                                           ; SOURCE LINE # 1140
00D7         ?C0109:
                                           ; SOURCE LINE # 1141
00D7 90FF92            MOV     DPTR,#0FF92H
00DA E4                CLR     A
00DB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1142
00DC 90FFFE            MOV     DPTR,#0FFFEH
00DF 7440              MOV     A,#040H
00E1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1143
00E2 7BFF              MOV     R3,#0FFH
00E4 7A00        R     MOV     R2,#HIGH ?SC_310
00E6 7900        R     MOV     R1,#LOW ?SC_310
00E8 120000      E     LCALL   _rs232_printstr
                                           ; SOURCE LINE # 1144
00EB D200        R     SETB    bSuspended
                                           ; SOURCE LINE # 1145
00ED 800A              SJMP    ?C0100
                                           ; SOURCE LINE # 1147
00EF         ?C0110:
                                           ; SOURCE LINE # 1148
00EF 90FF92            MOV     DPTR,#0FF92H
00F2 E4                CLR     A
00F3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1149
00F4 E0                MOVX    A,@DPTR
00F5 FF                MOV     R7,A
00F6 120000      E     LCALL   _rs232_printhex
                                           ; SOURCE LINE # 1150
                                           ; SOURCE LINE # 1151
00F9         ?C0100:
                                           ; SOURCE LINE # 1154
00F9 D2AF              SETB    EA
                                           ; SOURCE LINE # 1155
00FB D007              POP     AR7
00FD D006              POP     AR6
00FF D005              POP     AR5
0101 D004              POP     AR4
0103 D003              POP     AR3
0105 D002              POP     AR2
0107 D001              POP     AR1
0109 D000              POP     AR0
010B D0D0              POP     PSW
010D D082              POP     DPL
010F D083              POP     DPH
0111 D0F0              POP     B
0113 D0E0              POP     ACC
0115 32                RETI    
             ; FUNCTION USBInterrupt (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V8.02   USB                                                                   02/01/2011 10:20:44 PAGE 44  

   CODE SIZE        =   1742    ----
   CONSTANT SIZE    =    593    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
