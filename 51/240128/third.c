/*********************************************************************************/
/* LCM MGLS-240128TA （ ）显示程序   */
/* MCU 型号 : Winbond W78E58-24 */
/* 时钟频率 : 22.1184 MHz */
/* 接口方式 :  直接接口（挂总线） */
/* 开发环境 : Keil C51 V6.14 */
/* 开发日期 : 2001.06.12- */
/* 程序编写 : Youth */
/*********************************************************************************/
#include <absacc.h>
#include <reg52.h>
#include <stdarg.h>
#include <stdio.h>
#define ulong unsigned long
//Ascii data
#define STX 0x02
#define ETX 0x03
#define EOT 0x04
#define ENQ 0x05
#define BS 0x08
#define CR 0x0D
#define LF 0x0A
#define DLE 0x10
#define ETB 0x17
#define SPACE 0x20
#define COMMA 0x2C
                
#define TRUE 1
#define FALSE 0
                
#define HIGH 1
#define LOW 0
// T6963C 端口定义6

#define LCMDW 	XBYTE[0x9000] // 数据口
#define LCMCW 	XBYTE[0x9001] // 命令口
// T6963C 命令定义
#define LC_CUR_POS 	0x21 // 光标位置设置
#define LC_CGR_POS 	0x22 // CGRAM偏置地址设置
#define LC_ADD_POS 	0x24 // 地址指针位置
#define LC_TXT_STP 	0x40 // 文本区首址
#define LC_TXT_WID 	0x41 // 文本区宽度
#define LC_GRH_STP 	0x42 // 图形区首址
#define LC_GRH_WID 	0x43 // 图形区宽度
#define LC_MOD_OR 	0x80 // 显示方式：逻辑“或”
#define LC_MOD_XOR  0x81 // 显示方式：逻辑“异或”
#define LC_MOD_AND  0x82 // 显示方式：逻辑“与”
#define LC_MOD_TCH	0x83 // 显示方式：文本特征
#define LC_DIS_SW 	0x90	//  D0=1/0: /显示开关： 光标闪烁启用 禁用；
								//  D1=1/0: /光标显示启用 禁用；
								//  D2=1/0: /文本显示启用 禁用；
								//  D3=1/0: /图形显示启用 禁用；
#define LC_CUR_SHP 	0xA0 //  0xA0-0xA7光标形状选择： 表示光标占的行数
#define LC_AUT_WR 	0xB0 // 自动写设置
#define LC_AUT_RD 	0xB1 // 自动读设置
#define LC_AUT_OVR	0xB2 //  /自动读 写结束
#define LC_INC_WR 	0xC0 //  1数据一次写，地址加
#define LC_INC_RD 	0xC1 //  1数据一次读，地址加
#define LC_DEC_WR 	0xC2 //  1数据一次写，地址减
#define LC_DEC_RD 	0xC3 //  1数据一次读，地址减
#define LC_NOC_WR 	0xC4 // 数据一次写，地址不变
#define LC_NOC_RD 	0xC5 // 数据一次读，地址不变

#define LC_SCN_RD 	0xE0 // 屏读
#define LC_SCN_CP 	0xE8 // 屏拷贝
#define LC_BIT_OP 	0xF0 //  D0-D2 D0-D7 D3 1 0位操作： ：定义 位； ： 置位； ：清除
code unsigned char const uPowArr[]   = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
// ASCII 字模宽度及高度定义
#define ASC_CHR_WIDTH  8
#define ASC_CHR_HEIGHT 12
// ASCII  8*16字模，显示为
char code ASC_MSK[96*12] = {
// Terminal9;    x =8x12此字体下对应的点阵为：宽 高
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff, // < 0x20 ,时 打印此字
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ' '
0x00,0x0C,0x1E,0x1E,0x1E,0x0C,0x0C,0x00,0x0C,0x0C,0x00,0x00,// '!'
0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '"'
0x00,0x36,0x36,0x7F,0x36,0x36,0x36,0x7F,0x36,0x36,0x00,0x00, // '#'


0x00,0x63,0x63,0x67,0x6F,0x7F,0x7B,0x73,0x63,0x63,0x00,0x00, // 'N'
0x00,0x1C,0x36,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x00,0x00, // 'O'
0x00,0x3F,0x66,0x66,0x66,0x3E,0x06,0x06,0x06,0x0F,0x00,0x00, // 'P'
0x00,0x1C,0x36,0x63,0x63,0x63,0x73,0x7B,0x3E,0x30,0x78,0x00, // 'Q'8

0x00,0x3F,0x66,0x66,0x66,0x3E,0x36,0x66,0x66,0x67,0x00,0x00, // 'R'
0x00,0x1E,0x33,0x33,0x03,0x0E,0x18,0x33,0x33,0x1E,0x00,0x00, // 'S'
0x00,0x3F,0x2D,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,// 'T'
0x00,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x1E,0x00,0x00, // 'U'
0x00,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x1E,0x0C,0x00,0x00, // 'V'
0x00,0x63,0x63,0x63,0x63,0x6B,0x6B,0x36,0x36,0x36,0x00,0x00, // 'W'
0x00,0x33,0x33,0x33,0x1E,0x0C,0x1E,0x33,0x33,0x33,0x00,0x00, // 'X'
0x00,0x33,0x33,0x33,0x33,0x1E,0x0C,0x0C,0x0C,0x1E,0x00,0x00, // 'Y'
0x00,0x7F,0x73,0x19,0x18,0x0C,0x06,0x46,0x63,0x7F,0x00,0x00, // 'Z'
0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,// '['
0x00,0x00,0x01,0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00,0x00, // '\'
0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00, // ']'
0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '^'
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00, // '_'
0x0C,0x0C,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '`'
0x00,0x00,0x00,0x00,0x1E,0x30,0x3E,0x33,0x33,0x6E,0x00,0x00, // 'a'
0x00,0x07,0x06,0x06,0x3E,0x66,0x66,0x66,0x66,0x3B,0x00,0x00, // 'b'
0x00,0x00,0x00,0x00,0x1E,0x33,0x03,0x03,0x33,0x1E,0x00,0x00, // 'c'
0x00,0x38,0x30,0x30,0x3E,0x33,0x33,0x33,0x33,0x6E,0x00,0x00, // 'd'
0x00,0x00,0x00,0x00,0x1E,0x33,0x3F,0x03,0x33,0x1E,0x00,0x00, // 'e'
0x00,0x1C,0x36,0x06,0x06,0x1F,0x06,0x06,0x06,0x0F,0x00,0x00, // 'f'
0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x3E,0x30,0x33,0x1E, // 'g'
0x00,0x07,0x06,0x06,0x36,0x6E,0x66,0x66,0x66,0x67,0x00,0x00, // 'h'
0x00,0x18,0x18,0x00,0x1E,0x18,0x18,0x18,0x18,0x7E,0x00,0x00, // 'i'
0x00,0x30,0x30,0x00,0x3C,0x30,0x30,0x30,0x30,0x33,0x33,0x1E, // 'j'
0x00,0x07,0x06,0x06,0x66,0x36,0x1E,0x36,0x66,0x67,0x00,0x00, // 'k'
0x00,0x1E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00, // 'l'
0x00,0x00,0x00,0x00,0x3F,0x6B,0x6B,0x6B,0x6B,0x63,0x00,0x00, // 'm'
0x00,0x00,0x00,0x00,0x1F,0x33,0x33,0x33,0x33,0x33,0x00,0x00, // 'n'
0x00,0x00,0x00,0x00,0x1E,0x33,0x33,0x33,0x33,0x1E,0x00,0x00, // 'o'
0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x0F, // 'p'
0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x3E,0x30,0x78, // 'q'
0x00,0x00,0x00,0x00,0x37,0x76,0x6E,0x06,0x06,0x0F,0x00,0x00, // 'r'
0x00,0x00,0x00,0x00,0x1E,0x33,0x06,0x18,0x33,0x1E,0x00,0x00, // 's'
0x00,0x00,0x04,0x06,0x3F,0x06,0x06,0x06,0x36,0x1C,0x00,0x00, // 't'
0x00,0x00,0x00,0x00,0x33,0x33,0x33,0x33,0x33,0x6E,0x00,0x00, // 'u'
0x00,0x00,0x00,0x00,0x33,0x33,0x33,0x33,0x1E,0x0C,0x00,0x00, // 'v'
0x00,0x00,0x00,0x00,0x63,0x63,0x6B,0x6B,0x36,0x36,0x00,0x00, // 'w'
0x00,0x00,0x00,0x00,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00,0x00, // 'x'
0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x30,0x18,0x0F, // 'y'
0x00,0x00,0x00,0x00,0x3F,0x31,0x18,0x06,0x23,0x3F,0x00,0x00, // 'z'
0x00,0x38,0x0C,0x0C,0x06,0x03,0x06,0x0C,0x0C,0x38,0x00,0x00, // '{'
0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x00,0x00, // '|'
0x00,0x07,0x0C,0x0C,0x18,0x30,0x18,0x0C,0x0C,0x07,0x00,0x00, // '}'
0x00,0xCE,0x5B,0x73,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '~'
};

typedef struct typFNT_GB16 // 汉字字模显示数据结构
{
char Index[2];
char Msk[32];
};

struct typFNT_GB16 xdata GB_16[] = { //  16*16显示为" 中 "," 文 "," 测 "," 试 "
		0x01,0x00,0x01,0x00,0x21,0x08,0x3F,0xFC,0x21,0x08,0x21,0x08,0x21,0x08,0x21,0x08,
		0x21,0x08,0x3F,0xF8,0x21,0x08,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,
		0x02,0x00,0x01,0x00,0x01,0x00,0xFF,0xFE,0x08,0x20,0x08,0x20,0x08,0x20,0x04,0x40,
		0x04,0x40,0x02,0x80,0x01,0x00,0x02,0x80,0x04,0x60,0x18,0x1E,0xE0,0x08,0x00,0x00,
		0x40,0x02,0x27,0xC2,0x24,0x42,0x84,0x52,0x45,0x52,0x55,0x52,0x15,0x52,0x25,0x52,
		0x25,0x52,0x25,0x52,0xC5,0x52,0x41,0x02,0x42,0x82,0x42,0x42,0x44,0x4A,0x48,0x04,
		0x00,0x20,0x40,0x28,0x20,0x24,0x30,0x24,0x27,0xFE,0x00,0x20,0xE0,0x20,0x27,0xE0,
		0x21,0x20,0x21,0x10,0x21,0x10,0x21,0x0A,0x29,0xCA,0x36,0x06,0x20,0x02,0x00,0x00,
};
unsigned char gCurRow,gCurCol; //  16 8当前行、列存储，行高 点，列宽 点
unsigned char fnGetRow(void)
{
	return gCurRow;
}
unsigned char fnGetCol(void)
{
	return gCurCol;
}
unsigned char fnST01(void) //  STA1,STA0状态位 判断（读写指令和读写数据）
{
	unsigned char i;
	for(i=10;i>0;i--)
	{
		if((LCMCW & 0x03) == 0x03)
		break;
	}
	return i; // 若返回零，说明错误
}
unsigned char fnST2(void) //  ST2状态位 判断（数据自动读状态）
{
	unsigned char i;
	for(i=10;i>0;i--)
	{
		if((LCMCW & 0x04) == 0x04)
		break;
	}
	return i; // 若返回零，说明错误
}
unsigned char fnST3(void) //  ST3状态位 判断（数据自动写状态）
{
	unsigned char i;
	for(i=10;i>0;i--)
	{
		if((LCMCW & 0x08) == 0x08)
		break;
	}
	return i; // 若返回零，说明错误
}
unsigned char fnST6(void) //  ST6 /状态位 判断（屏读 屏拷贝状态）
{
	unsigned char i;
	for(i=10;i>0;i--)
	{
		if((LCMCW & 0x40) == 0x40)
		break;
	}
	return i; // 若返回零，说明错误
}
unsigned char fnPR1(unsigned char uCmd,unsigned char uPar1,unsigned char uPar2) // 写双参数的指令
{
	if(fnST01() == 0)
		return 1;
	LCMDW = uPar1;
	if(fnST01() == 0)
		return 2;
	LCMDW = uPar2;
	if(fnST01() == 0)
		return 3;
	LCMCW = uCmd;
	return 0; //  0返回 成功
}
unsigned char fnPR11(unsigned char uCmd,unsigned char uPar1) // 写单参数的指令
{
	if(fnST01() == 0)
		return 1;
	LCMDW = uCmd;
	if(fnST01() == 0)
		return 2;
	LCMCW = uPar1;
	return 0; //  0返回 成功
}
unsigned char fnPR12(unsigned char uCmd) // 写无参数的指令
{
	if(fnST01() == 0)
		return 1;
	LCMCW = uCmd;
	return 0; //  0返回 成功
}
unsigned char fnPR13(unsigned char uData) // 写数据
{
	if(fnST3() == 0)
		return 1;
	LCMDW = uData;
	return 0; //  0返回 成功
}
unsigned char fnPR2(void) // 读数据
{
	if(fnST01() == 0)
		return 1;
	return LCMDW;
}
// 设置当前地址
void fnSetPos(unsigned char urow, unsigned char ucol)
{
	unsigned int  iPos;
	iPos = urow * 30 + ucol;
	fnPR1(LC_ADD_POS,iPos & 0xFF,iPos / 256);
	gCurRow = urow;
	gCurCol = ucol;
}
// 设置当前显示行、列
void cursor(unsigned char uRow, unsigned char uCol)
{
	fnSetPos(uRow * 16, uCol);
}
// 清屏
void cls(void)
{
	unsigned int  i;
	fnPR1(LC_ADD_POS,0x00,0x00); // 置地址指针
	fnPR12(LC_AUT_WR); // 自动写
	for(i=0;i<240*30;i++)
	{
		fnST3();
		fnPR13(0x00); // 写数据
	}
	fnPR12(LC_AUT_OVR); // 自动写结束
	fnPR1(LC_ADD_POS,0x00,0x00); // 重置地址指针
	gCurRow = 0; // 置地址指针存储变量
	gCurCol = 0;
}
// LCM 初始化
char fnLCMInit(void)
{
	if(fnPR1(LC_TXT_STP,0x00,0x00) != 0) // 文本显示区首地址
		return -1;
	fnPR1(LC_TXT_WID,0x1E,0x00); // 文本显示区宽度
	fnPR1(LC_GRH_STP,0x00,0x00); // 图形显示区首地址
	fnPR1(LC_GRH_WID,0x1E,0x00); // 图形显示区宽度
	fnPR12(LC_CUR_SHP | 0x01); // 光标形状
	fnPR12(LC_MOD_OR); // 显示方式设置
	fnPR12(LC_DIS_SW | 0x08); // 显示开关设置
	return 0;
}
// ASCII(8*16)    (16*16) 及 汉字 显示函数
unsigned char dprintf(char *fmt, ...)
{
	va_list arg_ptr;
	char  c1,c2,cData;
	char tmpBuf[64]; // LCD显示数据缓冲区
	unsigned char i=0,j,uLen,uRow,uCol;
	unsigned int  k;
	va_start(arg_ptr, fmt);
	uLen = (unsigned char)vsprintf(tmpBuf, fmt, arg_ptr);
	va_end(arg_ptr);
	while(i<uLen)
	{
		c1 = tmpBuf[i];
		c2 = tmpBuf[i+1];
		uRow = fnGetRow();
		uCol = fnGetCol();
		if(c1 >= 0)
		{ // ASCII
			if(c1 < 0x20)
			{
				switch(c1)
				{
					case CR:
					case LF: // 回车或换行
						i++;
					if(uRow < 112)
						fnSetPos(uRow+16,0);
					else
						fnSetPos(0,0);
					continue;
					case BS: // 退格
						if(uCol > 0)
							uCol--;
						fnSetPos(uRow,uCol);
						cData = 0x00;
					break;
					default: // 其他
						c1 = 0x1f;
				}
			}
			for(j=0;j<16;j++)
			{
				fnPR12(LC_AUT_WR); // 写数据
				if(c1 >= 0x1f)
				{
					if(j < (16-ASC_CHR_HEIGHT))
						fnPR13(0x00);
					else
						fnPR13(ASC_MSK[(c1-0x1f)*ASC_CHR_HEIGHT+j-(16-ASC_CHR_HEIGHT)]);
				}
				else
					fnPR13(cData);
				fnPR12(LC_AUT_OVR);
				fnSetPos(uRow+j+1,uCol);
			}
			if(c1 != BS) // 非退格
			uCol++;
		}
		else
		{ // 中文
			for(j=0;j<sizeof(GB_16)/sizeof(GB_16[0]);j++)
			{
				if(c1 == GB_16[j].Index[0] && c2 == GB_16[j].Index[1])
				break;
			}
			for(k=0;k<sizeof(GB_16[0].Msk)/2;k++)
			{
				fnSetPos(uRow+k,uCol);
				fnPR12(LC_AUT_WR); // 写数据
				if(j < sizeof(GB_16)/sizeof(GB_16[0]))
				{
					fnPR13(GB_16[j].Msk[k*2]);
					fnPR13(GB_16[j].Msk[k*2+1]);
				}
				else // 未找到该字
				{
					if(k < sizeof(GB_16[0].Msk)/4)
					{
						fnPR13(0x00);
						fnPR13(0x00);
					}
					else
					{
						fnPR13(0xff);
						fnPR13(0xff);
					}
				}
				fnPR12(LC_AUT_OVR);
			}
			uCol += 2;
			i++;
		}
		if(uCol >= 30) // 光标后移
		{
			uRow += 16;
			if(uRow < 0x80)
			uCol -= 30;
			else
			{
				uRow = 0;
				uCol = 0;
			}
		}
		fnSetPos(uRow,uCol);
		i++;
	}
	return uLen;
}
void main(void) // 测试用 ,中文测试
{
	fnLCMInit();
	cls();
	cursor(0,0);
	dprintf("%s","This is a test: ");
}