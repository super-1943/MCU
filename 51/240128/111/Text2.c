/*********************************************************************************/
/* LCM MGLS-240128TA （ ）显示程序   */
/* MCU 型号 : Winbond W78E58-24 */
/* 时钟频率 : 22.1184 MHz */
/* 接口方式 :  直接接口（挂总线） */
/* 开发环境 : Keil C51 V6.14 */
/* 开发日期 : 2001.06.12- */
/* 程序编写 : Youth */
/*********************************************************************************/
#include <absacc.h>
#include <reg52.h>
#include <stdarg.h>
#include <stdio.h>
//No change 
#define ulong unsigned long
#define uchar unsigned char
#define uint unsigned int

#define STX 0x02
#define ETX 0x03
#define EOT 0x04
#define ENQ 0x05
#define BS 0x08
#define CR 0x0D
#define LF 0x0A
#define DLE 0x10
#define ETB 0x17
#define SPACE 0x20
#define COMMA 0x2C
                
#define TRUE 1
#define FALSE 0
                
#define HIGH 1
#define LOW 0
//命令定义
#define LC_CUR_POS 	0x21 // 光标位置设置
#define LC_CGR_POS 	0x22 // CGRAM偏置地址设置
#define LC_ADD_POS 	0x24 // 地址指针位置
#define LC_TXT_STP 	0x40 // 文本区首址
#define LC_TXT_WID 	0x41 // 文本区宽度
#define LC_GRH_STP 	0x42 // 图形区首址
#define LC_GRH_WID 	0x43 // 图形区宽度
#define LC_MOD_OR 	0x80 // 显示方式：逻辑“或”
#define LC_MOD_XOR0x81 // 显示方式：逻辑“异或”
#define LC_MOD_AND0x82 // 显示方式：逻辑“与”
#define LC_MOD_TCH	0x83 // 显示方式：文本特征
#define LC_DIS_SW 	0x90	//  D0=1/0: /显示开关： 光标闪烁启用 禁用；
								//  D1=1/0: /光标显示启用 禁用；
								//  D2=1/0: /文本显示启用 禁用；
								//  D3=1/0: /图形显示启用 禁用；
#define LC_CUR_SHP 	0xA0 //  0xA0-0xA7光标形状选择： 表示光标占的行数
#define LC_AUT_WR 	0xB0 // 自动写设置
#define LC_AUT_RD 	0xB1 // 自动读设置
#define LC_AUT_OVR	0xB2 //  /自动读 写结束
#define LC_INC_WR 	0xC0 //  1数据一次写，地址加
#define LC_INC_RD 	0xC1 //  1数据一次读，地址加
#define LC_DEC_WR 	0xC2 //  1数据一次写，地址减
#define LC_DEC_RD 	0xC3 //  1数据一次读，地址减
#define LC_NOC_WR 	0xC4 // 数据一次写，地址不变
#define LC_NOC_RD 	0xC5 // 数据一次读，地址不变
#define LC_SCN_RD 	0xE0 // 屏读
#define LC_SCN_CP 	0xE8 // 屏拷贝
#define LC_BIT_OP 	0xF0 //  D0-D2 D0-D7 D3 1 0位操作： ：定义 位； ： 置位； ：清除

#define STA(a) (1<<a)
#define LCMDW 	XBYTE[0x9000] // 数据口
#define LCMCW 	XBYTE[0x9100] // 命令口


// ASCII 字模宽度及高度定义
#define ASC_CHR_WIDTH  8
#define ASC_CHR_HEIGHT 12
// ASCII  8*16字模，显示为
char code ASC_MSK[96*12] = {
// Terminal9;    x =8x12此字体下对应的点阵为：宽 高
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff, // < 0x20 ,时 打印此字
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ' '
0x00,0x0C,0x1E,0x1E,0x1E,0x0C,0x0C,0x00,0x0C,0x0C,0x00,0x00,// '!'
0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '"'
0x00,0x36,0x36,0x7F,0x36,0x36,0x36,0x7F,0x36,0x36,0x00,0x00, // '#'7

0x0C,0x0C,0x3E,0x03,0x03,0x1E,0x30,0x30,0x1F,0x0C,0x0C,0x00, // '$'
0x00,0x00,0x00,0x23,0x33,0x18,0x0C,0x06,0x33,0x31,0x00,0x00, // '%'
0x00,0x0E,0x1B,0x1B,0x0E,0x5F,0x7B,0x33,0x3B,0x6E,0x00,0x00, // '&'
0x00,0x0C,0x0C,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '''
0x00,0x30,0x18,0x0C,0x06,0x06,0x06,0x0C,0x18,0x30,0x00,0x00, // '('
0x00,0x06,0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x06,0x00,0x00, // ')'
0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00, // '*'
0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00, // '+'
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x06,0x00, // ','
0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00, // '-'
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x00,0x00, // '.'
0x00,0x00,0x40,0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00,0x00, // '/'
0x00,0x3E,0x63,0x73,0x7B,0x6B,0x6F,0x67,0x63,0x3E,0x00,0x00, // '0'
0x00,0x08,0x0C,0x0F,0x0C,0x0C,0x0C,0x0C,0x0C,0x3F,0x00,0x00, // '1'
0x00,0x1E,0x33,0x33,0x30,0x18,0x0C,0x06,0x33,0x3F,0x00,0x00, // '2'
0x00,0x1E,0x33,0x30,0x30,0x1C,0x30,0x30,0x33,0x1E,0x00,0x00, // '3'
0x00,0x30,0x38,0x3C,0x36,0x33,0x7F,0x30,0x30,0x78,0x00,0x00, // '4'
0x00,0x3F,0x03,0x03,0x03,0x1F,0x30,0x30,0x33,0x1E,0x00,0x00, // '5'
0x00,0x1C,0x06,0x03,0x03,0x1F,0x33,0x33,0x33,0x1E,0x00,0x00, // '6'
0x00,0x7F,0x63,0x63,0x60,0x30,0x18,0x0C,0x0C,0x0C,0x00,0x00, // '7'
0x00,0x1E,0x33,0x33,0x37,0x1E,0x3B,0x33,0x33,0x1E,0x00,0x00, // '8'

};
typedef struct typFNT_GB16 // 汉字字模显示数据结构
{
char Index[2];
char Msk[32];
};
struct typFNT_GB16 xdata GB_16[] = { //  16*16显示为" 中 "," 文 "," 测 "," 试 "
		0x01,0x00,0x01,0x00,0x21,0x08,0x3F,0xFC,0x21,0x08,0x21,0x08,0x21,0x08,0x21,0x08,
		0x21,0x08,0x3F,0xF8,0x21,0x08,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,
		0x02,0x00,0x01,0x00,0x01,0x00,0xFF,0xFE,0x08,0x20,0x08,0x20,0x08,0x20,0x04,0x40,
		0x04,0x40,0x02,0x80,0x01,0x00,0x02,0x80,0x04,0x60,0x18,0x1E,0xE0,0x08,0x00,0x00,
		0x40,0x02,0x27,0xC2,0x24,0x42,0x84,0x52,0x45,0x52,0x55,0x52,0x15,0x52,0x25,0x52,
		0x25,0x52,0x25,0x52,0xC5,0x52,0x41,0x02,0x42,0x82,0x42,0x42,0x44,0x4A,0x48,0x04,
		0x00,0x20,0x40,0x28,0x20,0x24,0x30,0x24,0x27,0xFE,0x00,0x20,0xE0,0x20,0x27,0xE0,
		0x21,0x20,0x21,0x10,0x21,0x10,0x21,0x0A,0x29,0xCA,0x36,0x06,0x20,0x02,0x00,0x00,
};
/**********************************************************************
忙检测函数
参数说明：
mask：要查的状态位，对应位为一则进行查询，为0则不管。
调用宏：STA(a)     (1<<a)
若查询STA1,STA0,则参数为(STA(0)|STA(1))
返回值等于参数，说明状态有效
**********************************************************************/
unsigned char gCurRow,gCurCol; //  16 8当前行、列存储，行高 点，列宽 点
unsigned char GetRow(void)
{
	return gCurRow;
}
unsigned char GetCol(void)
{
	return gCurCol;
}
unsigned char CheckStatus(unsigned char mask)
{
	return (mask&LCMCW);
}


void  Write2Data(unsigned char uCmd,unsigned char uPar1,unsigned char uPar2) // 写双参数的指令
{
	while(CheckStatus(STA(0)|STA(1))!=(STA(0)|STA(1)));
	LCMDW=uPar1;
	while(CheckStatus(STA(0)|STA(1))!=(STA(0)|STA(1)));
	LCMDW = uPar2;
	while(CheckStatus(STA(0)|STA(1))!=(STA(0)|STA(1)));
	LCMCW = uCmd;
}
void Write1Data(unsigned char uCmd,unsigned char uPar1) // 写单参数的指令
{
	while(CheckStatus(STA(0)|STA(1))!=(STA(0)|STA(1)));
	LCMDW =uPar1 ;
	while(CheckStatus(STA(0)|STA(1))!=(STA(0)|STA(1)));
	LCMCW = uCmd;
}

void Write0Data(unsigned char uCmd) // 写无参数的指令
{
	while(CheckStatus(STA(0)|STA(1))!=(STA(0)|STA(1)));
	LCMCW = uCmd;
}

void WriteAllData(unsigned char uData) // 写数据
{
	while(CheckStatus(STA(3))!=(STA(3)));
	LCMDW = uData;
}
unsigned char fnPR2(void) // 读数据
{
	while(CheckStatus(STA(0)|STA(1))!=(STA(0)|STA(1)));
	return LCMDW;
}
// 设置当前地址
void SetPos(unsigned char urow, unsigned char ucol)
{
	unsigned int  iPos;
	iPos = urow * 30 + ucol;
	Write2Data(LC_ADD_POS,iPos & 0xFF,iPos / 256);
	gCurRow = urow;
	gCurCol = ucol;
}
// 设置当前显示行、列
void cursor(unsigned char uRow, unsigned char uCol)
{
	SetPos(uRow * 16, uCol);
}
// 清屏
void cls(void)
{
	unsigned int  i;
	Write2Data(LC_ADD_POS,0x00,0x00); // 置地址指针
	Write0Data(LC_AUT_WR); // 自动写
	for(i=0;i<240*30;i++)
	{
		while(CheckStatus(0x08)!=0x08);
		WriteAllData(0x00); // 写数据
	}
	Write0Data(LC_AUT_OVR); // 自动写结束
	Write2Data(LC_ADD_POS,0x00,0x00); // 重置地址指针
	gCurRow = 0; // 置地址指针存储变量
	gCurCol = 0;
}
// LCM 初始化
char fnLCMInit(void)
{
	Write2Data(LC_TXT_STP,0x00,0x00); // 文本显示区首地址
	Write2Data(LC_TXT_WID,0x1E,0x00); // 文本显示区宽度
	Write2Data(LC_GRH_STP,0x00,0x00); // 图形显示区首地址
	Write2Data(LC_GRH_WID,0x1E,0x00); // 图形显示区宽度
	Write0Data(LC_CUR_SHP | 0x01); // 光标形状
	Write0Data(LC_MOD_OR); // 显示方式设置
	Write0Data(LC_DIS_SW | 0x08); // 显示开关设置
	return 0;
}
// ASCII(8*16)    (16*16) 及 汉字 显示函数
unsigned char dprintf(char *fmt, ...)
{
	va_list arg_ptr;
	char  c1,c2,cData;
	char tmpBuf[64]; // LCD显示数据缓冲区
	unsigned char i=0,j,uLen,uRow,uCol;
	unsigned int  k;
	va_start(arg_ptr, fmt);
	uLen = (unsigned char)vsprintf(tmpBuf, fmt, arg_ptr);
	va_end(arg_ptr);
	while(i<uLen)
	{
		c1 = tmpBuf[i];
		c2 = tmpBuf[i+1];
		uRow = GetRow();
		uCol = GetCol();
		if(c1 >= 0)
		{ // ASCII
			if(c1 < 0x20)
			{
				switch(c1)
				{
					case CR:
					case LF: // 回车或换行
						i++;
					if(uRow < 112)
						SetPos(uRow+16,0);
					else
						SetPos(0,0);
					continue;
					case BS: // 退格
						if(uCol > 0)
							uCol--;
						SetPos(uRow,uCol);
						cData = 0x00;
					break;
					default: // 其他
						c1 = 0x1f;
				}
			}
			for(j=0;j<16;j++)
			{
				Write0Data(LC_AUT_WR); // 写数据
				if(c1 >= 0x1f)
				{
					if(j < (16-ASC_CHR_HEIGHT))
						WriteAllData(0x00);
					else
						WriteAllData(ASC_MSK[(c1-0x1f)*ASC_CHR_HEIGHT+j-(16-ASC_CHR_HEIGHT)]);
				}
				else
					WriteAllData(cData);
				Write0Data(LC_AUT_OVR);
				SetPos(uRow+j+1,uCol);
			}
			if(c1 != BS) // 非退格
			uCol++;
		}
		else
		{ // 中文
			for(j=0;j<sizeof(GB_16)/sizeof(GB_16[0]);j++)
			{
				if(c1 == GB_16[j].Index[0] && c2 == GB_16[j].Index[1])
				break;
			}
			for(k=0;k<sizeof(GB_16[0].Msk)/2;k++)
			{
				SetPos(uRow+k,uCol);
				Write0Data(LC_AUT_WR); // 写数据
				if(j < sizeof(GB_16)/sizeof(GB_16[0]))
				{
					WriteAllData(GB_16[j].Msk[k*2]);
					WriteAllData(GB_16[j].Msk[k*2+1]);
				}
				else // 未找到该字
				{
					if(k < sizeof(GB_16[0].Msk)/4)
					{
						WriteAllData(0x00);
						WriteAllData(0x00);
					}
					else
					{
						WriteAllData(0xff);
						WriteAllData(0xff);
					}
				}
				Write0Data(LC_AUT_OVR);
			}
			uCol += 2;
			i++;
		}
		if(uCol >= 30) // 光标后移
		{
			uRow += 16;
			if(uRow < 0x80)
			uCol -= 30;
			else
			{
				uRow = 0;
				uCol = 0;
			}
		}
		SetPos(uRow,uCol);
		i++;
	}
	return uLen;
}
void main(void) // 测试用 ,中文测试
{
	fnLCMInit();
	cls();
	cursor(0,0);
	dprintf("%s","This is a test: ");
}