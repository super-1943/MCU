	//本解码程序适用于NEC的upd6121及其兼容芯片的解码，支持大多数遥控器 实验板采用30MHZ晶振
#include<reg52.h>       //包含单片机寄存器的头文件
#include<intrins.h>  //包含_nop_()函数定义的头文件
#include<hongwai.h>
#include<1602.h>
#include<1302.h>
unsigned char keyflag=0;
unsigned char a[4];    //储存用户码、用户反码与键数据码、键数据反码
unsigned int LowTime,HighTime; //储存高、低电平的宽度 
/*****************************************************
函数功能：延时1ms
***************************************************/
void Hw_delay1ms()
{
   unsigned char i,j;	
	 for(i=0;i<25;i++)
	  for(j=0;j<33;j++)
	   ;		 
 }
 /*****************************************************
函数功能：延时若干毫秒
入口参数：n
***************************************************/
 void Hw_delay(unsigned char n)
 {
   unsigned char i;
	for(i=0;i<n;i++)
	   Hw_delay1ms();
 }



/*********************************************************/
void Hw_beep()		//蜂鸣器响一声函数
{
  unsigned char i;
  for (i=0;i<100;i++)
   {
   Hw_delay1ms();
   BEEP=!BEEP;       //BEEP取反
   } 
   BEEP=1;           //关闭蜂鸣器
   Hw_delay(250);       //延时     
}

/************************************************************
函数功能：对4个字节的用户码和键数据码进行解码
说明：解码正确，返回1，否则返回0
出口参数：dat
*************************************************************/
bit Hw_DeCode(void)        
{
    
   unsigned char  i,j;
	unsigned char temp;    //储存解码出的数据
	for(i=0;i<4;i++)      //连续读取4个用户码和键数据码
	  {
		 for(j=0;j<8;j++)  //每个码有8位数字
			 {
	         temp=temp>>1;  //temp中的各数据位右移一位，因为先读出的是高位数据									
			   TH0=0;         //定时器清0
			   TL0=0;         //定时器清0
			   TR0=1;         //开启定时器T0
		      while(IR==0)   //如果是低电平就等待
	               ;	      //低电平计时
		  	   TR0=0;         //关闭定时器T0
			   LowTime=TH0*256+TL0;    //保存低电平宽度
			   TH0=0;         //定时器清0
			   TL0=0;         //定时器清0
			   TR0=1;         //开启定时器T0
			   while(IR==1)   //如果是高电平就等待
			       ;			   
			   TR0=0;        //关闭定时器T0
			   HighTime=TH0*256+TL0;   //保存高电平宽度
			   if((LowTime<1100)||(LowTime>1700))  //对于不同的遥控不同的晶振修改此处即可
			  		    return 0;        //如果低电平长度不在合理范围，则认为出错，停止解码			
			   if((HighTime>1100)&&(HighTime<1700))   //如果高电平时间在560微秒左右，即计数560／1.085＝516次
			           temp=temp&0x7f;       //(520-100=420, 520+100=620)，则该位是0
			   if((HighTime>3700)&&(HighTime<4700)) //如果高电平时间在1680微秒左右，即计数1680／1.085＝1548次
			           temp=temp|0x80;       //(1550-250=1300,1550+250=1800),则该位是1
		     }  			            
	   a[i]=temp;	//将解码出的字节值储存在a[i]																					 
    }  				 		 
  if(a[2]=~a[3])  //验证键数据码和其反码是否相等,一般情况下不必验证用户码
	 return 1;     //解码正确，返回1
}

/*------------------二进制码转换为压缩型BCD码,并显示---------------*/

void Hw_two_2_bcd(unsigned char date)
{

   unsigned char temp;
   temp=date;
   date&=0xf0;
   date>>=4;                    //右移四位得到高四位码
   date&=0x0f;                  //与0x0f想与确保高四位为0
   if(date<=0x09)
   {                 
     Lcd_WriteData(0x30+date);            //lcd显示键值高四位
	 Hw_delay(5);
   }
   else
   {
     date=date-0x09;
	 Lcd_WriteData(0x40+date);
	 Hw_delay(5);
   }
   date=temp;
   date&=0x0f;
   if(date<=0x09)
   {
     Lcd_WriteData(0x30+date);            //lcd显示低四位值
	 Hw_delay(10);
   }
   else
   {
     date=date-0x09;
	 Lcd_WriteData(0x40+date);
	 Hw_delay(5);
   }
   Lcd_WriteData(0x48);                 //显示字符'H'
   Hw_delay(5);
} 
/************************************************************
函数功能：1602LCD显示
*************************************************************/
void Hw_Disp(void)
{  
    Lcd_WriteAddress(0x40);  // 设置显示位置为第一行的第1个字
      Hw_two_2_bcd(a[0]);
	  Lcd_WriteData(0x20);
	  Hw_delay(5);
	  Hw_two_2_bcd(a[1]);
	  Lcd_WriteData(0x20);
	  Hw_delay(10);
	  Hw_two_2_bcd(a[2]);
	  Lcd_WriteData(0x20);
	  Hw_delay(5);
	  Hw_two_2_bcd(a[3]);
}
/************************************************************
函数功能：红外初始化
************************************************************/
void Hw_Int()
{    	
	   EA=1;        //开启总中断
       EX0=1;       //开外中断0
       ET0=1;       //定时器T0中断允许
       IT0=1;       //外中断的下降沿触发  
       TMOD=0x01;   //使用定时器T0的模式1	
	   TR0=0;       //定时器T0关闭
}
/************************************************************
函数功能：红外线触发的外中断处理函数
*************************************************************/
void Int0(void) interrupt 0
  {	  
     EX0=0;      //关闭外中断0，不再接收二次红外信号的中断，只解码当前红外信号
	  TH0=0;      //定时器T0的高8位清0
	  TL0=0;      //定时器T0的低8位清0
	  TR0=1;	    //开启定时器T0	 
	  while(!IR&&(TH0&0x80)==0);          //如果是低电平就等待，给引导码低电平计时	  注：如果超时则退出，防止出不了中断，导致主函数无法执行
	  TR0=0;                //关闭定时器T0     
	  LowTime=TH0*256+TL0;  //保存低电平时间
	  TH0=0;      //定时器T0的高8位清0
	  TL0=0;      //定时器T0的低8位清0
	  TR0=1;	    //开启定时器T0
	  while(IR&&(TH0&0x40)==0);  //如果是高电平就等待，给引导码高电平计时
	  TR0=0;        //关闭定时器T0
	  HighTime=TH0*256+TL0;	//保存引导码的高电平长度
     if((LowTime>21000)&&(LowTime<24000)&&(HighTime>9750)&&(HighTime<12750))
		 {
		    //如果是引导码,就开始解码,否则放弃,引导码的低电平计时
	       //次数＝9000us/1.085=8294, 判断区间:8300－500＝7800，8300＋500＝8800.
	      if(Hw_DeCode()==1) // 执行遥控解码功能
		 {
		   if(a[2]==wl1)
		 {
		 Lcd_WriteCom(0x01);
         Lcd_delay(3); 
		 keyflag+=1;
		 if(keyflag==3)
		 keyflag=0;
		 }	
		 // Hw_Disp();//调用1602LCD显示函数
		  Hw_beep();//蜂鸣器响一声 提示解码成功
		 }
		 }
	  EX0=1;   //开启外中断EX0
  }
