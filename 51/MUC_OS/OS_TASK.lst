C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE OS_TASK
OBJECT MODULE PLACED IN .\OS_TASK.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\UCOS_II\OS_TASK.C LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\OS_TASK.lst) O
                    -BJECT(.\OS_TASK.obj)

line level    source

   1          /*
   2          *********************************************************************************************************
   3          *                                                uC/OS-II
   4          *                                          The Real-Time Kernel
   5          *                                            TASK MANAGEMENT
   6          *
   7          *                          (c) Copyright 1992-2002, Jean J. Labrosse, Weston, FL
   8          *                                           All Rights Reserved
   9          *
  10          * File : OS_TASK.C
  11          * By   : Jean J. Labrosse
  12          *********************************************************************************************************
  13          */
  14          
  15          #ifndef  OS_MASTER_FILE
  16          #include "includes.h"
*** WARNING C318 IN LINE 18 OF includes.h: can't open file '..\ucos_ii.h'
  17          #endif
  18          
  19          /*
  20          *********************************************************************************************************
  21          *                                        CHANGE PRIORITY OF A TASK
  22          *
  23          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
  24          *              priority MUST be available.
  25          *
  26          * Arguments  : oldp     is the old priority
  27          *
  28          *              newp     is the new priority
  29          *
  30          * Returns    : OS_NO_ERR        is the call was successful
  31          *              OS_PRIO_INVALID  if the priority you specify is higher that the maximum allowed
  32          *                               (i.e. >= OS_LOWEST_PRIO)
  33          *              OS_PRIO_EXIST    if the new priority already exist.
  34          *              OS_PRIO_ERR      there is no task with the specified OLD priority (i.e. the OLD task does
  35          *                               not exist.
  36          *********************************************************************************************************
  37          */
  38          
  39          #if OS_TASK_CHANGE_PRIO_EN > 0
              INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR    cpu_sr;
              #endif
              
              #if OS_EVENT_EN > 0
                  OS_EVENT    *pevent;
              #endif
              
                  OS_TCB      *ptcb;
                  INT8U        x;
                  INT8U        y;
                  INT8U        bitx;
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 2   

                  INT8U        bity;
              
              
              
              #if OS_ARG_CHK_EN > 0
                  if ((oldprio >= OS_LOWEST_PRIO && oldprio != OS_PRIO_SELF)  ||
                       newprio >= OS_LOWEST_PRIO) {
                      return (OS_PRIO_INVALID);
                  }
              #endif
                  OS_ENTER_CRITICAL();
                  if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {                 /* New priority must not already exist */
                      OS_EXIT_CRITICAL();
                      return (OS_PRIO_EXIST);
                  } else {
                      OSTCBPrioTbl[newprio] = (OS_TCB *)1;                    /* Reserve the entry to prevent others */
                      OS_EXIT_CRITICAL();
                      y    = newprio >> 3;                                    /* Precompute to reduce INT. latency   */
                      bity = OSMapTbl[y];
                      x    = newprio & 0x07;
                      bitx = OSMapTbl[x];
                      OS_ENTER_CRITICAL();
                      if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                */
                          oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                   */
                      }
                      ptcb = OSTCBPrioTbl[oldprio];
                      if (ptcb != (OS_TCB *)0) {                              /* Task to change must exist           */
                          OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                /* Remove TCB from old priority        */
                          if ((OSRdyTbl[ptcb->OSTCBY] & ptcb->OSTCBBitX) != 0x00) {  /* If task is ready make it not */
                              if ((OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0x00) {
                                  OSRdyGrp &= ~ptcb->OSTCBBitY;
                              }
                              OSRdyGrp    |= bity;                            /* Make new priority ready to run      */
                              OSRdyTbl[y] |= bitx;
              #if OS_EVENT_EN > 0
                          } else {
                              pevent = ptcb->OSTCBEventPtr;
                              if (pevent != (OS_EVENT *)0) {                  /* Remove from event wait list  */
                                  if ((pevent->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
                                      pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
                                  }
                                  pevent->OSEventGrp    |= bity;              /* Add new priority to wait list       */
                                  pevent->OSEventTbl[y] |= bitx;
                              }
              #endif
                          }
                          OSTCBPrioTbl[newprio] = ptcb;                       /* Place pointer to TCB @ new priority */
                          ptcb->OSTCBPrio       = newprio;                    /* Set new task priority               */
                          ptcb->OSTCBY          = y;
                          ptcb->OSTCBX          = x;
                          ptcb->OSTCBBitY       = bity;
                          ptcb->OSTCBBitX       = bitx;
                          OS_EXIT_CRITICAL();
                          OS_Sched();                                         /* Run highest priority task ready     */
                          return (OS_NO_ERR);
                      } else {
                          OSTCBPrioTbl[newprio] = (OS_TCB *)0;                /* Release the reserved prio.          */
                          OS_EXIT_CRITICAL();
                          return (OS_PRIO_ERR);                               /* Task to change didn't exist         */
                      }
                  }
              }
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 3   

              #endif
 117          /*$PAGE*/
 118          /*
 119          *********************************************************************************************************
 120          *                                            CREATE A TASK
 121          *
 122          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
 123          *              be created prior to the start of multitasking or by a running task.  A task cannot be
 124          *              created by an ISR.
 125          *
 126          * Arguments  : task     is a pointer to the task's code
 127          *
 128          *              pdata    is a pointer to an optional data area which can be used to pass parameters to
 129          *                       the task when the task first executes.  Where the task is concerned it thinks
 130          *                       it was invoked and passed the argument 'pdata' as follows:
 131          *
 132          *                           void Task (void *pdata)
 133          *                           {
 134          *                               for (;;) {
 135          *                                   Task code;
 136          *                               }
 137          *                           }
 138          *
 139          *              ptos     is a pointer to the task's top of stack.  If the configuration constant
 140          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
 141          *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
 142          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
 143          *                       lowest memory location of the stack and the stack will grow with increasing
 144          *                       memory locations.
 145          *
 146          *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
 147          *                       lower the number, the higher the priority.
 148          *
 149          * Returns    : OS_NO_ERR        if the function was successful.
 150          *              OS_PRIO_EXIT     if the task priority already exist
 151          *                               (each task MUST have a unique priority).
 152          *              OS_PRIO_INVALID  if the priority you specify is higher that the maximum allowed
 153          *                               (i.e. >= OS_LOWEST_PRIO)
 154          *********************************************************************************************************
 155          */
 156          
 157          #if OS_TASK_CREATE_EN > 0
 158          INT8U  OSTaskCreate (void (*task)(void *pd), void *pdata, OS_STK *ptos, INT8U prio)
*** ERROR C141 IN LINE 158 OF ..\UCOS_II\OS_TASK.C: syntax error near ','
 159          {
 160   1      #if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
                  OS_CPU_SR  cpu_sr;
              #endif
 163   1          OS_STK    *psp;
 164   1          INT8U      err;
 165   1      
 166   1      
 167   1      #if OS_ARG_CHK_EN > 0
                  if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                      return (OS_PRIO_INVALID);
                  }
              #endif
 172   1          OS_ENTER_CRITICAL();
 173   1          if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
*** ERROR C202 IN LINE 173 OF ..\UCOS_II\OS_TASK.C: 'OSTCBPrioTbl': undefined identifier
*** ERROR C141 IN LINE 173 OF ..\UCOS_II\OS_TASK.C: syntax error near ')'
*** ERROR C141 IN LINE 173 OF ..\UCOS_II\OS_TASK.C: syntax error near ')'
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 4   

 174   2              OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
*** ERROR C202 IN LINE 174 OF ..\UCOS_II\OS_TASK.C: 'OSTCBPrioTbl': undefined identifier
*** ERROR C141 IN LINE 174 OF ..\UCOS_II\OS_TASK.C: syntax error near ')'
 175   2                                                   /* ... the same thing until task is created.              */
 176   2              OS_EXIT_CRITICAL();
 177   2              psp = (OS_STK *)OSTaskStkInit(task, pdata, ptos, 0);    /* Initialize the task's stack         */
 178   2              err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 179   2              if (err == OS_NO_ERR) {
 180   3                  OS_ENTER_CRITICAL();
 181   3                  OSTaskCtr++;                                        /* Increment the #tasks counter        */
 182   3                  OS_EXIT_CRITICAL();
 183   3                  if (OSRunning == TRUE) {         /* Find highest priority task if multitasking has started */
 184   4                      OS_Sched();
 185   4                  }
 186   3              } else {
 187   3                  OS_ENTER_CRITICAL();
 188   3                  OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 189   3                  OS_EXIT_CRITICAL();
 190   3              }
 191   2              return (err);
 192   2          }
 193   1          OS_EXIT_CRITICAL();
 194   1          return (OS_PRIO_EXIST);
 195   1      }
 196          #endif
 197          /*$PAGE*/
 198          /*
 199          *********************************************************************************************************
 200          *                                     CREATE A TASK (Extended Version)
 201          *
 202          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
 203          *              be created prior to the start of multitasking or by a running task.  A task cannot be
 204          *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
 205          *              additional information about a task to be specified.
 206          *
 207          * Arguments  : task     is a pointer to the task's code
 208          *
 209          *              pdata    is a pointer to an optional data area which can be used to pass parameters to
 210          *                       the task when the task first executes.  Where the task is concerned it thinks
 211          *                       it was invoked and passed the argument 'pdata' as follows:
 212          *
 213          *                           void Task (void *pdata)
 214          *                           {
 215          *                               for (;;) {
 216          *                                   Task code;
 217          *                               }
 218          *                           }
 219          *
 220          *              ptos     is a pointer to the task's top of stack.  If the configuration constant
 221          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
 222          *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
 223          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
 224          *                       lowest memory location of the stack and the stack will grow with increasing
 225          *                       memory locations.  'pstk' MUST point to a valid 'free' data item.
 226          *
 227          *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
 228          *                       lower the number, the higher the priority.
 229          *
 230          *              id       is the task's ID (0..65535)
 231          *
 232          *              pbos     is a pointer to the task's bottom of stack.  If the configuration constant
 233          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 5   

 234          *                       memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
 235          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
 236          *                       HIGHEST memory location of the stack and the stack will grow with increasing
 237          *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
 238          *
 239          *              stk_size is the size of the stack in number of elements.  If OS_STK is set to INT8U,
 240          *                       'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
 241          *                       INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
 242          *                       OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
 243          *                       available on the stack.
 244          *
 245          *              pext     is a pointer to a user supplied memory location which is used as a TCB extension.
 246          *                       For example, this user memory can hold the contents of floating-point registers
 247          *                       during a context switch, the time each task takes to execute, the number of times
 248          *                       the task has been switched-in, etc.
 249          *
 250          *              opt      contains additional information (or options) about the behavior of the task.  The
 251          *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
 252          *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
 253          *
 254          * Returns    : OS_NO_ERR        if the function was successful.
 255          *              OS_PRIO_EXIT     if the task priority already exist
 256          *                               (each task MUST have a unique priority).
 257          *              OS_PRIO_INVALID  if the priority you specify is higher that the maximum allowed
 258          *                               (i.e. > OS_LOWEST_PRIO)
 259          *********************************************************************************************************
 260          */
 261          /*$PAGE*/
 262          #if OS_TASK_CREATE_EXT_EN > 0
              INT8U  OSTaskCreateExt (void   (*task)(void *pd),
                                      void    *pdata,
                                      OS_STK  *ptos,
                                      INT8U    prio,
                                      INT16U   id,
                                      OS_STK  *pbos,
                                      INT32U   stk_size,
                                      void    *pext,
                                      INT16U   opt)
              {
              #if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
                  OS_CPU_SR  cpu_sr;
              #endif
                  OS_STK    *psp;
                  INT8U      err;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                      return (OS_PRIO_INVALID);
                  }
              #endif
                  OS_ENTER_CRITICAL();
                  if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
                      OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
                                                           /* ... the same thing until task is created.              */
                      OS_EXIT_CRITICAL();
              
                      if (((opt & OS_TASK_OPT_STK_CHK) != 0x0000) ||   /* See if stack checking has been enabled     */
                          ((opt & OS_TASK_OPT_STK_CLR) != 0x0000)) {   /* See if stack needs to be cleared           */
                          #if OS_STK_GROWTH == 1
                          (void)memset(pbos, 0, stk_size * sizeof(OS_STK));
                          #else
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 6   

                          (void)memset(ptos, 0, stk_size * sizeof(OS_STK));
                          #endif
                      }
              
                      psp = (OS_STK *)OSTaskStkInit(task, pdata, ptos, opt); /* Initialize the task's stack          */
                      err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
                      if (err == OS_NO_ERR) {
                          OS_ENTER_CRITICAL();
                          OSTaskCtr++;                                       /* Increment the #tasks counter         */
                          OS_EXIT_CRITICAL();
                          if (OSRunning == TRUE) {                           /* Find HPT if multitasking has started */
                              OS_Sched();
                          }
                      } else {
                          OS_ENTER_CRITICAL();
                          OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
                          OS_EXIT_CRITICAL();
                      }
                      return (err);
                  }
                  OS_EXIT_CRITICAL();
                  return (OS_PRIO_EXIST);
              }
              #endif
 320          /*$PAGE*/
 321          /*
 322          *********************************************************************************************************
 323          *                                            DELETE A TASK
 324          *
 325          * Description: This function allows you to delete a task.  The calling task can delete itself by
 326          *              its own priority number.  The deleted task is returned to the dormant state and can be
 327          *              re-activated by creating the deleted task again.
 328          *
 329          * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitely delete
 330          *                      the current task without knowing its priority level by setting 'prio' to
 331          *                      OS_PRIO_SELF.
 332          *
 333          * Returns    : OS_NO_ERR           if the call is successful
 334          *              OS_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
 335          *              OS_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
 336          *                                  (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 337          *              OS_TASK_DEL_ERR     if the task you want to delete does not exist
 338          *              OS_TASK_DEL_ISR     if you tried to delete a task from an ISR
 339          *
 340          * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
 341          *                    a) by making it not ready
 342          *                    b) by removing it from any wait lists
 343          *                    c) by preventing OSTimeTick() from making the task ready to run.
 344          *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
 345          *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
 346          *                 the next instruction following the enable interrupt instruction is ignored.  
 347          *              3) An ISR cannot delete a task.
 348          *              4) The lock nesting counter is incremented because, for a brief instant, if the current
 349          *                 task is being deleted, the current task would not be able to be rescheduled because it
 350          *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
 351          *                 from being schedule.  This means that an ISR would return to the current task which is
 352          *                 being deleted.  The rest of the deletion would thus be able to be completed.
 353          *********************************************************************************************************
 354          */
 355          /*$PAGE*/
 356          #if OS_TASK_DEL_EN > 0
              INT8U  OSTaskDel (INT8U prio)
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 7   

              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR     cpu_sr;
              #endif
              
              #if OS_EVENT_EN > 0
                  OS_EVENT     *pevent;
              #endif    
              #if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
                  OS_FLAG_NODE *pnode;
              #endif
                  OS_TCB       *ptcb;
                  BOOLEAN       self;
              
              
              
                  if (OSIntNesting > 0) {                                     /* See if trying to delete from ISR    */
                      return (OS_TASK_DEL_ISR);
                  }
              #if OS_ARG_CHK_EN > 0
                  if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to delete idle task     */
                      return (OS_TASK_DEL_IDLE);
                  }
                  if (prio >= OS_LOWEST_PRIO && prio != OS_PRIO_SELF) {       /* Task priority valid ?               */
                      return (OS_PRIO_INVALID);
                  }
              #endif
                  OS_ENTER_CRITICAL();
                  if (prio == OS_PRIO_SELF) {                                 /* See if requesting to delete self    */
                      prio = OSTCBCur->OSTCBPrio;                             /* Set priority to delete to current   */
                  }
                  ptcb = OSTCBPrioTbl[prio];
                  if (ptcb != (OS_TCB *)0) {                                       /* Task to delete must exist      */
                      if ((OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0x00) {  /* Make task not ready            */
                          OSRdyGrp &= ~ptcb->OSTCBBitY;
                      }
              #if OS_EVENT_EN > 0
                      pevent = ptcb->OSTCBEventPtr;
                      if (pevent != (OS_EVENT *)0) {                          /* If task is waiting on event         */
                          if ((pevent->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) { /* ... remove task from */
                              pevent->OSEventGrp &= ~ptcb->OSTCBBitY;                        /* ... event ctrl block */
                          }
                      }
              #endif
              #if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
                      pnode = ptcb->OSTCBFlagNode;
                      if (pnode != (OS_FLAG_NODE *)0) {                       /* If task is waiting on event flag    */
                          OS_FlagUnlink(pnode);                               /* Remove from wait list               */
                      }
              #endif
                      ptcb->OSTCBDly  = 0;                                    /* Prevent OSTimeTick() from updating  */
                      ptcb->OSTCBStat = OS_STAT_RDY;                          /* Prevent task from being resumed     */
                              if (OSLockNesting < 255) {
                          OSLockNesting++;
                              }
                      OS_EXIT_CRITICAL();                                     /* Enabling INT. ignores next instruc. */
                      OS_Dummy();                                             /* ... Dummy ensures that INTs will be */
                      OS_ENTER_CRITICAL();                                    /* ... disabled HERE!                  */
                              if (OSLockNesting > 0) {
                          OSLockNesting--;
                              }
                      OSTaskDelHook(ptcb);                                    /* Call user defined hook              */
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 8   

                      OSTaskCtr--;                                            /* One less task being managed         */
                      OSTCBPrioTbl[prio] = (OS_TCB *)0;                       /* Clear old priority entry            */
                      if (ptcb->OSTCBPrev == (OS_TCB *)0) {                   /* Remove from TCB chain               */
                          ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
                          OSTCBList                  = ptcb->OSTCBNext;
                      } else {
                          ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
                          ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
                      }
                      ptcb->OSTCBNext = OSTCBFreeList;                        /* Return TCB to free TCB list         */
                      OSTCBFreeList   = ptcb;
                      OS_EXIT_CRITICAL();
                      OS_Sched();                                             /* Find new highest priority task      */
                      return (OS_NO_ERR);
                  }
                  OS_EXIT_CRITICAL();
                  return (OS_TASK_DEL_ERR);
              }
              #endif
 439          /*$PAGE*/
 440          /*
 441          *********************************************************************************************************
 442          *                                    REQUEST THAT A TASK DELETE ITSELF
 443          *
 444          * Description: This function is used to:
 445          *                   a) notify a task to delete itself.
 446          *                   b) to see if a task requested that the current task delete itself.
 447          *              This function is a little tricky to understand.  Basically, you have a task that needs
 448          *              to be deleted however, this task has resources that it has allocated (memory buffers,
 449          *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
 450          *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
 451          *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
 452          *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
 453          *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
 454          *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
 455          *              value is OS_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
 456          *              this:
 457          *
 458          *                   void Task(void *data)
 459          *                   {
 460          *                       .
 461          *                       .
 462          *                       while (1) {
 463          *                           OSTimeDly(1);
 464          *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_TASK_DEL_REQ) {
 465          *                               Release any owned resources;
 466          *                               De-allocate any dynamic memory;
 467          *                               OSTaskDel(OS_PRIO_SELF);
 468          *                           }
 469          *                       }
 470          *                   }
 471          *
 472          * Arguments  : prio    is the priority of the task to request the delete from
 473          *
 474          * Returns    : OS_NO_ERR          if the task exist and the request has been registered
 475          *              OS_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
 476          *                                 the request has been executed.
 477          *              OS_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
 478          *              OS_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
 479          *                                 (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 480          *              OS_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
 481          *                                 deleted.
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 9   

 482          *********************************************************************************************************
 483          */
 484          /*$PAGE*/
 485          #if OS_TASK_DEL_EN > 0
              INT8U  OSTaskDelReq (INT8U prio)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif
                  BOOLEAN    stat;
                  INT8U      err;
                  OS_TCB    *ptcb;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to delete idle task     */
                      return (OS_TASK_DEL_IDLE);
                  }
                  if (prio >= OS_LOWEST_PRIO && prio != OS_PRIO_SELF) {       /* Task priority valid ?               */
                      return (OS_PRIO_INVALID);
                  }
              #endif
                  if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
                      OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
                      stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
                      OS_EXIT_CRITICAL();
                      return (stat);
                  }
                  OS_ENTER_CRITICAL();
                  ptcb = OSTCBPrioTbl[prio];
                  if (ptcb != (OS_TCB *)0) {                                  /* Task to delete must exist           */
                      ptcb->OSTCBDelReq = OS_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
                      err               = OS_NO_ERR;
                  } else {
                      err               = OS_TASK_NOT_EXIST;                  /* Task must be deleted                */
                  }
                  OS_EXIT_CRITICAL();
                  return (err);
              }
              #endif
 522          /*$PAGE*/
 523          /*
 524          *********************************************************************************************************
 525          *                                        RESUME A SUSPENDED TASK
 526          *
 527          * Description: This function is called to resume a previously suspended task.  This is the only call that
 528          *              will remove an explicit task suspension.
 529          *
 530          * Arguments  : prio     is the priority of the task to resume.
 531          *
 532          * Returns    : OS_NO_ERR                if the requested task is resumed
 533          *              OS_PRIO_INVALID          if the priority you specify is higher that the maximum allowed
 534          *                                       (i.e. >= OS_LOWEST_PRIO)
 535          *              OS_TASK_RESUME_PRIO      if the task to resume does not exist
 536          *              OS_TASK_NOT_SUSPENDED    if the task to resume has not been suspended
 537          *********************************************************************************************************
 538          */
 539          
 540          #if OS_TASK_SUSPEND_EN > 0
              INT8U  OSTaskResume (INT8U prio)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 10  

                  OS_CPU_SR  cpu_sr;
              #endif
                  OS_TCB    *ptcb;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (prio >= OS_LOWEST_PRIO) {                               /* Make sure task priority is valid    */
                      return (OS_PRIO_INVALID);
                  }
              #endif
                  OS_ENTER_CRITICAL();
                  ptcb = OSTCBPrioTbl[prio];
                  if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
                      OS_EXIT_CRITICAL();
                      return (OS_TASK_RESUME_PRIO);
                  }
                  if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) {              /* Task must be suspended   */
                      if (((ptcb->OSTCBStat &= ~OS_STAT_SUSPEND) == OS_STAT_RDY) &&      /* Remove suspension        */
                           (ptcb->OSTCBDly  == 0)) {                                     /* Must not be delayed      */
                          OSRdyGrp               |= ptcb->OSTCBBitY;                     /* Make task ready to run   */
                          OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
                          OS_EXIT_CRITICAL();
                          OS_Sched();
                      } else {
                          OS_EXIT_CRITICAL();
                      }
                      return (OS_NO_ERR);
                  }
                  OS_EXIT_CRITICAL();
                  return (OS_TASK_NOT_SUSPENDED);
              }
              #endif
 576          /*$PAGE*/
 577          /*
 578          *********************************************************************************************************
 579          *                                             STACK CHECKING
 580          *
 581          * Description: This function is called to check the amount of free memory left on the specified task's
 582          *              stack.
 583          *
 584          * Arguments  : prio     is the task priority
 585          *
 586          *              pdata    is a pointer to a data structure of type OS_STK_DATA.
 587          *
 588          * Returns    : OS_NO_ERR           upon success
 589          *              OS_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
 590          *                                  (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 591          *              OS_TASK_NOT_EXIST   if the desired task has not been created
 592          *              OS_TASK_OPT_ERR     if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
 593          *********************************************************************************************************
 594          */
 595          #if OS_TASK_CREATE_EXT_EN > 0
              INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *pdata)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif
                  OS_TCB    *ptcb;
                  OS_STK    *pchk;
                  INT32U     free;
                  INT32U     size;
              
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 11  

              
              #if OS_ARG_CHK_EN > 0
                  if (prio > OS_LOWEST_PRIO && prio != OS_PRIO_SELF) {        /* Make sure task priority is valid    */
                      return (OS_PRIO_INVALID);
                  }
              #endif
                  pdata->OSFree = 0;                                          /* Assume failure, set to 0 size       */
                  pdata->OSUsed = 0;
                  OS_ENTER_CRITICAL();
                  if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
                      prio = OSTCBCur->OSTCBPrio;
                  }
                  ptcb = OSTCBPrioTbl[prio];
                  if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
                      OS_EXIT_CRITICAL();
                      return (OS_TASK_NOT_EXIST);
                  }
                  if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
                      OS_EXIT_CRITICAL();
                      return (OS_TASK_OPT_ERR);
                  }
                  free = 0;
                  size = ptcb->OSTCBStkSize;
                  pchk = ptcb->OSTCBStkBottom;
                  OS_EXIT_CRITICAL();
              #if OS_STK_GROWTH == 1
                  while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
                      free++;
                  }
              #else
                  while (*pchk-- == (OS_STK)0) {
                      free++;
                  }
              #endif
                  pdata->OSFree = free * sizeof(OS_STK);            /* Compute number of free bytes on the stack     */
                  pdata->OSUsed = (size - free) * sizeof(OS_STK);   /* Compute number of bytes used on the stack     */
                  return (OS_NO_ERR);
              }
              #endif
 645          /*$PAGE*/
 646          /*
 647          *********************************************************************************************************
 648          *                                            SUSPEND A TASK
 649          *
 650          * Description: This function is called to suspend a task.  The task can be the calling task if the
 651          *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
 652          *
 653          * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
 654          *                       calling task will suspend itself and rescheduling will occur.
 655          *
 656          * Returns    : OS_NO_ERR                if the requested task is suspended
 657          *              OS_TASK_SUSPEND_IDLE     if you attempted to suspend the idle task which is not allowed.
 658          *              OS_PRIO_INVALID          if the priority you specify is higher that the maximum allowed
 659          *                                       (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 660          *              OS_TASK_SUSPEND_PRIO     if the task to suspend does not exist
 661          *
 662          * Note       : You should use this function with great care.  If you suspend a task that is waiting for
 663          *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
 664          *              running when the event arrives.
 665          *********************************************************************************************************
 666          */
 667          
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 12  

 668          #if OS_TASK_SUSPEND_EN > 0
              INT8U  OSTaskSuspend (INT8U prio)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif
                  BOOLEAN    self;
                  OS_TCB    *ptcb;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to suspend idle task    */
                      return (OS_TASK_SUSPEND_IDLE);
                  }
                  if (prio >= OS_LOWEST_PRIO && prio != OS_PRIO_SELF) {       /* Task priority valid ?               */
                      return (OS_PRIO_INVALID);
                  }
              #endif
                  OS_ENTER_CRITICAL();
                  if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
                      prio = OSTCBCur->OSTCBPrio;
                      self = TRUE;
                  } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
                      self = TRUE;
                  } else {
                      self = FALSE;                                           /* No suspending another task          */
                  }
                  ptcb = OSTCBPrioTbl[prio];
                  if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
                      OS_EXIT_CRITICAL();
                      return (OS_TASK_SUSPEND_PRIO);
                  }
                  if ((OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0x00) { /* Make task not ready                 */
                      OSRdyGrp &= ~ptcb->OSTCBBitY;
                  }
                  ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
                  OS_EXIT_CRITICAL();
                  if (self == TRUE) {                                         /* Context switch only if SELF         */
                      OS_Sched();
                  }
                  return (OS_NO_ERR);
              }
              #endif
 711          /*$PAGE*/
 712          /*
 713          *********************************************************************************************************
 714          *                                            QUERY A TASK
 715          *
 716          * Description: This function is called to obtain a copy of the desired task's TCB.
 717          *
 718          * Arguments  : prio     is the priority of the task to obtain information from.
 719          *
 720          * Returns    : OS_NO_ERR       if the requested task is suspended
 721          *              OS_PRIO_INVALID if the priority you specify is higher that the maximum allowed
 722          *                              (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 723          *              OS_PRIO_ERR     if the desired task has not been created
 724          *********************************************************************************************************
 725          */
 726          
 727          #if OS_TASK_QUERY_EN > 0
              INT8U  OSTaskQuery (INT8U prio, OS_TCB *pdata)
              {
C51 COMPILER V8.02   OS_TASK                                                               07/25/2010 11:06:16 PAGE 13  

              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif
                  OS_TCB    *ptcb;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (prio > OS_LOWEST_PRIO && prio != OS_PRIO_SELF) {   /* Task priority valid ?                    */
                      return (OS_PRIO_INVALID);
                  }
              #endif
                  OS_ENTER_CRITICAL();
                  if (prio == OS_PRIO_SELF) {                            /* See if suspend SELF                      */
                      prio = OSTCBCur->OSTCBPrio;
                  }
                  ptcb = OSTCBPrioTbl[prio];
                  if (ptcb == (OS_TCB *)0) {                             /* Task to query must exist                 */
                      OS_EXIT_CRITICAL();
                      return (OS_PRIO_ERR);
                  }
                  memcpy(pdata, ptcb, sizeof(OS_TCB));                   /* Copy TCB into user storage area          */
                  OS_EXIT_CRITICAL();
                  return (OS_NO_ERR);
              }
              #endif

C51 COMPILATION COMPLETE.  1 WARNING(S),  6 ERROR(S)
