C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE OS_TASK
OBJECT MODULE PLACED IN OS_TASK.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE OS_TASK.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          *********************************************************************************************************
   3          *                                                uC/OS-II
   4          *                                          The Real-Time Kernel
   5          *                                            TASK MANAGEMENT
   6          *
   7          *                        (c) Copyright 1992-1998, Jean J. Labrosse, Plantation, FL
   8          *                                           All Rights Reserved
   9          *
  10          *                                                  V2.00
  11          *
  12          * File : OS_TASK.C
  13          * By   : Jean J. Labrosse
  14          *********************************************************************************************************
  15          */
  16          
  17          #ifndef  OS_MASTER_FILE
  18          #include "includes.h"
  19          #endif
  20          
  21          /*
  22          *********************************************************************************************************
  23          *                                        LOCAL FUNCTION PROTOTYPES
  24          *********************************************************************************************************
  25          */
  26          
  27          #if OS_TASK_DEL_EN
              static  void  OSDummy(void);
              
              /*
              *********************************************************************************************************
              *                                            DUMMY FUNCTION
              *
              * Description: This function doesn't do anything.  It is called by OSTaskDel() to ensure that interrupts
              *              are disabled immediately after they are enabled.
              *
              * Arguments  : none
              *
              * Returns    : none
              *********************************************************************************************************
              */
              
              static void  OSDummy (void)reentrant
              {
              }
              #endif
  47          /*$PAGE*/
  48          /*
  49          *********************************************************************************************************
  50          *                                        CHANGE PRIORITY OF A TASK
  51          *
  52          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
  53          *              priority MUST be available.
  54          *
  55          * Arguments  : oldp     is the old priority
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 2   

  56          *
  57          *              newp     is the new priority
  58          *
  59          * Returns    : OS_NO_ERR        is the call was successful
  60          *              OS_PRIO_INVALID  if the priority you specify is higher that the maximum allowed 
  61          *                               (i.e. >= OS_LOWEST_PRIO)
  62          *              OS_PRIO_EXIST    if the new priority already exist.
  63          *              OS_PRIO_ERR      there is no task with the specified OLD priority (i.e. the OLD task does
  64          *                               not exist.
  65          *********************************************************************************************************
  66          */
  67          
  68          #if OS_TASK_CHANGE_PRIO_EN
              INT8U OSTaskChangePrio (INT8U oldprio, INT8U newprio)reentrant
              {
                  OS_TCB   *ptcb;
                  OS_EVENT *pevent;
                  INT8U     x;
                  INT8U     y;
                  INT8U     bitx;
                  INT8U     bity;
              
              
                  if ((oldprio >= OS_LOWEST_PRIO && oldprio != OS_PRIO_SELF)  || 
                       newprio >= OS_LOWEST_PRIO) {
                      return (OS_PRIO_INVALID);
                  }
                  OS_ENTER_CRITICAL();
                  if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {                 /* New priority must not already exist */
                      OS_EXIT_CRITICAL();
                      return (OS_PRIO_EXIST);
                  } else {
                      OSTCBPrioTbl[newprio] = (OS_TCB *)1;                    /* Reserve the entry to prevent others */
                      OS_EXIT_CRITICAL();
                      y    = newprio >> 3;                                    /* Precompute to reduce INT. latency   */
                      bity = OSMapTbl[y];
                      x    = newprio & 0x07;
                      bitx = OSMapTbl[x];
                      OS_ENTER_CRITICAL();
                      if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                */
                          oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                   */
                      }
                      if ((ptcb = OSTCBPrioTbl[oldprio]) != (OS_TCB *)0) {    /* Task to change must exist           */
                          OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                /* Remove TCB from old priority        */
                          if (OSRdyTbl[ptcb->OSTCBY] & ptcb->OSTCBBitX) {     /* If task is ready make it not ready  */
                              if ((OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
                                  OSRdyGrp &= ~ptcb->OSTCBBitY;
                              }
                              OSRdyGrp    |= bity;                            /* Make new priority ready to run      */
                              OSRdyTbl[y] |= bitx;
                          } else {
                              if ((pevent = ptcb->OSTCBEventPtr) != (OS_EVENT *)0) { /* Remove from event wait list  */
                                  if ((pevent->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
                                      pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
                                  }
                                  pevent->OSEventGrp    |= bity;              /* Add new priority to wait list       */
                                  pevent->OSEventTbl[y] |= bitx;
                              }
                          }
                          OSTCBPrioTbl[newprio] = ptcb;                       /* Place pointer to TCB @ new priority */
                          ptcb->OSTCBPrio       = newprio;                    /* Set new task priority               */
                          ptcb->OSTCBY          = y;
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 3   

                          ptcb->OSTCBX          = x;
                          ptcb->OSTCBBitY       = bity;
                          ptcb->OSTCBBitX       = bitx;
                          OS_EXIT_CRITICAL();
                          OSSched();                                          /* Run highest priority task ready     */
                          return (OS_NO_ERR);
                      } else {
                          OSTCBPrioTbl[newprio] = (OS_TCB *)0;                /* Release the reserved prio.          */
                          OS_EXIT_CRITICAL();
                          return (OS_PRIO_ERR);                               /* Task to change didn't exist         */
                      }
                  }
              }
              #endif
 132          /*$PAGE*/
 133          /*
 134          *********************************************************************************************************
 135          *                                            CREATE A TASK
 136          *
 137          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
 138          *              be created prior to the start of multitasking or by a running task.  A task cannot be
 139          *              created by an ISR.
 140          *
 141          * Arguments  : task     is a pointer to the task's code
 142          *
 143          *              dataptr    is a pointer to an optional data area which can be used to pass parameters to
 144          *                       the task when the task first executes.  Where the task is concerned it thinks
 145          *                       it was invoked and passed the argument 'dataptr' as follows:
 146          *
 147          *                           void Task (void *dataptr)
 148          *                           {
 149          *                               for (;;) {
 150          *                                   Task code;
 151          *                               }
 152          *                           }
 153          *
 154          *              ptos     is a pointer to the task's top of stack.  If the configuration constant 
 155          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
 156          *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory 
 157          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the 
 158          *                       lowest memory location of the stack and the stack will grow with increasing
 159          *                       memory locations.
 160          *
 161          *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
 162          *                       lower the number, the higher the priority.
 163          *
 164          * Returns    : OS_NO_ERR        if the function was successful.
 165          *              OS_PRIO_EXIT     if the task priority already exist 
 166          *                               (each task MUST have a unique priority).
 167          *              OS_PRIO_INVALID  if the priority you specify is higher that the maximum allowed 
 168          *                               (i.e. >= OS_LOWEST_PRIO)
 169          *********************************************************************************************************
 170          */
 171          
 172          #if OS_TASK_CREATE_EN
 173          INT8U OSTaskCreate (void (*task)(void *pd)reentrant, 
 174                              void *dataptr, 
 175                              OS_STK *ptos, 
 176                              INT8U prio)reentrant
 177          {
 178   1          void   *psp;
 179   1          INT8U   err;
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 4   

 180   1      
 181   1      
 182   1          if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 183   2              return (OS_PRIO_INVALID);
 184   2          }
 185   1          OS_ENTER_CRITICAL();
 186   1          if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 187   2              OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
 188   2                                                   /* ... the same thing until task is created.              */
 189   2              OS_EXIT_CRITICAL();
 190   2              psp = (void *)OSTaskStkInit(task, dataptr, ptos, 0); /* Initialize the task's stack              *
             -/
 191   2              err = OSTCBInit(prio, psp, (void *)0, 0, 0, (void *)0, 0);         
 192   2              if (err == OS_NO_ERR) {
 193   3                  OS_ENTER_CRITICAL();
 194   3                  OSTaskCtr++;                                   /* Increment the #tasks counter             */
 195   3                  OSTaskCreateHook(OSTCBPrioTbl[prio]);          /* Call user defined hook                   */
 196   3                  OS_EXIT_CRITICAL();
 197   3                  if (OSRunning) {                 /* Find highest priority task if multitasking has started */
 198   4                      OSSched();
 199   4                  }
 200   3              } else {
 201   3                  OS_ENTER_CRITICAL();
 202   3                  OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 203   3                  OS_EXIT_CRITICAL();
 204   3              }
 205   2              return (err);
 206   2          } else {
 207   2              OS_EXIT_CRITICAL();
 208   2              return (OS_PRIO_EXIST);
 209   2          }
 210   1      }
 211          #endif
 212          /*$PAGE*/
 213          /*
 214          *********************************************************************************************************
 215          *                                     CREATE A TASK (Extended Version)
 216          *
 217          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
 218          *              be created prior to the start of multitasking or by a running task.  A task cannot be
 219          *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
 220          *              additional information about a task to be specified.
 221          *
 222          * Arguments  : task     is a pointer to the task's code
 223          *
 224          *              dataptr    is a pointer to an optional data area which can be used to pass parameters to
 225          *                       the task when the task first executes.  Where the task is concerned it thinks
 226          *                       it was invoked and passed the argument 'dataptr' as follows:
 227          *
 228          *                           void Task (void *dataptr)
 229          *                           {
 230          *                               for (;;) {
 231          *                                   Task code;
 232          *                               }
 233          *                           }
 234          *
 235          *              ptos     is a pointer to the task's top of stack.  If the configuration constant 
 236          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
 237          *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory 
 238          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the 
 239          *                       lowest memory location of the stack and the stack will grow with increasing
 240          *                       memory locations.  'pstk' MUST point to a valid 'free' data item.
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 5   

 241          *
 242          *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
 243          *                       lower the number, the higher the priority.
 244          *
 245          *              id       is the task's ID (0..65535)
 246          *
 247          *              pbos     is a pointer to the task's bottom of stack.  If the configuration constant 
 248          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
 249          *                       memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory 
 250          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the 
 251          *                       HIGHEST memory location of the stack and the stack will grow with increasing
 252          *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
 253          *
 254          *              stk_size is the size of the stack in number of elements.  If OS_STK is set to INT8U,
 255          *                       'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
 256          *                       INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
 257          *                       OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
 258          *                       available on the stack.
 259          *
 260          *              pext     is a pointer to a user supplied memory location which is used as a TCB extension.
 261          *                       For example, this user memory can hold the contents of floating-point registers
 262          *                       during a context switch, the time each task takes to execute, the number of times
 263          *                       the task has been switched-in, etc. 
 264          *
 265          *              opt      contains additional information (or options) about the behavior of the task.  The 
 266          *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application 
 267          *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
 268          *
 269          * Returns    : OS_NO_ERR        if the function was successful.
 270          *              OS_PRIO_EXIT     if the task priority already exist 
 271          *                               (each task MUST have a unique priority).
 272          *              OS_PRIO_INVALID  if the priority you specify is higher that the maximum allowed 
 273          *                               (i.e. > OS_LOWEST_PRIO)
 274          *********************************************************************************************************
 275          */
 276          /*$PAGE*/
 277          #if   OS_TASK_CREATE_EXT_EN    
              INT8U OSTaskCreateExt (void   (*task)(void *pd), 
                                     void    *dataptr, 
                                     OS_STK  *ptos, 
                                     INT8U    prio,
                                     INT16U   id,
                                     OS_STK  *pbos,
                                     INT32U   stk_size,
                                     void    *pext,
                                     INT16U   opt)reentrant
              {
                  void    *psp;
                  INT8U    err;
                  INT16U   i;
                  OS_STK  *pfill;
              
              
                  if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                      return (OS_PRIO_INVALID);
                  }
                  OS_ENTER_CRITICAL();
                  if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
                      OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
                                                           /* ... the same thing until task is created.              */
                      OS_EXIT_CRITICAL();
                      
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 6   

                      if (opt & OS_TASK_OPT_STK_CHK) {     /* See if stack checking has been enabled                 */
                          if (opt & OS_TASK_OPT_STK_CLR) { /* See if stack needs to be cleared                       */
                              pfill = pbos;                /* Yes, fill the stack with zeros                         */
                              for (i = 0; i < stk_size; i++) {
                                  #if OS_STK_GROWTH == 1
                                  *pfill++ = (OS_STK)0;
                                  #else
                                  *pfill-- = (OS_STK)0;
                                  #endif
                              }
                          }
                      }
                      
                      psp = (void *)OSTaskStkInit(task, dataptr, ptos, opt); /* Initialize the task's stack            *
             -/
                      err = OSTCBInit(prio, psp, pbos, id, stk_size, pext, opt);         
                      if (err == OS_NO_ERR) {
                          OS_ENTER_CRITICAL();
                          OSTaskCtr++;                                     /* Increment the #tasks counter           */
                          OSTaskCreateHook(OSTCBPrioTbl[prio]);            /* Call user defined hook                 */
                          OS_EXIT_CRITICAL();
                          if (OSRunning) {                 /* Find highest priority task if multitasking has started */
                              OSSched();
                          }
                      } else {
                          OS_ENTER_CRITICAL();
                          OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
                          OS_EXIT_CRITICAL();
                      }
                      return (err);
                  } else {
                      OS_EXIT_CRITICAL();
                      return (OS_PRIO_EXIST);
                  }
              }
              #endif
 338          /*$PAGE*/
 339          /*
 340          *********************************************************************************************************
 341          *                                            DELETE A TASK
 342          *
 343          * Description: This function allows you to delete a task.  The calling task can delete itself by 
 344          *              its own priority number.  The deleted task is returned to the dormant state and can be
 345          *              re-activated by creating the deleted task again.
 346          *
 347          * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitely delete
 348          *                      the current task without knowing its priority level by setting 'prio' to
 349          *                      OS_PRIO_SELF.
 350          *
 351          * Returns    : OS_NO_ERR           if the call is successful
 352          *              OS_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
 353          *              OS_PRIO_INVALID     if the priority you specify is higher that the maximum allowed 
 354          *                                  (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 355          *              OS_TASK_DEL_ERR     if the task you want to delete does not exist
 356          *              OS_TASK_DEL_ISR     if you tried to delete a task from an ISR
 357          *
 358          * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
 359          *                    a) by making it not ready
 360          *                    b) by removing it from any wait lists
 361          *                    c) by preventing OSTimeTick() from making the task ready to run.
 362          *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
 363          *              2) The function OSDummy() is called after OS_EXIT_CRITICAL() because, on most processors, 
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 7   

 364          *                 the next instruction following the enable interrupt instruction is ignored.  You can 
 365          *                 replace OSDummy() with a macro that basically executes a NO OP (i.e. OS_NOP()).  The 
 366          *                 NO OP macro would avoid the execution time of the function call and return.
 367          *              3) An ISR cannot delete a task.
 368          *              4) The lock nesting counter is incremented because, for a brief instant, if the current
 369          *                 task is being deleted, the current task would not be able to be rescheduled because it
 370          *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
 371          *                 from being schedule.  This means that the ISR would return to the current task which is
 372          *                 being deleted.  The rest of the deletion would thus be able to be completed.
 373          *********************************************************************************************************
 374          */
 375          /*$PAGE*/
 376          #if OS_TASK_DEL_EN
              INT8U OSTaskDel (INT8U prio)reentrant
              {
                  OS_TCB   *ptcb;
                  OS_EVENT *pevent;
              
              
                  if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to delete idle task     */
                      return (OS_TASK_DEL_IDLE);
                  }
                  if (prio >= OS_LOWEST_PRIO && prio != OS_PRIO_SELF) {       /* Task priority valid ?               */
                      return (OS_PRIO_INVALID);
                  }
                  OS_ENTER_CRITICAL();
                  if (OSIntNesting > 0) {                                     /* See if trying to delete from ISR    */
                      OS_EXIT_CRITICAL();
                      return (OS_TASK_DEL_ISR);
                  }
                  if (prio == OS_PRIO_SELF) {                                 /* See if requesting to delete self    */
                      prio = OSTCBCur->OSTCBPrio;                             /* Set priority to delete to current   */
                  }
                  if ((ptcb = OSTCBPrioTbl[prio]) != (OS_TCB *)0) {           /* Task to delete must exist           */
                      if ((OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {/* Make task not ready                 */
                          OSRdyGrp &= ~ptcb->OSTCBBitY;
                      }
                      if ((pevent = ptcb->OSTCBEventPtr) != (OS_EVENT *)0) {  /* If task is waiting on event         */
                          if ((pevent->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) { /* ... remove task from */
                              pevent->OSEventGrp &= ~ptcb->OSTCBBitY;                        /* ... event ctrl block */
                          }
                      }
                      ptcb->OSTCBDly  = 0;                                    /* Prevent OSTimeTick() from updating  */
                      ptcb->OSTCBStat = OS_STAT_RDY;                          /* Prevent task from being resumed     */
                      OSLockNesting++;
                      OS_EXIT_CRITICAL();                                     /* Enabling INT. ignores next instruc. */
                      OSDummy();                                              /* ... Dummy ensures that INTs will be */
                      OS_ENTER_CRITICAL();                                    /* ... disabled HERE!                  */
                      OSLockNesting--;
                      OSTaskDelHook(ptcb);                                    /* Call user defined hook              */
                      OSTaskCtr--;                                            /* One less task being managed         */
                      OSTCBPrioTbl[prio] = (OS_TCB *)0;                       /* Clear old priority entry            */
                      if (ptcb->OSTCBPrev == (OS_TCB *)0) {                   /* Remove from TCB chain               */
                          ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
                          OSTCBList                  = ptcb->OSTCBNext;
                      } else {
                          ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
                          ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
                      }
                      ptcb->OSTCBNext = OSTCBFreeList;                        /* Return TCB to free TCB list         */
                      OSTCBFreeList   = ptcb;
                      OS_EXIT_CRITICAL();
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 8   

                      OSSched();                                              /* Find new highest priority task      */
                      return (OS_NO_ERR);
                  } else {
                      OS_EXIT_CRITICAL();
                      return (OS_TASK_DEL_ERR);
                  }
              }
              #endif
 434          /*$PAGE*/
 435          /*
 436          *********************************************************************************************************
 437          *                                    REQUEST THAT A TASK DELETE ITSELF
 438          *
 439          * Description: This function is used to:
 440          *                   a) notify a task to delete itself.
 441          *                   b) to see if a task requested that the current task delete itself.
 442          *              This function is a little tricky to understand.  Basically, you have a task that needs
 443          *              to be deleted however, this task has resources that it has allocated (memory buffers,
 444          *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
 445          *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
 446          *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
 447          *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
 448          *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
 449          *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
 450          *              value is OS_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
 451          *              this:
 452          *
 453          *                   void Task(void *dataptr)
 454          *                   {
 455          *                       .
 456          *                       .
 457          *                       while (1) {
 458          *                           OSTimeDly(1);
 459          *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_TASK_DEL_REQ) {
 460          *                               Release any owned resources;
 461          *                               De-allocate any dynamic memory;
 462          *                               OSTaskDel(OS_PRIO_SELF);
 463          *                           }
 464          *                       }
 465          *                   }
 466          *
 467          * Arguments  : prio    is the priority of the task to request the delete from
 468          *
 469          * Returns    : OS_NO_ERR          if the task exist and the request has been registered
 470          *              OS_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
 471          *                                 the request has been executed.
 472          *              OS_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
 473          *              OS_PRIO_INVALID    if the priority you specify is higher that the maximum allowed 
 474          *                                 (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 475          *              OS_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be 
 476          *                                 deleted.
 477          *********************************************************************************************************
 478          */
 479          /*$PAGE*/
 480          #if OS_TASK_DEL_EN
              INT8U OSTaskDelReq (INT8U prio)reentrant
              {
                  BOOLEAN  stat;
                  INT8U    err;
                  OS_TCB  *ptcb;
              
              
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 9   

                  if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to delete idle task     */
                      return (OS_TASK_DEL_IDLE);
                  }
                  if (prio >= OS_LOWEST_PRIO && prio != OS_PRIO_SELF) {       /* Task priority valid ?               */
                      return (OS_PRIO_INVALID);
                  }
                  if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
                      OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
                      stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
                      OS_EXIT_CRITICAL();
                      return (stat);
                  } else {
                      OS_ENTER_CRITICAL();
                      if ((ptcb = OSTCBPrioTbl[prio]) != (OS_TCB *)0) {       /* Task to delete must exist           */
                          ptcb->OSTCBDelReq = OS_TASK_DEL_REQ;                /* Set flag indicating task to be DEL. */
                          err               = OS_NO_ERR;
                      } else {
                          err               = OS_TASK_NOT_EXIST;              /* Task must be deleted                */
                      }
                      OS_EXIT_CRITICAL();
                      return (err);
                  }
              }
              #endif
 512          /*$PAGE*/
 513          /*
 514          *********************************************************************************************************
 515          *                                        RESUME A SUSPENDED TASK
 516          *
 517          * Description: This function is called to resume a previously suspended task.  This is the only call that
 518          *              will remove an explicit task suspension.
 519          *
 520          * Arguments  : prio     is the priority of the task to resume.
 521          *
 522          * Returns    : OS_NO_ERR                if the requested task is resumed
 523          *              OS_PRIO_INVALID          if the priority you specify is higher that the maximum allowed 
 524          *                                       (i.e. >= OS_LOWEST_PRIO)
 525          *              OS_TASK_RESUME_PRIO      if the task to resume does not exist
 526          *              OS_TASK_NOT_SUSPENDED    if the task to resume has not been suspended
 527          *********************************************************************************************************
 528          */
 529          
 530          #if OS_TASK_SUSPEND_EN
              INT8U OSTaskResume (INT8U prio)reentrant
              {
                  OS_TCB   *ptcb;
              
              
                  if (prio >= OS_LOWEST_PRIO) {                               /* Make sure task priority is valid    */
                      return (OS_PRIO_INVALID);
                  }
                  OS_ENTER_CRITICAL();
                  if ((ptcb = OSTCBPrioTbl[prio]) == (OS_TCB *)0) {           /* Task to suspend must exist          */
                      OS_EXIT_CRITICAL();
                      return (OS_TASK_RESUME_PRIO);
                  } else {
                      if (ptcb->OSTCBStat & OS_STAT_SUSPEND) {                           /* Task must be suspended   */
                          if (((ptcb->OSTCBStat &= ~OS_STAT_SUSPEND) == OS_STAT_RDY) &&  /* Remove suspension        */
                               (ptcb->OSTCBDly  == 0)) {                                 /* Must not be delayed      */
                              OSRdyGrp               |= ptcb->OSTCBBitY;                 /* Make task ready to run   */
                              OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
                              OS_EXIT_CRITICAL();
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 10  

                              OSSched();
                          } else {
                              OS_EXIT_CRITICAL();
                          }
                          return (OS_NO_ERR);
                      } else {
                          OS_EXIT_CRITICAL();
                          return (OS_TASK_NOT_SUSPENDED);
                      }
                  }
              }
              #endif
 562          /*$PAGE*/
 563          /*
 564          *********************************************************************************************************
 565          *                                             STACK CHECKING 
 566          *
 567          * Description: This function is called to check the amount of free memory left on the specified task's
 568          *              stack.
 569          *
 570          * Arguments  : prio     is the task priority
 571          *
 572          *              dataptr    is a pointer to a data structure of type OS_STK_DATA.
 573          *
 574          * Returns    : OS_NO_ERR           upon success
 575          *              OS_PRIO_INVALID     if the priority you specify is higher that the maximum allowed 
 576          *                                  (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 577          *              OS_TASK_NOT_EXIST   if the desired task has not been created
 578          *              OS_TASK_OPT_ERR     if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
 579          *********************************************************************************************************
 580          */
 581          #if   OS_TASK_CREATE_EXT_EN
              INT8U OSTaskStkChk (INT8U prio, OS_STK_DATA *dataptr)reentrant
              {
                  OS_TCB  *ptcb;
                  OS_STK  *pchk;
                  INT32U   free;
                  INT32U   size;
              
              
                  dataptr->OSFree = 0;                                          /* Assume failure, set to 0 size       *
             -/
                  dataptr->OSUsed = 0;
                  if (prio > OS_LOWEST_PRIO && prio != OS_PRIO_SELF) {        /* Make sure task priority is valid    */
                      return (OS_PRIO_INVALID);
                  }
                  OS_ENTER_CRITICAL();
                  if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
                      prio = OSTCBCur->OSTCBPrio;
                  }
                  ptcb = OSTCBPrioTbl[prio];
                  if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
                      OS_EXIT_CRITICAL();
                      return (OS_TASK_NOT_EXIST);
                  }
                  if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
                      OS_EXIT_CRITICAL();
                      return (OS_TASK_OPT_ERR);
                  }
                  free = 0;
                  size = ptcb->OSTCBStkSize;
                  pchk = ptcb->OSTCBStkBottom;
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 11  

                  OS_EXIT_CRITICAL();
              #if OS_STK_GROWTH == 1
                  while (*pchk++ == 0) {                            /* Compute the number of zero entries on the stk */
                      free++;
                  }
              #else
                  while (*pchk-- == 0) {
                      free++;
                  }
              #endif
                  dataptr->OSFree = free * sizeof(OS_STK);            /* Compute number of free bytes on the stack     *
             -/
                  dataptr->OSUsed = (size - free) * sizeof(OS_STK);   /* Compute number of bytes used on the stack     *
             -/
                  return (OS_NO_ERR);
              }
              #endif
 626          /*$PAGE*/
 627          /*
 628          *********************************************************************************************************
 629          *                                            SUSPEND A TASK
 630          *
 631          * Description: This function is called to suspend a task.  The task can be the calling task if the
 632          *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
 633          *
 634          * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
 635          *                       calling task will suspend itself and rescheduling will occur.
 636          *
 637          * Returns    : OS_NO_ERR                if the requested task is suspended
 638          *              OS_TASK_SUSPEND_IDLE     if you attempted to suspend the idle task which is not allowed.
 639          *              OS_PRIO_INVALID          if the priority you specify is higher that the maximum allowed 
 640          *                                       (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 641          *              OS_TASK_SUSPEND_PRIO     if the task to suspend does not exist
 642          *
 643          * Note       : You should use this function with great care.  If you suspend a task that is waiting for
 644          *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
 645          *              running when the event arrives.
 646          *********************************************************************************************************
 647          */
 648          
 649          #if OS_TASK_SUSPEND_EN
              INT8U OSTaskSuspend (INT8U prio)reentrant
              {
                  BOOLEAN   self;
                  OS_TCB   *ptcb;
              
              
                  if (prio == OS_IDLE_PRIO) {                                 /* Not allowed to suspend idle task    */
                      return (OS_TASK_SUSPEND_IDLE);
                  }
                  if (prio >= OS_LOWEST_PRIO && prio != OS_PRIO_SELF) {       /* Task priority valid ?               */
                      return (OS_PRIO_INVALID);
                  }
                  OS_ENTER_CRITICAL();
                  if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
                      prio = OSTCBCur->OSTCBPrio;
                      self = TRUE;
                  } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
                      self = TRUE;
                  } else {
                      self = FALSE;                                           /* No suspending another task          */
                  }
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 12  

                  if ((ptcb = OSTCBPrioTbl[prio]) == (OS_TCB *)0) {                /* Task to suspend must exist     */
                      OS_EXIT_CRITICAL();
                      return (OS_TASK_SUSPEND_PRIO);
                  } else {
                      if ((OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {     /* Make task not ready            */
                          OSRdyGrp &= ~ptcb->OSTCBBitY;
                      }
                      ptcb->OSTCBStat |= OS_STAT_SUSPEND;                          /* Status of task is 'SUSPENDED'  */
                      OS_EXIT_CRITICAL();
                      if (self == TRUE) {                                          /* Context switch only if SELF    */
                          OSSched();
                      }
                      return (OS_NO_ERR);
                  }
              }
              #endif
 687          /*$PAGE*/
 688          /*
 689          *********************************************************************************************************
 690          *                                            QUERY A TASK
 691          *
 692          * Description: This function is called to obtain a copy of the desired task's TCB.
 693          *
 694          * Arguments  : prio     is the priority of the task to obtain information from.  
 695          *
 696          * Returns    : OS_NO_ERR       if the requested task is suspended
 697          *              OS_PRIO_INVALID if the priority you specify is higher that the maximum allowed 
 698          *                              (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
 699          *              OS_PRIO_ERR     if the desired task has not been created 
 700          *********************************************************************************************************
 701          */
 702          #if OS_Task_Query_EN
              INT8U OSTaskQuery (INT8U prio, OS_TCB *dataptr)reentrant
              {
                  OS_TCB *ptcb;
              
              
                  if (prio > OS_LOWEST_PRIO && prio != OS_PRIO_SELF) {   /* Task priority valid ?                    */
                      return (OS_PRIO_INVALID);
                  }
                  OS_ENTER_CRITICAL();
                  if (prio == OS_PRIO_SELF) {                            /* See if suspend SELF                      */
                      prio = OSTCBCur->OSTCBPrio;
                  }
                  if ((ptcb = OSTCBPrioTbl[prio]) == (OS_TCB *)0) {      /* Task to query must exist                 */
                      OS_EXIT_CRITICAL();
                      return (OS_PRIO_ERR);
                  }
                  *dataptr = *ptcb;                                        /* Copy TCB into user storage area          *
             -/
                  OS_EXIT_CRITICAL();
                  return (OS_NO_ERR);
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    349    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V8.02   OS_TASK                                                               02/27/2009 13:40:12 PAGE 13  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
